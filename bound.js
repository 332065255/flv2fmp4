/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _chimeeFlv2fmp = __webpack_require__(1);\n\nvar _chimeeFlv2fmp2 = _interopRequireDefault(_chimeeFlv2fmp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// var cpu=require('chimee-flv2fmp4')\n\nvar temp = new _chimeeFlv2fmp2.default(); /* eslint-disable */\n\n// import cpu from './flv2fmp4';\n\nconsole.log(temp);\nwindow.flvParse = {\n    mp4File: null,\n    succ: null,\n    // ftyp_moov:null,\n    tracks: [],\n    baseTime: 0,\n    setFlv: function setFlv(uint8, baseTime) {\n        if (flvParse.baseTime != baseTime) {\n            flvParse.baseTime = baseTime;\n            temp.seek(baseTime);\n        }\n        if (window.mp4Init) {\n            temp.onInitSegment = window.mp4Init;\n        }\n        if (window.onMediaSegment) {\n            temp.onMediaSegment = window.onMediaSegment;\n        }\n        if (window.seekCallBack) {\n            // temp.seekCallBack = window.se\n            temp.seekCallBack = window.seekCallBack;\n        }\n        if (window.onMediaInfo) {\n            temp.onMediaInfo = window.onMediaInfo;\n        }\n        return temp.setflv(uint8.buffer, baseTime);\n\n        // 用来获取moov\n    },\n    setLocFlv: function setLocFlv(uin8) {\n        return temp.setflvloc(uin8);\n    }\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9mbHZFbnRlci5qcz9iZGJiIl0sIm5hbWVzIjpbInRlbXAiLCJjb25zb2xlIiwibG9nIiwid2luZG93IiwiZmx2UGFyc2UiLCJtcDRGaWxlIiwic3VjYyIsInRyYWNrcyIsImJhc2VUaW1lIiwic2V0Rmx2IiwidWludDgiLCJzZWVrIiwibXA0SW5pdCIsIm9uSW5pdFNlZ21lbnQiLCJvbk1lZGlhU2VnbWVudCIsInNlZWtDYWxsQmFjayIsIm9uTWVkaWFJbmZvIiwic2V0Zmx2IiwiYnVmZmVyIiwic2V0TG9jRmx2IiwidWluOCIsInNldGZsdmxvYyJdLCJtYXBwaW5ncyI6Ijs7QUFHQTs7Ozs7O0FBQ0E7O0FBRUEsSUFBTUEsT0FBTyw2QkFBYixDLENBTkE7O0FBRUE7O0FBS0FDLFFBQVFDLEdBQVIsQ0FBWUYsSUFBWjtBQUNBRyxPQUFPQyxRQUFQLEdBQWtCO0FBQ2RDLGFBQVMsSUFESztBQUVkQyxVQUFNLElBRlE7QUFHZDtBQUNBQyxZQUFRLEVBSk07QUFLZEMsY0FBVSxDQUxJO0FBTWRDLFVBTmMsa0JBTVBDLEtBTk8sRUFNQUYsUUFOQSxFQU1VO0FBQ3BCLFlBQUlKLFNBQVNJLFFBQVQsSUFBcUJBLFFBQXpCLEVBQW1DO0FBQy9CSixxQkFBU0ksUUFBVCxHQUFvQkEsUUFBcEI7QUFDQVIsaUJBQUtXLElBQUwsQ0FBVUgsUUFBVjtBQUNIO0FBQ0QsWUFBSUwsT0FBT1MsT0FBWCxFQUFvQjtBQUNoQlosaUJBQUthLGFBQUwsR0FBcUJWLE9BQU9TLE9BQTVCO0FBQ0g7QUFDRCxZQUFJVCxPQUFPVyxjQUFYLEVBQTJCO0FBQ3ZCZCxpQkFBS2MsY0FBTCxHQUFzQlgsT0FBT1csY0FBN0I7QUFDSDtBQUNELFlBQUlYLE9BQU9ZLFlBQVgsRUFBeUI7QUFDckI7QUFDQWYsaUJBQUtlLFlBQUwsR0FBb0JaLE9BQU9ZLFlBQTNCO0FBQ0g7QUFDRCxZQUFJWixPQUFPYSxXQUFYLEVBQXdCO0FBQ3BCaEIsaUJBQUtnQixXQUFMLEdBQW1CYixPQUFPYSxXQUExQjtBQUNIO0FBQ0QsZUFBT2hCLEtBQUtpQixNQUFMLENBQVlQLE1BQU1RLE1BQWxCLEVBQTBCVixRQUExQixDQUFQOztBQUVBO0FBRUgsS0E1QmE7QUE2QmRXLGFBN0JjLHFCQTZCSkMsSUE3QkksRUE2QkU7QUFDWixlQUFPcEIsS0FBS3FCLFNBQUwsQ0FBZUQsSUFBZixDQUFQO0FBQ0g7QUEvQmEsQ0FBbEIiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5cbi8vIGltcG9ydCBjcHUgZnJvbSAnLi9mbHYyZm1wNCc7XG5pbXBvcnQgY3B1IGZyb20gJ2NoaW1lZS1mbHYyZm1wNCc7XG4vLyB2YXIgY3B1PXJlcXVpcmUoJ2NoaW1lZS1mbHYyZm1wNCcpXG5cbmNvbnN0IHRlbXAgPSBuZXcgY3B1KCk7XG5jb25zb2xlLmxvZyh0ZW1wKTtcbndpbmRvdy5mbHZQYXJzZSA9IHtcbiAgICBtcDRGaWxlOiBudWxsLFxuICAgIHN1Y2M6IG51bGwsXG4gICAgLy8gZnR5cF9tb292Om51bGwsXG4gICAgdHJhY2tzOiBbXSxcbiAgICBiYXNlVGltZTogMCxcbiAgICBzZXRGbHYodWludDgsIGJhc2VUaW1lKSB7XG4gICAgICAgIGlmIChmbHZQYXJzZS5iYXNlVGltZSAhPSBiYXNlVGltZSkge1xuICAgICAgICAgICAgZmx2UGFyc2UuYmFzZVRpbWUgPSBiYXNlVGltZTtcbiAgICAgICAgICAgIHRlbXAuc2VlayhiYXNlVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbmRvdy5tcDRJbml0KSB7XG4gICAgICAgICAgICB0ZW1wLm9uSW5pdFNlZ21lbnQgPSB3aW5kb3cubXA0SW5pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2luZG93Lm9uTWVkaWFTZWdtZW50KSB7XG4gICAgICAgICAgICB0ZW1wLm9uTWVkaWFTZWdtZW50ID0gd2luZG93Lm9uTWVkaWFTZWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aW5kb3cuc2Vla0NhbGxCYWNrKSB7XG4gICAgICAgICAgICAvLyB0ZW1wLnNlZWtDYWxsQmFjayA9IHdpbmRvdy5zZVxuICAgICAgICAgICAgdGVtcC5zZWVrQ2FsbEJhY2sgPSB3aW5kb3cuc2Vla0NhbGxCYWNrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aW5kb3cub25NZWRpYUluZm8pIHtcbiAgICAgICAgICAgIHRlbXAub25NZWRpYUluZm8gPSB3aW5kb3cub25NZWRpYUluZm87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbXAuc2V0Zmx2KHVpbnQ4LmJ1ZmZlciwgYmFzZVRpbWUpO1xuXG4gICAgICAgIC8vIOeUqOadpeiOt+WPlm1vb3ZcblxuICAgIH0sXG4gICAgc2V0TG9jRmx2KHVpbjgpIHtcbiAgICAgICAgcmV0dXJuIHRlbXAuc2V0Zmx2bG9jKHVpbjgpO1xuICAgIH1cbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vanMvZmx2RW50ZXIuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_chimee_helper__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_chimee_helper___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_chimee_helper__);\n\n\n/* eslint-disable */\nclass FlvTag {\n    constructor() {\n        this.tagType = -1;\n        this.dataSize = -1;\n        this.Timestamp = -1;\n        this.StreamID = -1;\n        this.body = -1;\n        this.time = -1;\n        this.arr = [];\n        this.size=-1;\n    }\n    getTime() {\n        // this.Timestamp.pop();\n        this.arr = [];\n        for (let i = 0; i < this.Timestamp.length; i++) {\n            this.arr.push((this.Timestamp[i].toString(16).length == 1 ? '0' + this.Timestamp[i].toString(16) : this.Timestamp[i].toString(16)));\n        }\n        this.arr.pop();\n        const time = this.arr.join('');\n        this.time = parseInt(time, 16);\n        return parseInt(time, 16);\n    }\n}\n\n/* eslint-disable */\nfunction decodeUTF8(uint8array) {\n    const out = [];\n    const input = uint8array;\n    let i = 0;\n    const length = uint8array.length;\n\n    while (i < length) {\n        if (input[i] < 0x80) {\n            out.push(String.fromCharCode(input[i]));\n            ++i;\n            continue;\n        } else if (input[i] < 0xC0) {\n            // fallthrough\n        } else if (input[i] < 0xE0) {\n            if (checkContinuation(input, i, 1)) {\n                const ucs4 = (input[i] & 0x1F) << 6 | (input[i + 1] & 0x3F);\n                if (ucs4 >= 0x80) {\n                    out.push(String.fromCharCode(ucs4 & 0xFFFF));\n                    i += 2;\n                    continue;\n                }\n            }\n        } else if (input[i] < 0xF0) {\n            if (checkContinuation(input, i, 2)) {\n                const ucs4 = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F;\n                if (ucs4 >= 0x800 && (ucs4 & 0xF800) !== 0xD800) {\n                    out.push(String.fromCharCode(ucs4 & 0xFFFF));\n                    i += 3;\n                    continue;\n                }\n            }\n        } else if (input[i] < 0xF8) {\n            if (checkContinuation(input, i, 3)) {\n                let ucs4 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12 |\n                    (input[i + 2] & 0x3F) << 6 | (input[i + 3] & 0x3F);\n                if (ucs4 > 0x10000 && ucs4 < 0x110000) {\n                    ucs4 -= 0x10000;\n                    out.push(String.fromCharCode((ucs4 >>> 10) | 0xD800));\n                    out.push(String.fromCharCode((ucs4 & 0x3FF) | 0xDC00));\n                    i += 4;\n                    continue;\n                }\n            }\n        }\n        out.push(String.fromCharCode(0xFFFD));\n        ++i;\n    }\n\n    return out.join('');\n}\n\nfunction checkContinuation(uint8array, start, checkLength) {\n    let array = uint8array;\n    if (start + checkLength < array.length) {\n        while (checkLength--) {\n            if ((array[++start] & 0xC0) !== 0x80)\n                return false;\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable */\n// Exponential-Golomb buffer decoder\nclass ExpGolomb {\n\n    constructor(uint8array) {\n        this.TAG = this.constructor.name;\n\n        this._buffer = uint8array;\n        this._buffer_index = 0;\n        this._total_bytes = uint8array.byteLength;\n        this._total_bits = uint8array.byteLength * 8;\n        this._current_word = 0;\n        this._current_word_bits_left = 0;\n    }\n\n    destroy() {\n        this._buffer = null;\n    }\n\n    _fillCurrentWord() {\n        const buffer_bytes_left = this._total_bytes - this._buffer_index;\n        if (buffer_bytes_left <= 0) { throw new IllegalStateException('ExpGolomb: _fillCurrentWord() but no bytes available'); }\n\n        const bytes_read = Math.min(4, buffer_bytes_left);\n        const word = new Uint8Array(4);\n        word.set(this._buffer.subarray(this._buffer_index, this._buffer_index + bytes_read));\n        this._current_word = new DataView(word.buffer).getUint32(0, false);\n\n        this._buffer_index += bytes_read;\n        this._current_word_bits_left = bytes_read * 8;\n    }\n\n    readBits(bits) {\n        if (bits > 32) { throw new InvalidArgumentException('ExpGolomb: readBits() bits exceeded max 32bits!'); }\n\n        if (bits <= this._current_word_bits_left) {\n            const result = this._current_word >>> (32 - bits);\n            this._current_word <<= bits;\n            this._current_word_bits_left -= bits;\n            return result;\n        }\n\n        let result = this._current_word_bits_left ? this._current_word : 0;\n        result = result >>> (32 - this._current_word_bits_left);\n        const bits_need_left = bits - this._current_word_bits_left;\n\n        this._fillCurrentWord();\n        const bits_read_next = Math.min(bits_need_left, this._current_word_bits_left);\n\n        const result2 = this._current_word >>> (32 - bits_read_next);\n        this._current_word <<= bits_read_next;\n        this._current_word_bits_left -= bits_read_next;\n\n        result = (result << bits_read_next) | result2;\n        return result;\n    }\n\n    readBool() {\n        return this.readBits(1) === 1;\n    }\n\n    readByte() {\n        return this.readBits(8);\n    }\n\n    _skipLeadingZero() {\n        let zero_count;\n        for (zero_count = 0; zero_count < this._current_word_bits_left; zero_count++) {\n            if ((this._current_word & (0x80000000 >>> zero_count)) !== 0) {\n                this._current_word <<= zero_count;\n                this._current_word_bits_left -= zero_count;\n                return zero_count;\n            }\n        }\n        this._fillCurrentWord();\n        return zero_count + this._skipLeadingZero();\n    }\n\n    readUEG() { // unsigned exponential golomb\n        const leading_zeros = this._skipLeadingZero();\n        return this.readBits(leading_zeros + 1) - 1;\n    }\n\n    readSEG() { // signed exponential golomb\n        const value = this.readUEG();\n        if (value & 0x01) {\n            return (value + 1) >>> 1;\n        } else {\n            return -1 * (value >>> 1);\n        }\n    }\n\n}\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable */\nclass SPSParser {\n\n    static _ebsp2rbsp(uint8array) {\n        const src = uint8array;\n        const src_length = src.byteLength;\n        const dst = new Uint8Array(src_length);\n        let dst_idx = 0;\n\n        for (let i = 0; i < src_length; i++) {\n            if (i >= 2) {\n                // Unescape: Skip 0x03 after 00 00\n                if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {\n                    continue;\n                }\n            }\n            dst[dst_idx] = src[i];\n            dst_idx++;\n        }\n\n        return new Uint8Array(dst.buffer, 0, dst_idx);\n    }\n\n    static parseSPS(uint8array) {\n        const rbsp = SPSParser._ebsp2rbsp(uint8array);\n        let gb = new ExpGolomb(rbsp);\n\n        gb.readByte();\n        const profile_idc = gb.readByte(); // profile_idc\n        gb.readByte(); // constraint_set_flags[5] + reserved_zero[3]\n        const level_idc = gb.readByte(); // level_idc\n        gb.readUEG(); // seq_parameter_set_id\n\n        const profile_string = SPSParser.getProfileString(profile_idc);\n        const level_string = SPSParser.getLevelString(level_idc);\n        let chroma_format_idc = 1;\n        let chroma_format = 420;\n        const chroma_format_table = [0, 420, 422, 444];\n        let bit_depth = 8;\n\n        if (profile_idc === 100 || profile_idc === 110 || profile_idc === 122 ||\n            profile_idc === 244 || profile_idc === 44 || profile_idc === 83 ||\n            profile_idc === 86 || profile_idc === 118 || profile_idc === 128 ||\n            profile_idc === 138 || profile_idc === 144) {\n\n            chroma_format_idc = gb.readUEG();\n            if (chroma_format_idc === 3) {\n                gb.readBits(1); // separate_colour_plane_flag\n            }\n            if (chroma_format_idc <= 3) {\n                chroma_format = chroma_format_table[chroma_format_idc];\n            }\n\n            bit_depth = gb.readUEG() + 8; // bit_depth_luma_minus8\n            gb.readUEG(); // bit_depth_chroma_minus8\n            gb.readBits(1); // qpprime_y_zero_transform_bypass_flag\n            if (gb.readBool()) { // seq_scaling_matrix_present_flag\n                const scaling_list_count = (chroma_format_idc !== 3) ? 8 : 12;\n                for (let i = 0; i < scaling_list_count; i++) {\n                    if (gb.readBool()) { // seq_scaling_list_present_flag\n                        if (i < 6) {\n                            SPSParser._skipScalingList(gb, 16);\n                        } else {\n                            SPSParser._skipScalingList(gb, 64);\n                        }\n                    }\n                }\n            }\n        }\n        gb.readUEG(); // log2_max_frame_num_minus4\n        const pic_order_cnt_type = gb.readUEG();\n        if (pic_order_cnt_type === 0) {\n            gb.readUEG(); // log2_max_pic_order_cnt_lsb_minus_4\n        } else if (pic_order_cnt_type === 1) {\n            gb.readBits(1); // delta_pic_order_always_zero_flag\n            gb.readSEG(); // offset_for_non_ref_pic\n            gb.readSEG(); // offset_for_top_to_bottom_field\n            const num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();\n            for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {\n                gb.readSEG(); // offset_for_ref_frame\n            }\n        }\n        gb.readUEG(); // max_num_ref_frames\n        gb.readBits(1); // gaps_in_frame_num_value_allowed_flag\n\n        const pic_width_in_mbs_minus1 = gb.readUEG();\n        const pic_height_in_map_units_minus1 = gb.readUEG();\n\n        const frame_mbs_only_flag = gb.readBits(1);\n        if (frame_mbs_only_flag === 0) {\n            gb.readBits(1); // mb_adaptive_frame_field_flag\n        }\n        gb.readBits(1); // direct_8x8_inference_flag\n\n        let frame_crop_left_offset = 0;\n        let frame_crop_right_offset = 0;\n        let frame_crop_top_offset = 0;\n        let frame_crop_bottom_offset = 0;\n\n        const frame_cropping_flag = gb.readBool();\n        if (frame_cropping_flag) {\n            frame_crop_left_offset = gb.readUEG();\n            frame_crop_right_offset = gb.readUEG();\n            frame_crop_top_offset = gb.readUEG();\n            frame_crop_bottom_offset = gb.readUEG();\n        }\n\n        let sar_width = 1,\n            sar_height = 1;\n        let fps = 0,\n            fps_fixed = true,\n            fps_num = 0,\n            fps_den = 0;\n\n        const vui_parameters_present_flag = gb.readBool();\n        if (vui_parameters_present_flag) {\n            if (gb.readBool()) { // aspect_ratio_info_present_flag\n                const aspect_ratio_idc = gb.readByte();\n                const sar_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\n                const sar_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];\n\n                if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n                    sar_width = sar_w_table[aspect_ratio_idc - 1];\n                    sar_height = sar_h_table[aspect_ratio_idc - 1];\n                } else if (aspect_ratio_idc === 255) {\n                    sar_width = gb.readByte() << 8 | gb.readByte();\n                    sar_height = gb.readByte() << 8 | gb.readByte();\n                }\n            }\n\n            if (gb.readBool()) { // overscan_info_present_flag\n                gb.readBool(); // overscan_appropriate_flag\n            }\n            if (gb.readBool()) { // video_signal_type_present_flag\n                gb.readBits(4); // video_format & video_full_range_flag\n                if (gb.readBool()) { // colour_description_present_flag\n                    gb.readBits(24); // colour_primaries & transfer_characteristics & matrix_coefficients\n                }\n            }\n            if (gb.readBool()) { // chroma_loc_info_present_flag\n                gb.readUEG(); // chroma_sample_loc_type_top_field\n                gb.readUEG(); // chroma_sample_loc_type_bottom_field\n            }\n            if (gb.readBool()) { // timing_info_present_flag\n                const num_units_in_tick = gb.readBits(32);\n                const time_scale = gb.readBits(32);\n                fps_fixed = gb.readBool(); // fixed_frame_rate_flag\n\n                fps_num = time_scale;\n                fps_den = num_units_in_tick * 2;\n                fps = fps_num / fps_den;\n            }\n        }\n\n        let sarScale = 1;\n        if (sar_width !== 1 || sar_height !== 1) {\n            sarScale = sar_width / sar_height;\n        }\n\n        let crop_unit_x = 0,\n            crop_unit_y = 0;\n        if (chroma_format_idc === 0) {\n            crop_unit_x = 1;\n            crop_unit_y = 2 - frame_mbs_only_flag;\n        } else {\n            const sub_wc = (chroma_format_idc === 3) ? 1 : 2;\n            const sub_hc = (chroma_format_idc === 1) ? 2 : 1;\n            crop_unit_x = sub_wc;\n            crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);\n        }\n\n        let codec_width = (pic_width_in_mbs_minus1 + 1) * 16;\n        let codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);\n\n        codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;\n        codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;\n\n        const present_width = Math.ceil(codec_width * sarScale);\n\n        gb.destroy();\n        gb = null;\n\n        return {\n            profile_string, // baseline, high, high10, ...\n            level_string, // 3, 3.1, 4, 4.1, 5, 5.1, ...\n            bit_depth, // 8bit, 10bit, ...\n            chroma_format, // 4:2:0, 4:2:2, ...\n            chroma_format_string: SPSParser.getChromaFormatString(chroma_format),\n\n            frame_rate: {\n                fixed: fps_fixed,\n                fps,\n                fps_den,\n                fps_num\n            },\n\n            sar_ratio: {\n                width: sar_width,\n                height: sar_height\n            },\n\n            codec_size: {\n                width: codec_width,\n                height: codec_height\n            },\n\n            present_size: {\n                width: present_width,\n                height: codec_height\n            }\n        };\n    }\n\n    static _skipScalingList(gb, count) {\n        let last_scale = 8,\n            next_scale = 8;\n        let delta_scale = 0;\n        for (let i = 0; i < count; i++) {\n            if (next_scale !== 0) {\n                delta_scale = gb.readSEG();\n                next_scale = (last_scale + delta_scale + 256) % 256;\n            }\n            last_scale = (next_scale === 0) ? last_scale : next_scale;\n        }\n    }\n\n    static getProfileString(profile_idc) {\n        switch (profile_idc) {\n            case 66:\n                return 'Baseline';\n            case 77:\n                return 'Main';\n            case 88:\n                return 'Extended';\n            case 100:\n                return 'High';\n            case 110:\n                return 'High10';\n            case 122:\n                return 'High422';\n            case 244:\n                return 'High444';\n            default:\n                return 'Unknown';\n        }\n    }\n\n    static getLevelString(level_idc) {\n        return (level_idc / 10).toFixed(1);\n    }\n\n    static getChromaFormatString(chroma) {\n        switch (chroma) {\n            case 420:\n                return '4:2:0';\n            case 422:\n                return '4:2:2';\n            case 444:\n                return '4:4:4';\n            default:\n                return 'Unknown';\n        }\n    }\n\n}\n\n/* eslint-disable */\nconst le = (function() {\n    const buf = new ArrayBuffer(2);\n    (new DataView(buf)).setInt16(0, 256, true); // little-endian write\n    return (new Int16Array(buf))[0] === 256; // platform-spec read, if equal then LE\n})();\nclass flvDemux {\n\n    constructor() {\n\n    }\n    static parseObject(arrayBuffer, dataOffset, dataSize) {\n\n        const name = flvDemux.parseString(arrayBuffer, dataOffset, dataSize);\n        const value = flvDemux.parseScript(arrayBuffer, dataOffset + name.size);\n        const isObjectEnd = value.objectEnd;\n\n        return {\n            data: {\n                name: name.data,\n                value: value.data\n            },\n            size: value.size,\n            objectEnd: isObjectEnd\n        };\n    }\n\n    static parseVariable(arrayBuffer, dataOffset, dataSize) {\n        return flvDemux.parseObject(arrayBuffer, dataOffset, dataSize);\n    }\n    static parseLongString(arrayBuffer, dataOffset, dataSize) {\n\n        const v = new DataView(arrayBuffer, dataOffset);\n        const length = v.getUint32(0, !le);\n\n        let str;\n        if (length > 0) {\n            str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 4, length));\n        } else {\n            str = '';\n        }\n\n        return {\n            data: str,\n            size: 4 + length\n        };\n    }\n    static parseDate(arrayBuffer, dataOffset, dataSize) {\n\n        const v = new DataView(arrayBuffer, dataOffset);\n        let timestamp = v.getFloat64(0, !le);\n        const localTimeOffset = v.getInt16(8, !le);\n        timestamp += localTimeOffset * 60 * 1000; // get UTC time\n\n        return {\n            data: new Date(timestamp),\n            size: 8 + 2\n        };\n    }\n    static parseString(arrayBuffer, dataOffset, dataSize) {\n        const v = new DataView(arrayBuffer, dataOffset);\n        const length = v.getUint16(0, !le);\n        let str;\n        if (length > 0) {\n            str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 2, length));\n        } else {\n            str = '';\n        }\n        return {\n            data: str,\n            size: 2 + length\n        };\n    }\n\n    /**\n     * 解析metadata\n     */\n    static parseMetadata(arr) {\n        const name = flvDemux.parseScript(arr, 0);\n        const value = flvDemux.parseScript(arr, name.size, arr.length - name.size);\n        // return {}\n        const data = {};\n        data[name.data] = value.data;\n        return data;\n    }\n\n    static parseScript(arr, offset, dataSize) {\n        let dataOffset = offset;\n        const object = {};\n        const uint8 = new Uint8Array(arr);\n        const buffer = uint8.buffer;\n        const dv = new DataView(buffer, 0, dataSize);\n        let value = null;\n        let objectEnd = false;\n        const type = (dv.getUint8(dataOffset));\n        dataOffset += 1;\n\n        switch (type) {\n            case 0: // Number(Double) type\n                value = dv.getFloat64(dataOffset, !le);\n                dataOffset += 8;\n                break;\n            case 1:\n                { // Boolean type\n                    const b = dv.getUint8(dataOffset);\n                    value = !!b;\n                    dataOffset += 1;\n                    break;\n                }\n            case 2:\n                { // String type\n                    // dataOffset += 1;\n                    const amfstr = flvDemux.parseString(buffer, dataOffset);\n                    value = amfstr.data;\n                    dataOffset += amfstr.size;\n                    break;\n                }\n            case 3:\n\n                { // Object(s) type\n                    value = {};\n                    let terminal = 0; // workaround for malformed Objects which has missing ScriptDataObjectEnd\n                    if ((dv.getUint32(dataSize - 4, !le) & 0x00FFFFFF) === 9) {\n                        terminal = 3;\n                    }\n                    while (dataOffset < dataSize - 4) { // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\n                        const amfobj = flvDemux.parseObject(buffer, dataOffset, dataSize - offset - terminal);\n\n                        if (amfobj.objectEnd) { break; }\n                        value[amfobj.data.name] = amfobj.data.value;\n                        // dataOffset += amfobj.size;\n                        dataOffset = amfobj.size;\n                    }\n                    if (dataOffset <= dataSize - 3) {\n                        const marker = v.getUint32(dataOffset - 1, !le) & 0x00FFFFFF;\n                        if (marker === 9) {\n                            dataOffset += 3;\n                        }\n                    }\n                    break;\n                }\n            case 8:\n                { // ECMA array type (Mixed array)\n                    value = {};\n                    // dataOffset += 1;\n                    dataOffset += 4; // ECMAArrayLength(UI32)\n                    let terminal = 0; // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\n                    if ((dv.getUint32(dataSize - 4, !le) & 0x00FFFFFF) === 9) {\n                        terminal = 3;\n                    }\n                    while (dataOffset < dataSize - 8) { // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\n                        const amfvar = flvDemux.parseVariable(buffer, dataOffset);\n\n                        if (amfvar.objectEnd) { break; }\n                        value[amfvar.data.name] = amfvar.data.value;\n                        dataOffset = amfvar.size;\n                    }\n                    if (dataOffset <= dataSize - 3) {\n                        const marker = dv.getUint32(dataOffset - 1, !le) & 0x00FFFFFF;\n                        if (marker === 9) {\n                            dataOffset += 3;\n                        }\n                    }\n                    break;\n                }\n            case 9: // ScriptDataObjectEnd\n                value = undefined;\n                dataOffset = 1;\n                objectEnd = true;\n                break;\n            case 10:\n                { // Strict array type\n                    // ScriptDataValue[n]. NOTE: according to video_file_format_spec_v10_1.pdf\n                    value = [];\n                    const strictArrayLength = dv.getUint32(dataOffset, !le);\n                    dataOffset += 4;\n                    for (let i = 0; i < strictArrayLength; i++) {\n                        const val = flvDemux.parseScript(buffer, dataOffset);\n                        value.push(val.data);\n                        dataOffset = val.size;\n                    }\n                    break;\n                }\n            case 11:\n                { // Date type\n                    const date = flvDemux.parseDate(buffer, dataOffset + 1, dataSize - 1);\n                    value = date.data;\n                    dataOffset += date.size;\n                    break;\n                }\n            case 12:\n                { // Long string type\n                    const amfLongStr = flvDemux.parseString(buffer, dataOffset + 1, dataSize - 1);\n                    value = amfLongStr.data;\n                    dataOffset += amfLongStr.size;\n                    break;\n                }\n            default:\n                // ignore and skip\n                dataOffset = dataSize;\n                console.log('AMF', 'Unsupported AMF value type ' + type);\n        }\n        return {\n            data: value,\n            size: dataOffset,\n        };\n    }\n}\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable */\nclass MediaInfo {\n\n    constructor() {\n        this.mimeType = null;\n        this.duration = null;\n\n        this.hasAudio = null;\n        this.hasVideo = null;\n        this.audioCodec = null;\n        this.videoCodec = null;\n        this.audioDataRate = null;\n        this.videoDataRate = null;\n\n        this.audioSampleRate = null;\n        this.audioChannelCount = null;\n\n        this.width = null;\n        this.height = null;\n        this.fps = null;\n        this.profile = null;\n        this.level = null;\n        this.chromaFormat = null;\n        this.sarNum = null;\n        this.sarDen = null;\n\n        this.metadata = null;\n        this.segments = null; // MediaInfo[]\n        this.segmentCount = null;\n        this.hasKeyframesIndex = null;\n        this.keyframesIndex = null;\n    }\n\n    isComplete() {\n        const audioInfoComplete = (this.hasAudio === false) ||\n            (this.hasAudio === true &&\n                this.audioCodec != null &&\n                this.audioSampleRate != null &&\n                this.audioChannelCount != null);\n\n        const videoInfoComplete = (this.hasVideo === false) ||\n            (this.hasVideo === true &&\n                this.videoCodec != null &&\n                this.width != null &&\n                this.height != null &&\n                this.fps != null &&\n                this.profile != null &&\n                this.level != null &&\n                this.chromaFormat != null &&\n                this.sarNum != null &&\n                this.sarDen != null);\n\n        // keyframesIndex may not be present\n        return this.mimeType != null &&\n            this.duration != null &&\n            this.metadata != null &&\n            this.hasKeyframesIndex != null &&\n            audioInfoComplete &&\n            videoInfoComplete;\n    }\n\n    isSeekable() {\n        return this.hasKeyframesIndex === true;\n    }\n}\n\nclass Error {\n    constructor (type) {\n        this.type = type;\n    }\n}\n\n/* eslint-disable */\nclass tagDemux {\n    constructor() {\n        this.TAG = this.constructor.name;\n\n        this._config = {};\n\n        this._onError = null;\n        this._onMediaInfo = null;\n        this._onTrackMetadata = null;\n        this._onDataAvailable = null;\n\n        this._dataOffset = 0;\n        this._firstParse = true;\n        this._dispatch = false;\n\n        this._hasAudio = false;\n        this._hasVideo = false;\n\n        this._audioInitialMetadataDispatched = false;\n        this._videoInitialMetadataDispatched = false;\n\n        this._mediaInfo = new MediaInfo();\n        this._mediaInfo.hasAudio = this._hasAudio;\n        this._mediaInfo.hasVideo = this._hasVideo;\n        this._metadata = null;\n        this._audioMetadata = null;\n        this._videoMetadata = null;\n\n        this._naluLengthSize = 4;\n        this._timestampBase = 0; // int32, in milliseconds\n        this._timescale = 1000;\n        this._duration = 0; // int32, in milliseconds\n        this._durationOverrided = false;\n        this._referenceFrameRate = {\n            fixed: true,\n            fps: 23.976,\n            fps_num: 23976,\n            fps_den: 1000\n        };\n\n        this._videoTrack = { type: 'video', id: 1, sequenceNumber: 0, addcoefficient: 2, samples: [], length: 0 };\n        this._audioTrack = { type: 'audio', id: 2, sequenceNumber: 0, addcoefficient: 2, samples: [], length: 0 };\n\n        this._littleEndian = (function() {\n            const buf = new ArrayBuffer(2);\n            (new DataView(buf)).setInt16(0, 256, true); // little-endian write\n            return (new Int16Array(buf))[0] === 256; // platform-spec read, if equal then LE\n        })();\n    }\n    set hasAudio(s){\n        this._mediaInfo.hasAudio = this._hasAudio=s;\n    }\n    set hasVideo(s){\n        this._mediaInfo.hasVideo = this._hasVideo=s;\n    }\n    onMediaInfo(callback) {\n        this._onMediaInfo = callback;\n    }\n    parseMetadata(arr) {\n        const data = flvDemux.parseMetadata(arr);\n        this._parseScriptData(data);\n        // console.log(this._mediaInfo, this._mediaInfo.isComplete());\n    }\n    _parseScriptData(obj) {\n        const scriptData = obj;\n\n        if (scriptData.hasOwnProperty('onMetaData')) {\n            if (this._metadata) {\n                // console.log(this.TAG, 'Found another onMetaData tag!');\n            }\n            this._metadata = scriptData;\n            const onMetaData = this._metadata.onMetaData;\n\n            if (typeof onMetaData.hasAudio === 'boolean') { // hasAudio\n                this._hasAudio = onMetaData.hasAudio;\n                this._mediaInfo.hasAudio = this._hasAudio;\n            }\n            if (typeof onMetaData.hasVideo === 'boolean') { // hasVideo\n                this._hasVideo = onMetaData.hasVideo;\n                this._mediaInfo.hasVideo = this._hasVideo;\n            }\n            if (typeof onMetaData.audiodatarate === 'number') { // audiodatarate\n                this._mediaInfo.audioDataRate = onMetaData.audiodatarate;\n            }\n            if (typeof onMetaData.videodatarate === 'number') { // videodatarate\n                this._mediaInfo.videoDataRate = onMetaData.videodatarate;\n            }\n            if (typeof onMetaData.width === 'number') { // width\n                this._mediaInfo.width = onMetaData.width;\n            }\n            if (typeof onMetaData.height === 'number') { // height\n                this._mediaInfo.height = onMetaData.height;\n            }\n            if (typeof onMetaData.duration === 'number') { // duration\n                if (!this._durationOverrided) {\n                    const duration = Math.floor(onMetaData.duration * this._timescale);\n                    this._duration = duration;\n                    this._mediaInfo.duration = duration;\n                }\n            } else {\n                this._mediaInfo.duration = 0;\n            }\n            if (typeof onMetaData.framerate === 'number') { // framerate\n                const fps_num = Math.floor(onMetaData.framerate * 1000);\n                if (fps_num > 0) {\n                    const fps = fps_num / 1000;\n                    this._referenceFrameRate.fixed = true;\n                    this._referenceFrameRate.fps = fps;\n                    this._referenceFrameRate.fps_num = fps_num;\n                    this._referenceFrameRate.fps_den = 1000;\n                    this._mediaInfo.fps = fps;\n                }\n            }\n            if (typeof onMetaData.keyframes === 'object') { // keyframes\n                this._mediaInfo.hasKeyframesIndex = true;\n                const keyframes = onMetaData.keyframes;\n                keyframes.times = onMetaData.times;\n                keyframes.filepositions = onMetaData.filepositions;\n                this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(keyframes);\n                onMetaData.keyframes = null; // keyframes has been extracted, remove it\n            } else {\n                this._mediaInfo.hasKeyframesIndex = false;\n            }\n            this._dispatch = false;\n            this._mediaInfo.metadata = onMetaData;\n            console.log(this.TAG, 'Parsed onMetaData');\n            // if (this._mediaInfo.isComplete()) {\n            // this._onMediaInfo(this._mediaInfo);\n            // }\n            return this._mediaInfo;\n        }\n    }\n\n    _parseKeyframesIndex(keyframes) {\n        const times = [];\n        const filepositions = [];\n\n        // ignore first keyframe which is actually AVC Sequence Header (AVCDecoderConfigurationRecord)\n        for (let i = 1; i < keyframes.times.length; i++) {\n            const time = this._timestampBase + Math.floor(keyframes.times[i] * 1000);\n            times.push(time);\n            filepositions.push(keyframes.filepositions[i]);\n        }\n\n        return {\n            times,\n            filepositions\n        };\n    }\n\n    /**\n     * 传入tags输出moof和mdat\n     *\n     * @param {any} tags\n     *\n     * @memberof tagDemux\n     */\n    moofTag(tags) {\n\n        for (let i = 0; i < tags.length; i++) {\n            this._dispatch = true;\n            this.parseChunks(tags[i]);\n            // console.log(\"tagTimestamp\", tags[i].getTime(), tags[i]);\n        }\n        if (this._isInitialMetadataDispatched()) {\n            if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n                this._onDataAvailable(this._audioTrack, this._videoTrack);\n            }\n        }\n    }\n\n    parseChunks(flvtag) {\n\n        switch (flvtag.tagType) {\n            case 8: // Audio\n                this._parseAudioData(flvtag.body.buffer, 0, flvtag.body.length, flvtag.getTime());\n                break;\n            case 9: // Video\n                this._parseVideoData(flvtag.body.buffer, 0, flvtag.body.length, flvtag.getTime(), 0);\n                break;\n            case 18: // ScriptDataObject\n                this.parseMetadata(flvtag.body);\n                break;\n        }\n    }\n\n    _parseVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition) {\n        if (tagTimestamp == this._timestampBase && this._timestampBase != 0) {\n            throw new Error(tagTimestamp, this._timestampBase, '夭寿啦这个视频不是从0开始');\n            // this.timestampBase(0);\n        }\n        if (dataSize <= 1) {\n            console.log(this.TAG, 'Flv: Invalid video packet, missing VideoData payload!');\n            return;\n        }\n        // 获取 video tag body 第一字节\n        const spec = (new Uint8Array(arrayBuffer, dataOffset, dataSize))[0];\n        // 获取是否是关键帧\n        const frameType = (spec & 240) >>> 4;\n        // 获取编码格式\n        const codecId = spec & 15;\n\n        if (codecId !== 7) {\n            if(this._onError)\n            this._onError(`Flv: Unsupported codec in video frame: ${codecId}`);\n            return;\n        }\n\n        this._parseAVCVideoPacket(arrayBuffer, dataOffset + 1, dataSize - 1, tagTimestamp, tagPosition, frameType);\n    }\n\n    _parseAVCVideoPacket(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType) {\n\n        if (dataSize < 4) {\n            console.log(this.TAG, 'Flv: Invalid AVC packet, missing AVCPacketType or/and CompositionTime');\n            return;\n        }\n\n        const le = this._littleEndian;\n        // 获取 video tag body 第2字节到结尾\n        const v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        // IF CodecID == 7  AVCPacketType\n        // 0 = AVC sequence header\n        // 1 = AVC NALU\n        // 2 = AVC end of sequence (lower level NALU sequence ender is not required or supported)\n        const packetType = v.getUint8(0);\n        // 3字节\n        // IF AVCPacketType == 1\n        //  Composition time offset\n        // ELSE\n        //  0\n        const cts = v.getUint32(0, !le) & 0x00FFFFFF;\n\n        // IF AVCPacketType == 0 AVCDecoderConfigurationRecord（AVC sequence header）\n        // IF AVCPacketType == 1 One or more NALUs (Full frames are required)\n\n        /**\n         *AVCDecoderConfigurationRecord.包含着是H.264解码相关比较重要的sps和pps信息，\n         *再给AVC解码器送数据 流之前一定要把sps和pps信息送出，否则的话解码器不能正常解码。\n         *而且在解码器stop之后再次start之前，如seek、快进快退状态切换等，\n         *都 需要重新送一遍sps和pps的信息.AVCDecoderConfigurationRecord在FLV文件中一般情况也是出现1次，\n         *也就是第一个 video tag.\n         */\n        if (packetType === 0) { // AVCDecoderConfigurationRecord\n            this._parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset + 4, dataSize - 4);\n        } else if (packetType === 1) { // One or more Nalus\n            this._parseAVCVideoData(arrayBuffer, dataOffset + 4, dataSize - 4, tagTimestamp, tagPosition, frameType, cts);\n        } else if (packetType === 2) {\n            // empty, AVC end of sequence\n        } else {\n            this._onError(`Flv: Invalid video packet type ${packetType}`);\n            return;\n        }\n    }\n\n    /**\n     * AVC 初始化\n     */\n    _parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize < 7) {\n            console.log(this.TAG, 'Flv: Invalid AVCDecoderConfigurationRecord, lack of data!');\n            return;\n        }\n\n        let meta = this._videoMetadata;\n        const track = this._videoTrack;\n        const le = this._littleEndian;\n        const v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        if (!meta) {\n            meta = this._videoMetadata = {};\n            meta.type = 'video';\n            meta.id = track.id;\n            meta.timescale = this._timescale;\n            meta.duration = this._duration;\n        } else {\n            if (typeof meta.avcc !== 'undefined') {\n                console.log(this.TAG, 'Found another AVCDecoderConfigurationRecord!');\n            }\n        }\n\n        const version = v.getUint8(0); // configurationVersion\n        const avcProfile = v.getUint8(1); // avcProfileIndication\n        const profileCompatibility = v.getUint8(2); // profile_compatibility\n        const avcLevel = v.getUint8(3); // AVCLevelIndication\n\n        if (version !== 1 || avcProfile === 0) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord');\n            return;\n        }\n\n        this._naluLengthSize = (v.getUint8(4) & 3) + 1; // lengthSizeMinusOne\n        if (this._naluLengthSize !== 3 && this._naluLengthSize !== 4) { // holy shit!!!\n            this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Strange NaluLengthSizeMinusOne: ${this._naluLengthSize - 1}`);\n            return;\n        }\n\n        const spsCount = v.getUint8(5) & 31; // numOfSequenceParameterSets\n        if (spsCount === 0 || spsCount > 1) {\n            this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Invalid H264 SPS count: ${spsCount}`);\n            return;\n        }\n\n        let offset = 6;\n\n        for (let i = 0; i < spsCount; i++) {\n            const len = v.getUint16(offset, !le); // sequenceParameterSetLength\n            offset += 2;\n\n            if (len === 0) {\n                continue;\n            }\n\n            // Notice: Nalu without startcode header (00 00 00 01)\n            const sps = new Uint8Array(arrayBuffer, dataOffset + offset, len);\n            offset += len;\n\n            const config = SPSParser.parseSPS(sps);\n            meta.codecWidth = config.codec_size.width;\n            meta.codecHeight = config.codec_size.height;\n            meta.presentWidth = config.present_size.width;\n            meta.presentHeight = config.present_size.height;\n            meta.config=config;\n            meta.profile = config.profile_string;\n            meta.level = config.level_string;\n            meta.bitDepth = config.bit_depth;\n            meta.chromaFormat = config.chroma_format;\n            meta.sarRatio = config.sar_ratio;\n            meta.frameRate = config.frame_rate;\n\n            if (config.frame_rate.fixed === false ||\n                config.frame_rate.fps_num === 0 ||\n                config.frame_rate.fps_den === 0) {\n                meta.frameRate = this._referenceFrameRate;\n            }\n\n            const fps_den = meta.frameRate.fps_den;\n            const fps_num = meta.frameRate.fps_num;\n            meta.refSampleDuration = Math.floor(meta.timescale * (fps_den / fps_num));\n\n            const codecArray = sps.subarray(1, 4);\n            let codecString = 'avc1.';\n            for (let j = 0; j < 3; j++) {\n                let h = codecArray[j].toString(16);\n                if (h.length < 2) {\n                    h = '0' + h;\n                }\n                codecString += h;\n            }\n            meta.codec = codecString;\n\n            const mi = this._mediaInfo;\n            mi.width = meta.codecWidth;\n            mi.height = meta.codecHeight;\n            mi.fps = meta.frameRate.fps;\n            mi.profile = meta.profile;\n            mi.level = meta.level;\n            mi.chromaFormat = config.chroma_format_string;\n            mi.sarNum = meta.sarRatio.width;\n            mi.sarDen = meta.sarRatio.height;\n            mi.videoCodec = codecString;\n            mi.meta=meta;\n            if (mi.hasAudio) {\n                if (mi.audioCodec != null) {\n                    mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n                }\n            } else {\n                mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + '\"';\n            }\n            if (mi.isComplete()) {\n                this._onMediaInfo(mi);\n            }\n        }\n\n        const ppsCount = v.getUint8(offset); // numOfPictureParameterSets\n        if (ppsCount === 0 || ppsCount > 1) {\n            this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Invalid H264 PPS count: ${ppsCount}`);\n            return;\n        }\n\n        offset++;\n\n        for (let i = 0; i < ppsCount; i++) {\n            const len = v.getUint16(offset, !le); // pictureParameterSetLength\n            offset += 2;\n\n            if (len === 0) {\n                continue;\n            }\n\n            // pps is useless for extracting video information\n            offset += len;\n        }\n\n        meta.avcc = new Uint8Array(dataSize);\n        meta.avcc.set(new Uint8Array(arrayBuffer, dataOffset, dataSize), 0);\n        console.log(this.TAG, 'Parsed AVCDecoderConfigurationRecord');\n\n        if (this._isInitialMetadataDispatched()) {\n            // flush parsed frames\n            if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n                this._onDataAvailable(this._audioTrack, this._videoTrack);\n            }\n        } else {\n            this._videoInitialMetadataDispatched = true;\n        }\n        // notify new metadata\n        this._dispatch = false;\n        // if (this._onTrackMetadata) {\n        //     this._onTrackMetadata.call(null, meta);\n        // }\n\n        this._onTrackMetadata('video', meta);\n    }\n    \n    timestampBase(i) {\n        this._timestampBase = i;\n    }\n\n    /**\n     * 普通的AVC 片段\n     */\n    _parseAVCVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType, cts) {\n\n        const le = this._littleEndian;\n        const v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        let units = [],\n            length = 0;\n\n        let offset = 0;\n        const lengthSize = this._naluLengthSize;\n        const dts = this._timestampBase + tagTimestamp;\n        let keyframe = (frameType === 1); // from FLV Frame Type constants\n\n        while (offset < dataSize) {\n            if (offset + 4 >= dataSize) {\n                console.log(this.TAG, `Malformed Nalu near timestamp ${dts}, offset = ${offset}, dataSize = ${dataSize}`);\n                break; // data not enough for next Nalu\n            }\n            // Nalu with length-header (AVC1)\n            let naluSize = v.getUint32(offset, !le); // Big-Endian read\n            if (lengthSize === 3) {\n                naluSize >>>= 8;\n            }\n            if (naluSize > dataSize - lengthSize) {\n                console.log(this.TAG, `Malformed Nalus near timestamp ${dts}, NaluSize > DataSize!`);\n                return;\n            }\n\n            const unitType = v.getUint8(offset + lengthSize) & 0x1F;\n\n            if (unitType === 5) { // IDR\n                keyframe = true;\n            }\n\n            const data = new Uint8Array(arrayBuffer, dataOffset + offset, lengthSize + naluSize);\n            const unit = { type: unitType, data };\n            units.push(unit);\n            length += data.byteLength;\n\n            offset += lengthSize + naluSize;\n        }\n\n        if (units.length) {\n            const track = this._videoTrack;\n            const avcSample = {\n                units,\n                length,\n                isKeyframe: keyframe,\n                dts,\n                cts,\n                pts: (dts + cts)\n            };\n            if (keyframe) {\n                avcSample.fileposition = tagPosition;\n            }\n            track.samples.push(avcSample);\n            track.length += length;\n        }\n    }\n    _parseAudioData(arrayBuffer, dataOffset, dataSize, tagTimestamp) {\n        if (tagTimestamp == this._timestampBase && this._timestampBase != 0) {\n            console.log(tagTimestamp, this._timestampBase, '夭寿啦这个视频不是从0开始');\n            // timestampBase(0);\n        }\n\n        if (dataSize <= 1) {\n            console.log(this.TAG, 'Flv: Invalid audio packet, missing SoundData payload!');\n            return;\n        }\n\n        let meta = this._audioMetadata;\n        const track = this._audioTrack;\n\n        if (!meta || !meta.codec) {\n            // initial metadata\n            meta = this._audioMetadata = {};\n            meta.type = 'audio';\n            meta.id = track.id;\n            meta.timescale = this._timescale;\n            meta.duration = this._duration;\n\n            const le = this._littleEndian;\n            const v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n            const soundSpec = v.getUint8(0);\n\n            const soundFormat = soundSpec >>> 4;\n            if (soundFormat !== 10) { // AAC\n                // TODO: support MP3 audio codec\n                this._onError(DemuxErrors.CODEC_UNSUPPORTED, 'Flv: Unsupported audio codec idx: ' + soundFormat);\n                return;\n            }\n\n            let soundRate = 0;\n            const soundRateIndex = (soundSpec & 12) >>> 2;\n\n            const soundRateTable = [5500, 11025, 22050, 44100, 48000];\n\n            if (soundRateIndex < soundRateTable.length) {\n                soundRate = soundRateTable[soundRateIndex];\n            } else {\n                this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid audio sample rate idx: ' + soundRateIndex);\n                return;\n            }\n\n            const soundSize = (soundSpec & 2) >>> 1; // unused\n            const soundType = (soundSpec & 1);\n\n            meta.audioSampleRate = soundRate;\n            meta.channelCount = (soundType === 0 ? 1 : 2);\n            meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);\n            meta.codec = 'mp4a.40.5';\n        }\n\n        const aacData = this._parseAACAudioData(arrayBuffer, dataOffset + 1, dataSize - 1);\n        if (aacData == undefined) {\n            return;\n        }\n\n        if (aacData.packetType === 0) { // AAC sequence header (AudioSpecificConfig)\n            if (meta.config) {\n                console.log(this.TAG, 'Found another AudioSpecificConfig!');\n            }\n            const misc = aacData.data;\n            meta.audioSampleRate = misc.samplingRate;\n            meta.channelCount = misc.channelCount;\n            meta.codec = misc.codec;\n            meta.config = misc.config;\n            // The decode result of an aac sample is 1024 PCM samples\n            meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);\n            console.log(this.TAG, 'Parsed AudioSpecificConfig');\n\n            if (this._isInitialMetadataDispatched()) {\n                // Non-initial metadata, force dispatch (or flush) parsed frames to remuxer\n                if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n                    this._onDataAvailable(this._audioTrack, this._videoTrack);\n                }\n            } else {\n                this._audioInitialMetadataDispatched = true;\n            }\n            // then notify new metadata\n            this._dispatch = false;\n            this._onTrackMetadata('audio', meta);\n\n            const mi = this._mediaInfo;\n            mi.audioCodec = 'mp4a.40.' + misc.originalAudioObjectType;\n            mi.audioSampleRate = meta.audioSampleRate;\n            mi.audioChannelCount = meta.channelCount;\n            if (mi.hasVideo) {\n                if (mi.videoCodec != null) {\n                    mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n                }\n            } else {\n                mi.mimeType = 'video/x-flv; codecs=\"' + mi.audioCodec + '\"';\n            }\n            if (mi.isComplete()) {\n                this._onMediaInfo(mi);\n            }\n            return;\n        } else if (aacData.packetType === 1) { // AAC raw frame data\n            const dts = this._timestampBase + tagTimestamp;\n            const aacSample = { unit: aacData.data, dts, pts: dts };\n            track.samples.push(aacSample);\n            track.length += aacData.data.length;\n        } else {\n            console.log(this.TAG, `Flv: Unsupported AAC data type ${aacData.packetType}`);\n        }\n    }\n\n    _parseAACAudioData(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize <= 1) {\n            console.log(this.TAG, 'Flv: Invalid AAC packet, missing AACPacketType or/and Data!');\n            return;\n        }\n\n        const result = {};\n        const array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n\n        result.packetType = array[0];\n\n        if (array[0] === 0) {\n            result.data = this._parseAACAudioSpecificConfig(arrayBuffer, dataOffset + 1, dataSize - 1);\n        } else {\n            result.data = array.subarray(1);\n        }\n\n        return result;\n    }\n\n    _parseAACAudioSpecificConfig(arrayBuffer, dataOffset, dataSize) {\n        const array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n        let config = null;\n\n        const mpegSamplingRates = [\n            96000, 88200, 64000, 48000, 44100, 32000,\n            24000, 22050, 16000, 12000, 11025, 8000, 7350\n        ];\n\n        /* Audio Object Type:\n           0: Null\n           1: AAC Main\n           2: AAC LC\n           3: AAC SSR (Scalable Sample Rate)\n           4: AAC LTP (Long Term Prediction)\n           5: HE-AAC / SBR (Spectral Band Replication)\n           6: AAC Scalable\n        */\n\n        let audioObjectType = 0;\n        let originalAudioObjectType = 0;\n        let audioExtensionObjectType = null;\n        let samplingIndex = 0;\n        let extensionSamplingIndex = null;\n        // debugger;\n        // 5 bits\n        audioObjectType = originalAudioObjectType = array[0] >>> 3;\n        // 4 bits\n        samplingIndex = ((array[0] & 0x07) << 1) | (array[1] >>> 7);\n        if (samplingIndex < 0 || samplingIndex >= mpegSamplingRates.length) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid sampling frequency index!');\n            return;\n        }\n\n        const samplingFrequence = mpegSamplingRates[samplingIndex];\n\n        // 4 bits\n        const channelConfig = (array[1] & 0x78) >>> 3;\n        if (channelConfig < 0 || channelConfig >= 8) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid channel configuration');\n            return;\n        }\n\n        if (audioObjectType === 5) { // HE-AAC?\n            // 4 bits\n            extensionSamplingIndex = ((array[1] & 0x07) << 1) | (array[2] >>> 7);\n            // 5 bits\n            audioExtensionObjectType = (array[2] & 0x7C) >>> 2;\n        }\n\n        // workarounds for various browsers\n        const userAgent = self.navigator.userAgent.toLowerCase();\n\n        if (userAgent.indexOf('firefox') !== -1) {\n            // firefox: use SBR (HE-AAC) if freq less than 24kHz\n            if (samplingIndex >= 6) {\n                audioObjectType = 5;\n                config = new Array(4);\n                extensionSamplingIndex = samplingIndex - 3;\n            } else { // use LC-AAC\n                audioObjectType = 2;\n                config = new Array(2);\n                extensionSamplingIndex = samplingIndex;\n            }\n        } else if (userAgent.indexOf('android') !== -1) {\n            // android: always use LC-AAC\n            audioObjectType = 2;\n            config = new Array(2);\n            extensionSamplingIndex = samplingIndex;\n        } else {\n            // for other browsers, e.g. chrome...\n            // Always use HE-AAC to make it easier to switch aac codec profile\n            audioObjectType = 5;\n            extensionSamplingIndex = samplingIndex;\n            config = new Array(4);\n\n            if (samplingIndex >= 6) {\n                extensionSamplingIndex = samplingIndex - 3;\n            } else if (channelConfig === 1) { // Mono channel\n                audioObjectType = 2;\n                config = new Array(2);\n                extensionSamplingIndex = samplingIndex;\n            }\n        }\n\n        config[0] = audioObjectType << 3;\n        config[0] |= (samplingIndex & 0x0F) >>> 1;\n        config[1] = (samplingIndex & 0x0F) << 7;\n        config[1] |= (channelConfig & 0x0F) << 3;\n        if (audioObjectType === 5) {\n            config[1] |= ((extensionSamplingIndex & 0x0F) >>> 1);\n            config[2] = (extensionSamplingIndex & 0x01) << 7;\n            // extended audio object type: force to 2 (LC-AAC)\n            config[2] |= (2 << 2);\n            config[3] = 0;\n        }\n\n        return {\n            config,\n            samplingRate: samplingFrequence,\n            channelCount: channelConfig,\n            codec: 'mp4a.40.' + audioObjectType,\n            originalAudioObjectType\n        };\n    }\n    _isInitialMetadataDispatched() {\n        if (this._hasAudio && this._hasVideo) { // both audio & video\n            return this._audioInitialMetadataDispatched && this._videoInitialMetadataDispatched;\n        }\n        if (this._hasAudio && !this._hasVideo) { // audio only\n            return this._audioInitialMetadataDispatched;\n        }\n        if (!this._hasAudio && this._hasVideo) { // video only\n            return this._videoInitialMetadataDispatched;\n        }\n    }\n}\nvar tagdemux = new tagDemux();\n\n/* eslint-disable */\nclass FlvParse {\n    constructor() {\n        this.tempUint8 = new Uint8Array();\n        this.arrTag = [];\n        this.index = 0;\n        this.tempArr = [];\n        this.stop = false;\n        this.offset = 0;\n        this.frist = true;\n        this._hasAudio = false;\n        this._hasVideo = false;\n    }\n\n    /**\n     * 接受 外部的flv二进制数据\n     */\n    setFlv(uint8) {\n        this.stop = false;\n        this.arrTag = [];\n        this.index = 0;\n        this.tempUint8 = uint8;\n        if (this.tempUint8.length > 13 && this.tempUint8[0] == 70 && this.tempUint8[1] == 76 && this.tempUint8[2] == 86) {\n            this.probe(this.tempUint8.buffer);\n            this.read(9); // 略掉9个字节的flv header tag\n            this.read(4); // 略掉第一个4字节的 tag size\n            this.parse();\n            this.frist = false;\n            return this.offset;\n        } else if (!this.frist) {\n            return this.parse();\n        } else {\n            return this.offset;\n        }\n    }\n    probe(buffer) {\n        const data = new Uint8Array(buffer);\n        const mismatch = { match: false };\n\n        if (data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01) {\n            return mismatch;\n        }\n\n        const hasAudio = ((data[4] & 4) >>> 2) !== 0;\n        const hasVideo = (data[4] & 1) !== 0;\n\n        if (!hasAudio && !hasVideo) {\n            return mismatch;\n        }\n        this._hasAudio = tagdemux._hasAudio = hasAudio;\n        this._hasVideo = tagdemux._hasVideo = hasVideo;\n        return {\n            match: true,\n            hasAudioTrack: hasAudio,\n            hasVideoTrack: hasVideo\n        };\n    }\n\n    /**\n     * 开始解析\n     */\n    parse() {\n\n        while (this.index < this.tempUint8.length && !this.stop) {\n            this.offset = this.index;\n\n            const t = new FlvTag();\n            if (this.tempUint8.length - this.index >= 11) {\n                t.tagType = (this.read(1)[0]); // 取出tag类型\n                t.dataSize = this.read(3); // 取出包体大小\n                t.Timestamp = this.read(4); // 取出解码时间\n                t.StreamID = this.read(3); // 取出stream id\n            } else {\n                this.stop = true;\n                continue;\n            }\n            if (t.tagType == 18 || t.tagType == 8 || t.tagType == 9) {\n                \n            } else {\n                throw new Error('wrong tagType' + t.tagType);\n            }\n            if (this.tempUint8.length - this.index >= (this.getBodySum(t.dataSize) + 4)) {\n                t.body = this.read(this.getBodySum(t.dataSize)); // 取出body\n                if (t.tagType == 9 && this._hasVideo) {\n                    this.arrTag.push(t);\n                }\n                if (t.tagType == 8 && this._hasAudio) {\n                    this.arrTag.push(t);\n                }\n                if (t.tagType == 18 ) {\n                    if(this.arrTag.length==0)\n                    this.arrTag.push(t);\n                    else{\n                        // console.log('这是截获的自定义数据',t);\n                    }\n                }\n                t.size=this.read(4);\n            } else {\n                this.stop = true;\n                continue;\n            }\n            this.offset = this.index;\n        }\n\n        return this.offset;\n    }\n    read(length) {\n        // let u8a = new Uint8Array(length);\n        // u8a.set(this.tempUint8.subarray(this.index, this.index + length), 0);\n        const u8a = this.tempUint8.slice(this.index, this.index + length);\n        this.index += length;\n        return u8a;\n    }\n\n    /**\n     * 计算tag包体大小\n     */\n    getBodySum(arr) {\n        let _str = '';\n        _str += (arr[0].toString(16).length == 1 ? '0' + arr[0].toString(16) : arr[0].toString(16));\n        _str += (arr[1].toString(16).length == 1 ? '0' + arr[1].toString(16) : arr[1].toString(16));\n        _str += (arr[2].toString(16).length == 1 ? '0' + arr[2].toString(16) : arr[2].toString(16));\n        return parseInt(_str, 16);\n    }\n}\nvar flvparse = new FlvParse();\n\n/**\n * 代码借鉴了flv.js\n * 增加了自己的注释和写法\n */\n/* eslint-disable */\nclass MP4 {\n\n    static init() {\n        MP4.types = {\n            avc1: [],\n            avcC: [],\n            btrt: [],\n            dinf: [],\n            dref: [],\n            esds: [],\n            ftyp: [],\n            hdlr: [],\n            mdat: [],\n            mdhd: [],\n            mdia: [],\n            mfhd: [],\n            minf: [],\n            moof: [],\n            moov: [],\n            mp4a: [],\n            mvex: [],\n            mvhd: [],\n            sdtp: [],\n            stbl: [],\n            stco: [],\n            stsc: [],\n            stsd: [],\n            stsz: [],\n            stts: [],\n            tfdt: [],\n            tfhd: [],\n            traf: [],\n            trak: [],\n            trun: [],\n            trex: [],\n            tkhd: [],\n            vmhd: [],\n            smhd: []\n        };\n\n        for (const name in MP4.types) {\n            if (MP4.types.hasOwnProperty(name)) {\n                MP4.types[name] = [\n                    name.charCodeAt(0),\n                    name.charCodeAt(1),\n                    name.charCodeAt(2),\n                    name.charCodeAt(3)\n                ];\n            }\n        }\n\n        const constants = MP4.constants = {};\n\n        constants.FTYP = new Uint8Array([\n            0x69, 0x73, 0x6F, 0x6D, // major_brand: isom\t\tisom\tMP4  Base Media v1 [IS0 14496-12:2003]\tISO\tYES\tvideo/mp4\n            0x0, 0x0, 0x0, 0x1, // minor_version: 0x01\n            0x69, 0x73, 0x6F, 0x6D, // isom\n            0x61, 0x76, 0x63, 0x31 // avc1\n        ]);\n\n        constants.STSD_PREFIX = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags  version字段后会有一个entry count字段\n            0x00, 0x00, 0x00, 0x01 // entry_count\t根据entry的个数，每个entry会有type信息，如“vide”、“sund”等，根据type不同sample description会提供不同的信息，例如对于video track，会有“VisualSampleEntry”类型信息，对于audio track会有“AudioSampleEntry”类型信息。\n        ]);\n\n        constants.STTS = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags\n            0x00, 0x00, 0x00, 0x00 // entry_count     0个索引\n        ]);\n\n        constants.STSC = constants.STCO = constants.STTS;\n\n        constants.STSZ = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags\n            0x00, 0x00, 0x00, 0x00, // sample_size\n            0x00, 0x00, 0x00, 0x00 // sample_count\n        ]);\n\n        constants.HDLR_VIDEO = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags\n            0x00, 0x00, 0x00, 0x00, // pre_defined\n            0x76, 0x69, 0x64, 0x65, // handler_type: 'vide' 在media box中，该值为4个字符\t\t“vide”— video track\n            0x00, 0x00, 0x00, 0x00, // reserved: 3 * 4 bytes\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, // 保留位\n            0x56, 0x69, 0x64, 0x65,\n            0x6F, 0x48, 0x61, 0x6E,\n            0x64, 0x6C, 0x65, 0x72, 0x00 // name: VideoHandler 长度不定\t\ttrack type name，以‘\\0’结尾的字符串\n        ]);\n\n        constants.HDLR_AUDIO = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags\n            0x00, 0x00, 0x00, 0x00, // pre_defined\n            0x73, 0x6F, 0x75, 0x6E, // handler_type: 'soun'在media box中，该值为4个字符\t\t“soun”— audio track\n            0x00, 0x00, 0x00, 0x00, // reserved: 3 * 4 bytes\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, // 保留位\n            0x53, 0x6F, 0x75, 0x6E,\n            0x64, 0x48, 0x61, 0x6E,\n            0x64, 0x6C, 0x65, 0x72, 0x00 // name: SoundHandler 长度不定\t\ttrack type name，以‘\\0’结尾的字符串\n        ]);\n\n        constants.DREF = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags\n            0x00, 0x00, 0x00, 0x01, // entry_count 1个url\n            // url\tbox开始\n            0x00, 0x00, 0x00, 0x0C, // entry_size\n            0x75, 0x72, 0x6C, 0x20, // type 'url '\n            0x00, 0x00, 0x00, 0x01 // version(0) + flags 当“url”或“urn”的box flag为1时，字符串均为空。\n        ]);\n\n        // Sound media header\n        constants.SMHD = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags\tbox版本，0或1，一般为0。\n            0x00, 0x00, 0x00, 0x00 // balance(2) + reserved(2) 立体声平衡，[8.8] 格式值，一般为0，-1.0表示全部左声道，1.0表示全部右声道+2位保留位\n        ]);\n\n        // video media header\n        constants.VMHD = new Uint8Array([\n            0x00, 0x00, 0x00, 0x01, // version(0) + flags\n            0x00, 0x00, // graphicsmode: 2 bytes 视频合成模式，为0时拷贝原始图像，否则与opcolor进行合成   //理论上是4位啊  暂时保留\n            0x00, 0x00, 0x00, 0x00, // opcolor: 3 * 2 bytes ｛red，green，blue｝\n            0x00, 0x00\n        ]);\n    }\n\n    /**\n     * 封装box\n     */\n    static box(type) {\n        let size = 8;\n        let result = null;\n        const datas = Array.prototype.slice.call(arguments, 1);\n        const arrayCount = datas.length;\n\n        for (let i = 0; i < arrayCount; i++) {\n            size += datas[i].byteLength;\n        }\n        // box头部大小\n        result = new Uint8Array(size);\n        result[0] = (size >>> 24) & 0xFF; // size\n        result[1] = (size >>> 16) & 0xFF;\n        result[2] = (size >>> 8) & 0xFF;\n        result[3] = (size) & 0xFF;\n        // 写入box的type\n        result.set(type, 4); // type\n\n        let offset = 8;\n        for (let i = 0; i < arrayCount; i++) { // data body\n            result.set(datas[i], offset);\n            offset += datas[i].byteLength;\n        }\n\n        return result;\n    }\n\n    // 创建ftyp&moov\n    static generateInitSegment(meta) {\n        if (meta.constructor != Array) {\n            meta = [meta];\n        }\n        const ftyp = MP4.box(MP4.types.ftyp, MP4.constants.FTYP);\n        const moov = MP4.moov(meta);\n\n        const result = new Uint8Array(ftyp.byteLength + moov.byteLength);\n        result.set(ftyp, 0);\n        result.set(moov, ftyp.byteLength);\n        return result;\n    }\n\n    // Movie metadata box\n    static moov(meta) {\n        const mvhd = MP4.mvhd(meta[0].timescale, meta[0].duration); // /moov里面的第一个box\n        const vtrak = MP4.trak(meta[0]);\n        let atrak;\n        if (meta.length > 1) {\n            atrak = MP4.trak(meta[1]);\n        }\n\n        const mvex = MP4.mvex(meta);\n        if (meta.length > 1) { return MP4.box(MP4.types.moov, mvhd, vtrak, atrak, mvex); } else { return MP4.box(MP4.types.moov, mvhd, vtrak, mvex); }\n    }\n\n    // Movie header box\n    static mvhd(timescale, duration) {\n        return MP4.box(MP4.types.mvhd, new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags     1位的box版本+3位flags   box版本，0或1，一般为0。（以下字节数均按version=0）\n            0x00, 0x00, 0x00, 0x00, // creation_time    创建时间  （相对于UTC时间1904-01-01零点的秒数）\n            0x00, 0x00, 0x00, 0x00, // modification_time   修改时间\n            (timescale >>> 24) & 0xFF, // timescale: 4 bytes\t\t文件媒体在1秒时间内的刻度值，可以理解为1秒长度\n            (timescale >>> 16) & 0xFF,\n            (timescale >>> 8) & 0xFF,\n            (timescale) & 0xFF,\n            (duration >>> 24) & 0xFF, // duration: 4 bytes\t该track的时间长度，用duration和time scale值可以计算track时长，比如audio track的time scale = 8000, duration = 560128，时长为70.016，video track的time scale = 600, duration = 42000，时长为70\n            (duration >>> 16) & 0xFF,\n            (duration >>> 8) & 0xFF,\n            (duration) & 0xFF,\n            0x00, 0x01, 0x00, 0x00, // Preferred rate: 1.0   推荐播放速率，高16位和低16位分别为小数点整数部分和小数部分，即[16.16] 格式，该值为1.0（0x00010000）表示正常前向播放\n            0x01, 0x00, 0x00, 0x00, // PreferredVolume(1.0, 2bytes) + reserved(2bytes)\t与rate类似，[8.8] 格式，1.0（0x0100）表示最大音量\n            0x00, 0x00, 0x00, 0x00, // reserved: 4 + 4 bytes\t保留位\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x01, 0x00, 0x00, // ----begin composition matrix----\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, // 视频变换矩阵   线性代数\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x01, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x40, 0x00, 0x00, 0x00, // ----end composition matrix----\n            0x00, 0x00, 0x00, 0x00, // ----begin pre_defined 6 * 4 bytes----\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, // pre-defined 保留位\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, // ----end pre_defined 6 * 4 bytes----\n            0xFF, 0xFF, 0xFF, 0xFF // next_track_ID 下一个track使用的id号\n        ]));\n    }\n\n    // Track box\n    static trak(meta) {\n        return MP4.box(MP4.types.trak, MP4.tkhd(meta), MP4.mdia(meta));\n    }\n\n    // Track header box\n    static tkhd(meta) {\n        let trackId = meta.id,\n            duration = meta.duration;\n        let width = meta.presentWidth,\n            height = meta.presentHeight;\n\n        return MP4.box(MP4.types.tkhd, new Uint8Array([\n            0x00, 0x00, 0x00, 0x07, // version(0) + flags 1位版本 box版本，0或1，一般为0。（以下字节数均按version=0）按位或操作结果值，预定义如下：\n            // 0x000001 track_enabled，否则该track不被播放；\n            // 0x000002 track_in_movie，表示该track在播放中被引用；\n            // 0x000004 track_in_preview，表示该track在预览时被引用。\n            // 一般该值为7，1+2+4 如果一个媒体所有track均未设置track_in_movie和track_in_preview，将被理解为所有track均设置了这两项；对于hint track，该值为0\n            // hint track  这个特殊的track并不包含媒体数据，而是包含了一些将其他数据track打包成流媒体的指示信息。\n            0x00, 0x00, 0x00, 0x00, // creation_time\t创建时间（相对于UTC时间1904-01-01零点的秒数）\n            0x00, 0x00, 0x00, 0x00, // modification_time\t修改时间\n            (trackId >>> 24) & 0xFF, // track_ID: 4 bytes\tid号，不能重复且不能为0\n            (trackId >>> 16) & 0xFF,\n            (trackId >>> 8) & 0xFF,\n            (trackId) & 0xFF,\n            0x00, 0x00, 0x00, 0x00, // reserved: 4 bytes    保留位\n            (duration >>> 24) & 0xFF, // duration: 4 bytes  \ttrack的时间长度\n            (duration >>> 16) & 0xFF,\n            (duration >>> 8) & 0xFF,\n            (duration) & 0xFF,\n            0x00, 0x00, 0x00, 0x00, // reserved: 2 * 4 bytes    保留位\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, // layer(2bytes) + alternate_group(2bytes)  视频层，默认为0，值小的在上层.track分组信息，默认为0表示该track未与其他track有群组关系\n            0x00, 0x00, 0x00, 0x00, // volume(2bytes) + reserved(2bytes)    [8.8] 格式，如果为音频track，1.0（0x0100）表示最大音量；否则为0   +保留位\n            0x00, 0x01, 0x00, 0x00, // ----begin composition matrix----\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x01, 0x00, 0x00, // 视频变换矩阵\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x40, 0x00, 0x00, 0x00, // ----end composition matrix----\n            (width >>> 8) & 0xFF, // //宽度\n            (width) & 0xFF,\n            0x00, 0x00,\n            (height >>> 8) & 0xFF, // 高度\n            (height) & 0xFF,\n            0x00, 0x00\n        ]));\n    }\n\n    /**\n     * “mdia”也是个container box，其子box的结构和种类还是比较复杂的。先来看一个“mdia”的实例结构树图。\n     * 总体来说，“mdia”定义了track媒体类型以及sample数据，描述sample信息。一般“mdia”包含一个“mdhd”，\n     * 一个“hdlr”和一个“minf”，其中“mdhd”为media header box，“hdlr”为handler reference box，\n     * “minf”为media information box。\n     *\n     * mdia\n     * \t\tmdhd\n     * \t\thdlr\n     * \t\tminf\n     * \t\t\tsmhd\n     * \t\t\tdinf\n     * \t\t\t\tdref\n     * \t\t\t\t\turl\n     * \t\t\tstbl\n     * \t\t\t\tstsd\n     * \t\t\t\t\tmp4a\n     * \t\t\t\t\t\tesds\n     * \t\t\t\tstts\n     * \t\t\t\tstsc\n     * \t\t\t\tstsz\n     * \t\t\t\tstco\n     */\n    static mdia(meta) {\n        return MP4.box(MP4.types.mdia, MP4.mdhd(meta), MP4.hdlr(meta), MP4.minf(meta));\n    }\n\n    // Media header box\n    static mdhd(meta) {\n        const timescale = meta.timescale;\n        const duration = meta.duration;\n        return MP4.box(MP4.types.mdhd, new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags // version(0) + flags\t\tbox版本，0或1，一般为0。\n            0x00, 0x00, 0x00, 0x00, // creation_time    创建时间\n            0x00, 0x00, 0x00, 0x00, // modification_time修改时间\n            (timescale >>> 24) & 0xFF, // timescale: 4 bytes    文件媒体在1秒时间内的刻度值，可以理解为1秒长度\n            (timescale >>> 16) & 0xFF,\n            (timescale >>> 8) & 0xFF,\n            (timescale) & 0xFF,\n            (duration >>> 24) & 0xFF, // duration: 4 bytes  track的时间长度\n            (duration >>> 16) & 0xFF,\n            (duration >>> 8) & 0xFF,\n            (duration) & 0xFF,\n            0x55, 0xC4, // language: und (undetermined) 媒体语言码。最高位为0，后面15位为3个字符（见ISO 639-2/T标准中定义）\n            0x00, 0x00 // pre_defined = 0\n        ]));\n    }\n\n    // Media handler reference box\n    static hdlr(meta) {\n        let data = null;\n        if (meta.type === 'audio') {\n            data = MP4.constants.HDLR_AUDIO;\n        } else {\n            data = MP4.constants.HDLR_VIDEO;\n        }\n        return MP4.box(MP4.types.hdlr, data);\n    }\n\n    /**\n\t\t * “minf”存储了解释track媒体数据的handler-specific信息，media handler用这些信息将媒体时间映射到媒体数据并进行处理。“minf”中的信息格式和内容与媒体类型以及解释媒体数据的media handler密切相关，其他media handler不知道如何解释这些信息。“minf”是一个container box，其实际内容由子box说明。\n    一般情况下，“minf”包含一个header box，一个“dinf”和一个“stbl”，其中，header box根据track type（即media handler type）分为“vmhd”、“smhd”、“hmhd”和“nmhd”，“dinf”为data information box，“stbl”为sample table box。下面分别介绍。\n\n\t\t *\n\t\t */\n    // Media infomation box\n    static minf(meta) {\n        // header box根据track type（即media handler type）分为“vmhd”、“smhd”、“hmhd”和“nmhd”\n        let xmhd = null;\n        if (meta.type === 'audio') {\n            xmhd = MP4.box(MP4.types.smhd, MP4.constants.SMHD);\n        } else {\n            xmhd = MP4.box(MP4.types.vmhd, MP4.constants.VMHD);\n        }\n        return MP4.box(MP4.types.minf, xmhd, MP4.dinf(), MP4.stbl(meta));\n    }\n\n    /**\n     * Data Information Box\n     * “dinf”解释如何定位媒体信息，是一个container box。“dinf”一般包含一个“dref”，即data reference box；\n     * “dref”下会包含若干个“url”或“urn”，这些box组成一个表，用来定位track数据。\n     * 简单的说，track可以被分成若干段，每一段都可以根据“url”或“urn”指向的地址来获取数据，\n     * sample描述中会用这些片段的序号将这些片段组成一个完整的track。\n     * 一般情况下，当数据被完全包含在文件中时，“url”或“urn”中的定位字符串是空的。\n     */\n    static dinf() {\n        const result = MP4.box(MP4.types.dinf,\n            MP4.box(MP4.types.dref, MP4.constants.DREF)\n        );\n        return result;\n    }\n\n    /**\n\t\t * Sample Table Box（stbl）\n    \t*\t“stbl”几乎是普通的MP4文件中最复杂的一个box了，首先需要回忆一下sample的概念。\n \t\t* \tsample是媒体数据存储的单位，存储在media的chunk中，chunk和sample的长度均可互不相同，如下图所示。\n\t\t\t“stbl”是一个container box，其子box包括：sample description box（stsd）、\n\t\t\t * time to sample box（stts）、sample size box（stsz或stz2）、\n\t\t\t * sample to chunk box（stsc）、chunk offset box（stco或co64）、\n\t\t\t * composition time to sample box（ctts）、sync sample box（stss）\n\t\t\t * stsd”必不可少，且至少包含一个条目，该box包含了data reference box进行sample数据检索的信息。\n\t\t\t * 没有“stsd”就无法计算media sample的存储位置。“stsd”包含了编码的信息，其存储的信息随媒体类型不同而不同。\n\t\t\t * \t\t\tstbl\n\t\t\t * \t\t\t\tstsd\n\t\t\t * \t\t\t\t\tavc1\n\t\t\t * \t\t\t\t\t\tavcC\n\t\t\t * \t\t\t\tstts\n\t\t\t * \t\t\t\tstsc\n\t\t\t * \t\t\t\tstsz\n\t\t\t * \t\t\t\tstco\n\t\t */\n    static stbl(meta) {\n        const result = MP4.box(MP4.types.stbl, // type: stbl\n            MP4.stsd(meta), // Sample Description Table\n            MP4.box(MP4.types.stts, MP4.constants.STTS), // Time-To-Sample    因为stts的entry count 为0\n            // 所以没有关键帧index 的stss\n            // 也没有CTTS box CTTS是记录偏移量\n            MP4.box(MP4.types.stsc, MP4.constants.STSC), // Sample-To-Chunk\n            MP4.box(MP4.types.stsz, MP4.constants.STSZ), // Sample size\n            MP4.box(MP4.types.stco, MP4.constants.STCO) // Chunk offset\n        );\n        return result;\n    }\n\n    /**\n\t\t * Sample Description Box（stsd）\n    \t\tbox header和version字段后会有一个entry count字段，\n * \t\t\t根据entry的个数，每个entry会有type信息，如“vide”、“sund”等，\n * \t\t根据type不同sample description会提供不同的信息，例如对于video track，\n * 会有“VisualSampleEntry”类型信息，对于audio track会有“AudioSampleEntry”类型信息。\n\n\t\t * * \t\t\t\tstsd\n\t\t\t* \t\t\t\t\tmp4a\n\t\t\t* \t\t\t\t\t\tesds\n\t\t\t *\n\t\t\t *\n\t\t\t *\n\t\t\t *\n\t\t\t * \t\t 4 bytes - length in total\n\t\t\t\t\t 4 bytes - 4 char code of sample description table (stsd)\n\t\t\t\t\t 4 bytes - version & flags\n\t\t\t\t\t 4 bytes - number of sample entries (num_sample_entries)\n\t\t\t\t\t\t [\n\t\t\t\t\t\t    4 bytes - length of sample entry (len_sample_entry)\n\t\t\t\t\t\t    4 bytes - 4 char code of sample entry\n\t\t\t\t\t\t    ('len_sample_entry' - 8) bytes of data\n\t\t\t\t\t\t ] (repeated 'num_sample_entries' times)\n\t\t\t\t\t(4 bytes - optional 0x00000000 as end of box marker )\n\t\t */\n    static stsd(meta) {\n        if (meta.type === 'audio') {\n            return MP4.box(MP4.types.stsd, MP4.constants.STSD_PREFIX, MP4.mp4a(meta));\n        } else {\n            return MP4.box(MP4.types.stsd, MP4.constants.STSD_PREFIX, MP4.avc1(meta));\n        }\n    }\n\n    static mp4a(meta) {\n        const channelCount = meta.channelCount;\n        const sampleRate = meta.audioSampleRate;\n\n        const data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // reserved(4) 6个字节，设置为0；\n            0x00, 0x00, 0x00, 0x01, // reserved(2) + data_reference_index(2)\n            0x00, 0x00, 0x00, 0x00, // reserved: 2 * 4 bytes 保留位\n            0x00, 0x00, 0x00, 0x00,\n            0x00, channelCount, // channelCount(2) 单声道还是双声道\n            0x00, 0x10, // sampleSize(2)\n            0x00, 0x00, 0x00, 0x00, // reserved(4) 4字节保留位\n            (sampleRate >>> 8) & 0xFF, // Audio sample rate 显然要右移16位才有意义\ttemplate unsigned int(32) samplerate = {timescale of media}<<16;\n            (sampleRate) & 0xFF,\n            0x00, 0x00\n        ]);\n\n        return MP4.box(MP4.types.mp4a, data, MP4.esds(meta));\n    }\n\n    static esds(meta) {\n        const config = meta.config;\n        const configSize = config.length;\n        const data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version 0 + flags\n\n            0x03, // descriptor_type    MP4ESDescrTag\n            0x17 + configSize, // length3\n            0x00, 0x01, // es_id\n            0x00, // stream_priority\n\n            0x04, // descriptor_type    MP4DecConfigDescrTag\n            0x0F + configSize, // length\n            0x40, // codec: mpeg4_audio\n            /**\n             *当objectTypeIndication为0x40时，为MPEG-4 Audio（MPEG-4 Audio generally is thought of as AAC\n             * but there is a whole framework of audio codecs that can Go in MPEG-4 Audio including AAC, BSAC, ALS, CELP,\n             * and something called MP3On4），如果想更细分format为aac还是mp3，\n             * 可以读取MP4DecSpecificDescr层data[0]的前五位\n             */\n            0x15, // stream_type: Audio\n            0x00, 0x00, 0x00, // buffer_size\n            0x00, 0x00, 0x00, 0x00, // maxBitrate\n            0x00, 0x00, 0x00, 0x00, // avgBitrate\n\n            0x05 // descriptor_type MP4DecSpecificDescrTag\n        ].concat([\n            configSize\n        ]).concat(\n            config\n        ).concat([\n            0x06, 0x01, 0x02 // GASpecificConfig\n        ]));\n        return MP4.box(MP4.types.esds, data);\n    }\n\n    /**\n     * 改版\n     *stsd下的avc1视频解析\n     */\n    static avc1(meta) {\n        const avcc = meta.avcc;\n        let width = meta.codecWidth,\n            height = meta.codecHeight;\n\n        const data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // // reserved(4)    6个 保留位\tReserved：6个字节，设置为0；\n            0x00, 0x00, 0x00, 0x01, // reserved(2) + {{{{data_reference_index(2)  数据引用索引}}}}\n            0x00, 0x00, 0x00, 0x00, // pre_defined(2) + reserved(2)\n            0x00, 0x00, 0x00, 0x00, // pre_defined: 3 * 4 bytes  3*4个字节的保留位\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            (width >>> 8) & 0xFF, // width: 2 bytes\n            (width) & 0xFF,\n            (height >>> 8) & 0xFF, // height: 2 bytes\n            (height) & 0xFF,\n            0x00, 0x48, 0x00, 0x00, // horizresolution: 4 bytes 常数\n            0x00, 0x48, 0x00, 0x00, // vertresolution: 4 bytes 常数\n            0x00, 0x00, 0x00, 0x00, // reserved: 4 bytes 保留位\n            0x00, 0x01, // frame_count\n            // frame_count表明多少帧压缩视频存储在每个样本。默认是1,每样一帧;它可能超过1每个样本的多个帧数\n            0x04, //\tstrlen compressorname: 32 bytes\t\t\tString[32]\n            // 32个8 bit    第一个8bit表示长度,剩下31个8bit表示内容\n            0x67, 0x31, 0x31, 0x31, // compressorname: 32 bytes    翻译过来是g111\n            0x00, 0x00, 0x00, 0x00, //\n            0x00, 0x00, 0x00, 0x00, //\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00,\n            0x00, 0x18, // depth 颜色深度\n            0xFF, 0xFF // pre_defined = -1\n        ]);\n        return MP4.box(MP4.types.avc1, data, MP4.box(MP4.types.avcC, avcc));\n    }\n\n    // Movie Extends box\n    static mvex(meta) {\n        if (meta.length > 1) { return MP4.box(MP4.types.mvex, MP4.trex(meta[0]), MP4.trex(meta[1])); } else { return MP4.box(MP4.types.mvex, MP4.trex(meta[0])); }\n    }\n\n    // Track Extends box\n    static trex(meta) {\n        const trackId = meta.id;\n        const data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags\n            (trackId >>> 24) & 0xFF, // track_ID\n            (trackId >>> 16) & 0xFF,\n            (trackId >>> 8) & 0xFF,\n            (trackId) & 0xFF,\n            0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n            0x00, 0x00, 0x00, 0x00, // default_sample_duration\n            0x00, 0x00, 0x00, 0x00, // default_sample_size\n            0x00, 0x01, 0x00, 0x01 // default_sample_flags\n        ]);\n        // if (meta.type !== 'video') {\n        //     data[data.length - 1] = 0x00;\n        // }\n        return MP4.box(MP4.types.trex, data);\n    }\n\n    // Movie fragment box\n    static moof(track, baseMediaDecodeTime) {\n        return MP4.box(MP4.types.moof, MP4.mfhd(track.sequenceNumber), MP4.traf(track, baseMediaDecodeTime));\n    }\n\n    static mfhd(sequenceNumber) {\n        const data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,\n            (sequenceNumber >>> 24) & 0xFF, // sequence_number: int32\n            (sequenceNumber >>> 16) & 0xFF,\n            (sequenceNumber >>> 8) & 0xFF,\n            (sequenceNumber) & 0xFF\n        ]);\n        return MP4.box(MP4.types.mfhd, data);\n    }\n\n    // Track fragment box\n    static traf(track, baseMediaDecodeTime) {\n        const trackId = track.id;\n\n        // Track fragment header box\n        const tfhd = MP4.box(MP4.types.tfhd, new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) & flags\n            (trackId >>> 24) & 0xFF, // track_ID\n            (trackId >>> 16) & 0xFF,\n            (trackId >>> 8) & 0xFF,\n            (trackId) & 0xFF\n        ]));\n        // Track Fragment Decode Time\n        const tfdt = MP4.box(MP4.types.tfdt, new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) & flags\n            (baseMediaDecodeTime >>> 24) & 0xFF, // baseMediaDecodeTime: int32\n            (baseMediaDecodeTime >>> 16) & 0xFF,\n            (baseMediaDecodeTime >>> 8) & 0xFF,\n            (baseMediaDecodeTime) & 0xFF\n        ]));\n        const sdtp = MP4.sdtp(track);\n        const trun = MP4.trun(track, sdtp.byteLength + 16 + 16 + 8 + 16 + 8 + 8);\n\n        return MP4.box(MP4.types.traf, tfhd, tfdt, trun, sdtp);\n    }\n\n    // Sample Dependency Type box\n    static sdtp(track) {\n        const samples = track.samples || [];\n        const sampleCount = samples.length;\n        const data = new Uint8Array(4 + sampleCount);\n        // 0~4 bytes: version(0) & flags\n        for (let i = 0; i < sampleCount; i++) {\n            const flags = samples[i].flags;\n            data[i + 4] = (flags.isLeading << 6) // is_leading: 2 (bit)\n                |\n                (flags.dependsOn << 4) // sample_depends_on\n                |\n                (flags.isDependedOn << 2) // sample_is_depended_on\n                |\n                (flags.hasRedundancy); // sample_has_redundancy\n        }\n        return MP4.box(MP4.types.sdtp, data);\n    }\n\n    // Track fragment run box\n    static trun(track, offset) {\n        const samples = track.samples || [];\n        const sampleCount = samples.length;\n        const dataSize = 12 + 16 * sampleCount;\n        const data = new Uint8Array(dataSize);\n        offset += 8 + dataSize;\n\n        data.set([\n            0x00, 0x00, 0x0F, 0x01, // version(0) & flags\n            (sampleCount >>> 24) & 0xFF, // sample_count\n            (sampleCount >>> 16) & 0xFF,\n            (sampleCount >>> 8) & 0xFF,\n            (sampleCount) & 0xFF,\n            (offset >>> 24) & 0xFF, // data_offset\n            (offset >>> 16) & 0xFF,\n            (offset >>> 8) & 0xFF,\n            (offset) & 0xFF\n        ], 0);\n\n        for (let i = 0; i < sampleCount; i++) {\n\n            const duration = samples[i].duration;\n\n            const size = samples[i].size;\n            const flags = samples[i].flags;\n            const cts = samples[i].cts;\n            data.set([\n                (duration >>> 24) & 0xFF, // sample_duration\n                (duration >>> 16) & 0xFF,\n                (duration >>> 8) & 0xFF,\n                (duration) & 0xFF,\n                (size >>> 24) & 0xFF, // sample_size\n                (size >>> 16) & 0xFF,\n                (size >>> 8) & 0xFF,\n                (size) & 0xFF,\n                (flags.isLeading << 2) | flags.dependsOn, // sample_flags\n                (flags.isDependedOn << 6) | (flags.hasRedundancy << 4) | flags.isNonSync,\n                0x00, 0x00, // sample_degradation_priority\n                (cts >>> 24) & 0xFF, // sample_composition_time_offset\n                (cts >>> 16) & 0xFF,\n                (cts >>> 8) & 0xFF,\n                (cts) & 0xFF\n            ], 12 + 16 * i);\n        }\n        return MP4.box(MP4.types.trun, data);\n    }\n\n    static mdat(data) {\n        return MP4.box(MP4.types.mdat, data);\n    }\n\n}\n\nMP4.init();\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * This file is modified from dailymotion's hls.js library (hls.js/src/helper/aac.js)\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable */\nclass AAC {\n\n    static getSilentFrame(channelCount) {\n        if (channelCount === 1) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n        } else if (channelCount === 2) {\n            return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n        } else if (channelCount === 3) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n        } else if (channelCount === 4) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n        } else if (channelCount === 5) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n        } else if (channelCount === 6) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n        }\n        return null;\n    }\n\n}\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable */\nconst Browser = {};\n\nfunction detect() {\n    // modified from jquery-browser-plugin\n\n    const ua = self.navigator.userAgent.toLowerCase();\n\n    const match = /(edge)\\/([\\w.]+)/.exec(ua) ||\n        /(opr)[\\/]([\\w.]+)/.exec(ua) ||\n        /(chrome)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(iemobile)[\\/]([\\w.]+)/.exec(ua) ||\n        /(version)(applewebkit)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(webkit)[ \\/]([\\w.]+).*(version)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(webkit)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(opera)(?:.*version|)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(msie) ([\\w.]+)/.exec(ua) ||\n        ua.indexOf('trident') >= 0 && /(rv)(?::| )([\\w.]+)/.exec(ua) ||\n        ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\\w.]+)|)/.exec(ua) || [];\n\n    const platform_match = /(ipad)/.exec(ua) ||\n        /(ipod)/.exec(ua) ||\n        /(windows phone)/.exec(ua) ||\n        /(iphone)/.exec(ua) ||\n        /(kindle)/.exec(ua) ||\n        /(android)/.exec(ua) ||\n        /(windows)/.exec(ua) ||\n        /(mac)/.exec(ua) ||\n        /(linux)/.exec(ua) ||\n        /(cros)/.exec(ua) || [];\n\n    const matched = {\n        browser: match[5] || match[3] || match[1] || '',\n        version: match[2] || match[4] || '0',\n        majorVersion: match[4] || match[2] || '0',\n        platform: platform_match[0] || ''\n    };\n\n    const browser = {};\n    if (matched.browser) {\n        browser[matched.browser] = true;\n\n        const versionArray = matched.majorVersion.split('.');\n        browser.version = {\n            major: parseInt(matched.majorVersion, 10),\n            string: matched.version\n        };\n        if (versionArray.length > 1) {\n            browser.version.minor = parseInt(versionArray[1], 10);\n        }\n        if (versionArray.length > 2) {\n            browser.version.build = parseInt(versionArray[2], 10);\n        }\n    }\n\n    if (matched.platform) {\n        browser[matched.platform] = true;\n    }\n\n    if (browser.chrome || browser.opr || browser.safari) {\n        browser.webkit = true;\n    }\n\n    // MSIE. IE11 has 'rv' identifer\n    if (browser.rv || browser.iemobile) {\n        if (browser.rv) {\n            delete browser.rv;\n        }\n        const msie = 'msie';\n        matched.browser = msie;\n        browser[msie] = true;\n    }\n\n    // Microsoft Edge\n    if (browser.edge) {\n        delete browser.edge;\n        const msedge = 'msedge';\n        matched.browser = msedge;\n        browser[msedge] = true;\n    }\n\n    // Opera 15+\n    if (browser.opr) {\n        const opera = 'opera';\n        matched.browser = opera;\n        browser[opera] = true;\n    }\n\n    // Stock android browsers are marked as Safari\n    if (browser.safari && browser.android) {\n        const android = 'android';\n        matched.browser = android;\n        browser[android] = true;\n    }\n\n    browser.name = matched.browser;\n    browser.platform = matched.platform;\n\n    for (const key in Browser) {\n        if (Browser.hasOwnProperty(key)) {\n            delete Browser[key];\n        }\n    }\n    Object.assign(Browser, browser);\n}\n\ndetect();\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable */\n// Represents an media sample (audio / video)\nclass SampleInfo {\n\n    constructor(dts, pts, duration, originalDts, isSync) {\n        this.dts = dts;\n        this.pts = pts;\n        this.duration = duration;\n        this.originalDts = originalDts;\n        this.isSyncPoint = isSync;\n        this.fileposition = null;\n    }\n\n}\n\n// Media Segment concept is defined in Media Source Extensions spec.\n// Particularly in ISO BMFF format, an Media Segment contains a moof box followed by a mdat box.\nclass MediaSegmentInfo {\n\n    constructor() {\n        this.beginDts = 0;\n        this.endDts = 0;\n        this.beginPts = 0;\n        this.endPts = 0;\n        this.originalBeginDts = 0;\n        this.originalEndDts = 0;\n        this.syncPoints = []; // SampleInfo[n], for video IDR frames only\n        this.firstSample = null; // SampleInfo\n        this.lastSample = null; // SampleInfo\n    }\n\n    appendSyncPoint(sampleInfo) { // also called Random Access Point\n        sampleInfo.isSyncPoint = true;\n        this.syncPoints.push(sampleInfo);\n    }\n\n}\n\n// Ordered list for recording video IDR frames, sorted by originalDts\n\n\n// Data structure for recording information of media segments in single track.\nclass MediaSegmentInfoList {\n\n    constructor(type) {\n        this._type = type;\n        this._list = [];\n        this._lastAppendLocation = -1; // cached last insert location\n    }\n\n    get type() {\n        return this._type;\n    }\n\n    get length() {\n        return this._list.length;\n    }\n\n    isEmpty() {\n        return this._list.length === 0;\n    }\n\n    clear() {\n        this._list = [];\n        this._lastAppendLocation = -1;\n    }\n\n    _searchNearestSegmentBefore(originalBeginDts) {\n        const list = this._list;\n        if (list.length === 0) {\n            return -2;\n        }\n        const last = list.length - 1;\n        let mid = 0;\n        let lbound = 0;\n        let ubound = last;\n\n        let idx = 0;\n\n        if (originalBeginDts < list[0].originalBeginDts) {\n            idx = -1;\n            return idx;\n        }\n\n        while (lbound <= ubound) {\n            mid = lbound + Math.floor((ubound - lbound) / 2);\n            if (mid === last || (originalBeginDts > list[mid].lastSample.originalDts &&\n                    (originalBeginDts < list[mid + 1].originalBeginDts))) {\n                idx = mid;\n                break;\n            } else if (list[mid].originalBeginDts < originalBeginDts) {\n                lbound = mid + 1;\n            } else {\n                ubound = mid - 1;\n            }\n        }\n        return idx;\n    }\n\n    _searchNearestSegmentAfter(originalBeginDts) {\n        return this._searchNearestSegmentBefore(originalBeginDts) + 1;\n    }\n\n    append(mediaSegmentInfo) {\n        const list = this._list;\n        const msi = mediaSegmentInfo;\n        const lastAppendIdx = this._lastAppendLocation;\n        let insertIdx = 0;\n\n        if (lastAppendIdx !== -1 && lastAppendIdx < list.length &&\n            msi.originalBeginDts >= list[lastAppendIdx].lastSample.originalDts &&\n            ((lastAppendIdx === list.length - 1) ||\n                (lastAppendIdx < list.length - 1 &&\n                    msi.originalBeginDts < list[lastAppendIdx + 1].originalBeginDts))) {\n            insertIdx = lastAppendIdx + 1; // use cached location idx\n        } else {\n            if (list.length > 0) {\n                insertIdx = this._searchNearestSegmentBefore(msi.originalBeginDts) + 1;\n            }\n        }\n\n        this._lastAppendLocation = insertIdx;\n        this._list.splice(insertIdx, 0, msi);\n    }\n\n    getLastSegmentBefore(originalBeginDts) {\n        const idx = this._searchNearestSegmentBefore(originalBeginDts);\n        if (idx >= 0) {\n            return this._list[idx];\n        } else { // -1\n            return null;\n        }\n    }\n\n    getLastSampleBefore(originalBeginDts) {\n        const segment = this.getLastSegmentBefore(originalBeginDts);\n        if (segment != null) {\n            return segment.lastSample;\n        } else {\n            return null;\n        }\n    }\n\n    getLastSyncPointBefore(originalBeginDts) {\n        let segmentIdx = this._searchNearestSegmentBefore(originalBeginDts);\n        let syncPoints = this._list[segmentIdx].syncPoints;\n        while (syncPoints.length === 0 && segmentIdx > 0) {\n            segmentIdx--;\n            syncPoints = this._list[segmentIdx].syncPoints;\n        }\n        if (syncPoints.length > 0) {\n            return syncPoints[syncPoints.length - 1];\n        } else {\n            return null;\n        }\n    }\n\n}\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// import Log from '../utils/logger.js';\n// Fragmented mp4 remuxer\nclass MP4Remuxer {\n\n    constructor(config) {\n        this.TAG = 'MP4Remuxer';\n\n        this._config = config;\n        this._isLive = (config.isLive === true) ? true : false;\n\n        this._dtsBase = -1;\n        this._dtsBaseInited = false;\n        this._audioDtsBase = Infinity;\n        this._videoDtsBase = Infinity;\n        this._audioNextDts = undefined;\n        this._videoNextDts = undefined;\n\n        this._audioMeta = null;\n        this._videoMeta = null;\n\n        this._audioSegmentInfoList = new MediaSegmentInfoList('audio');\n        this._videoSegmentInfoList = new MediaSegmentInfoList('video');\n\n        this._onInitSegment = null;\n        this._onMediaSegment = null;\n\n        // Workaround for chrome < 50: Always force first sample as a Random Access Point in media segment\n        // see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n        this._forceFirstIDR = (Browser.chrome &&\n                              (Browser.version.major < 50 ||\n                              (Browser.version.major === 50 && Browser.version.build < 2661))) ? true : false;\n\n        // Workaround for IE11/Edge: Fill silent aac frame after keyframe-seeking\n        // Make audio beginDts equals with video beginDts, in order to fix seek freeze\n        this._fillSilentAfterSeek = (Browser.msedge || Browser.msie);\n\n        // While only FireFox supports 'audio/mp4, codecs=\"mp3\"', use 'audio/mpeg' for chrome, safari, ...\n        this._mp3UseMpegAudio = !Browser.firefox;\n    }\n\n    destroy() {\n        this._dtsBase = -1;\n        this._dtsBaseInited = false;\n        this._audioMeta = null;\n        this._videoMeta = null;\n        this._audioSegmentInfoList.clear();\n        this._audioSegmentInfoList = null;\n        this._videoSegmentInfoList.clear();\n        this._videoSegmentInfoList = null;\n        this._onInitSegment = null;\n        this._onMediaSegment = null;\n    }\n\n    bindDataSource(producer) {\n        producer.onDataAvailable = this.remux.bind(this);\n        producer.onTrackMetadata = this._onTrackMetadataReceived.bind(this);\n        return this;\n    }\n\n    /* prototype: function onInitSegment(type: string, initSegment: ArrayBuffer): void\n       InitSegment: {\n           type: string,\n           data: ArrayBuffer,\n           codec: string,\n           container: string\n       }\n    */\n    get onInitSegment() {\n        return this._onInitSegment;\n    }\n\n    set onInitSegment(callback) {\n        this._onInitSegment = callback;\n    }\n\n    /* prototype: function onMediaSegment(type: string, mediaSegment: MediaSegment): void\n       MediaSegment: {\n           type: string,\n           data: ArrayBuffer,\n           sampleCount: int32\n           info: MediaSegmentInfo\n       }\n    */\n    get onMediaSegment() {\n        return this._onMediaSegment;\n    }\n\n    set onMediaSegment(callback) {\n        this._onMediaSegment = callback;\n    }\n\n    insertDiscontinuity() {\n        this._audioNextDts = this._videoNextDts = undefined;\n    }\n\n    seek(originalDts) {\n        this._videoSegmentInfoList.clear();\n        this._audioSegmentInfoList.clear();\n    }\n\n    remux(audioTrack, videoTrack) {\n        if (!this._onMediaSegment) {\n            throw new IllegalStateException('MP4Remuxer: onMediaSegment callback must be specificed!');\n        }\n        if (!this._dtsBaseInited) {\n            this._calculateDtsBase(audioTrack, videoTrack);\n        }\n        this._remuxVideo(videoTrack);\n        this._remuxAudio(audioTrack);\n    }\n\n    _onTrackMetadataReceived(type, metadata) {\n        let metabox = null;\n\n        let container = 'mp4';\n        let codec = metadata.codec;\n\n        if (type === 'audio') {\n            this._audioMeta = metadata;\n            if (metadata.codec === 'mp3' && this._mp3UseMpegAudio) {\n                // 'audio/mpeg' for MP3 audio track\n                container = 'mpeg';\n                codec = '';\n                metabox = new Uint8Array();\n            } else {\n                // 'audio/mp4, codecs=\"codec\"'\n                metabox = MP4.generateInitSegment(metadata);\n            }\n        } else if (type === 'video') {\n            this._videoMeta = metadata;\n            metabox = MP4.generateInitSegment(metadata);\n        } else {\n            return;\n        }\n\n        // dispatch metabox (Initialization Segment)\n        if (!this._onInitSegment) {\n            throw new IllegalStateException('MP4Remuxer: onInitSegment callback must be specified!');\n        }\n        this._onInitSegment(type, {\n            type: type,\n            data: metabox.buffer,\n            codec: codec,\n            container: `${type}/${container}`,\n            mediaDuration: metadata.duration  // in timescale 1000 (milliseconds)\n        });\n    }\n\n    _calculateDtsBase(audioTrack, videoTrack) {\n        if (this._dtsBaseInited) {\n            return;\n        }\n\n        if (audioTrack.samples && audioTrack.samples.length) {\n            this._audioDtsBase = audioTrack.samples[0].dts;\n        }\n        if (videoTrack.samples && videoTrack.samples.length) {\n            this._videoDtsBase = videoTrack.samples[0].dts;\n        }\n\n        this._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase);\n        this._dtsBaseInited = true;\n    }\n\n    _remuxAudio(audioTrack) {\n        if (this._audioMeta == null) {\n            return;\n        }\n\n        let track = audioTrack;\n        let samples = track.samples;\n        let dtsCorrection = undefined;\n        let firstDts = -1, lastDts = -1, lastPts = -1;\n        let refSampleDuration = this._audioMeta.refSampleDuration;\n\n        let mpegRawTrack = this._audioMeta.codec === 'mp3' && this._mp3UseMpegAudio;\n        let firstSegmentAfterSeek = this._dtsBaseInited && this._audioNextDts === undefined;\n\n        let insertPrefixSilentFrame = false;\n\n        if (!samples || samples.length === 0) {\n            return;\n        }\n\n        let offset = 0;\n        let mdatbox = null;\n        let mdatBytes = 0;\n\n        // calculate initial mdat size\n        if (mpegRawTrack) {\n            // for raw mpeg buffer\n            offset = 0;\n            mdatBytes = track.length;\n        } else {\n            // for fmp4 mdat box\n            offset = 8;  // size + type\n            mdatBytes = 8 + track.length;\n        }\n\n        let firstSampleOriginalDts = samples[0].dts - this._dtsBase;\n\n        // calculate dtsCorrection\n        if (this._audioNextDts) {\n            dtsCorrection = firstSampleOriginalDts - this._audioNextDts;\n        } else {  // this._audioNextDts == undefined\n            if (this._audioSegmentInfoList.isEmpty()) {\n                dtsCorrection = 0;\n                if (this._fillSilentAfterSeek && !this._videoSegmentInfoList.isEmpty()) {\n                    if (this._audioMeta.originalCodec !== 'mp3') {\n                        insertPrefixSilentFrame = true;\n                    }\n                }\n            } else {\n                let lastSample = this._audioSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);\n                if (lastSample != null) {\n                    let distance = (firstSampleOriginalDts - (lastSample.originalDts + lastSample.duration));\n                    if (distance <= 3) {\n                        distance = 0;\n                    }\n                    let expectedDts = lastSample.dts + lastSample.duration + distance;\n                    dtsCorrection = firstSampleOriginalDts - expectedDts;\n                } else { // lastSample == null, cannot found\n                    dtsCorrection = 0;\n                }\n            }\n        }\n        \n        if (insertPrefixSilentFrame) {\n            // align audio segment beginDts to match with current video segment's beginDts\n            let firstSampleDts = firstSampleOriginalDts - dtsCorrection;\n            let videoSegment = this._videoSegmentInfoList.getLastSegmentBefore(firstSampleOriginalDts);\n            if (videoSegment != null && videoSegment.beginDts < firstSampleDts) {\n                let silentUnit = AAC.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);\n                if (silentUnit) {\n                    let dts = videoSegment.beginDts;\n                    let silentFrameDuration = firstSampleDts - videoSegment.beginDts;\n                    Log.v(this.TAG, `InsertPrefixSilentAudio: dts: ${dts}, duration: ${silentFrameDuration}`);\n                    samples.unshift({unit: silentUnit, dts: dts, pts: dts});\n                    mdatBytes += silentUnit.byteLength;\n                }  // silentUnit == null: Cannot generate, skip\n            } else {\n                insertPrefixSilentFrame = false;\n            }\n        }\n\n        let mp4Samples = [];\n\n        // Correct dts for each sample, and calculate sample duration. Then output to mp4Samples\n        for (let i = 0; i < samples.length; i++) {\n            let sample = samples[i];\n            let unit = sample.unit;\n            let originalDts = sample.dts - this._dtsBase;\n            let dts = originalDts - dtsCorrection;\n\n            if (firstDts === -1) {\n                firstDts = dts;\n            }\n\n            let sampleDuration = 0;\n\n            if (i !== samples.length - 1) {\n                let nextDts = samples[i + 1].dts - this._dtsBase - dtsCorrection;\n                sampleDuration = nextDts - dts;\n            } else {  // the last sample\n                if (mp4Samples.length >= 1) {  // use second last sample duration\n                    sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n                } else {  // the only one sample, use reference sample duration\n                    sampleDuration = Math.floor(refSampleDuration);\n                }\n            }\n\n            let needFillSilentFrames = false;\n            let silentFrames = null;\n\n            // Silent frame generation, if large timestamp gap detected\n            if (sampleDuration > refSampleDuration * 1.5 && this._audioMeta.codec !== 'mp3') {\n                // We need to insert silent frames to fill timestamp gap\n                needFillSilentFrames = true;\n                let delta = Math.abs(sampleDuration - refSampleDuration);\n                let frameCount = Math.ceil(delta / refSampleDuration);\n                let currentDts = dts + refSampleDuration;  // Notice: in float\n\n                // console.log(this.TAG, 'Large audio timestamp gap detected, may cause AV sync to drift. ' +\n                //                 'Silent frames will be generated to avoid unsync.\\n' +\n                //                 `dts: ${dts + sampleDuration} ms, expected: ${dts + Math.round(refSampleDuration)} ms, ` +\n                //                 `delta: ${Math.round(delta)} ms, generate: ${frameCount} frames`);\n\n                let silentUnit = AAC.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);\n                if (silentUnit == null) {\n                    // console.log(this.TAG, 'Unable to generate silent frame for ' +\n                    //                 `${this._audioMeta.originalCodec} with ${this._audioMeta.channelCount} channels, repeat last frame`);\n                    // Repeat last frame\n                    silentUnit = unit;\n                }\n                silentFrames = [];\n\n                for (let j = 0; j < frameCount; j++) {\n                    let intDts = Math.round(currentDts);  // round to integer\n                    if (silentFrames.length > 0) {\n                        // Set previous frame sample duration\n                        let previousFrame = silentFrames[silentFrames.length - 1];\n                        previousFrame.duration = intDts - previousFrame.dts;\n                    }\n                    let frame = {\n                        dts: intDts,\n                        pts: intDts,\n                        cts: 0,\n                        unit: silentUnit,\n                        size: silentUnit.byteLength,\n                        duration: 0,  // wait for next sample\n                        originalDts: originalDts,\n                        flags: {\n                            isLeading: 0,\n                            dependsOn: 1,\n                            isDependedOn: 0,\n                            hasRedundancy: 0\n                        }\n                    };\n                    silentFrames.push(frame);\n                    mdatBytes += unit.byteLength;\n                    currentDts += refSampleDuration;\n                }\n\n                // last frame: align end time to next frame dts\n                let lastFrame = silentFrames[silentFrames.length - 1];\n                lastFrame.duration = dts + sampleDuration - lastFrame.dts;\n\n                // silentFrames.forEach((frame) => {\n                //     Log.w(this.TAG, `SilentAudio: dts: ${frame.dts}, duration: ${frame.duration}`);\n                // });\n\n                // Set correct sample duration for current frame\n                sampleDuration = Math.round(refSampleDuration);\n            }\n\n            mp4Samples.push({\n                dts: dts,\n                pts: dts,\n                cts: 0,\n                unit: sample.unit,\n                size: sample.unit.byteLength,\n                duration: sampleDuration,\n                originalDts: originalDts,\n                flags: {\n                    isLeading: 0,\n                    dependsOn: 1,\n                    isDependedOn: 0,\n                    hasRedundancy: 0\n                }\n            });\n\n            if (needFillSilentFrames) {\n                // Silent frames should be inserted after wrong-duration frame\n                mp4Samples.push.apply(mp4Samples, silentFrames);\n            }\n        }\n\n        // allocate mdatbox\n        if (mpegRawTrack) {\n            // allocate for raw mpeg buffer\n            mdatbox = new Uint8Array(mdatBytes);\n        } else {\n            // allocate for fmp4 mdat box\n            mdatbox = new Uint8Array(mdatBytes);\n            // size field\n            mdatbox[0] = (mdatBytes >>> 24) & 0xFF;\n            mdatbox[1] = (mdatBytes >>> 16) & 0xFF;\n            mdatbox[2] = (mdatBytes >>>  8) & 0xFF;\n            mdatbox[3] = (mdatBytes) & 0xFF;\n            // type field (fourCC)\n            mdatbox.set(MP4.types.mdat, 4);\n        }\n\n        // Write samples into mdatbox\n        for (let i = 0; i < mp4Samples.length; i++) {\n            let unit = mp4Samples[i].unit;\n            mdatbox.set(unit, offset);\n            offset += unit.byteLength;\n        }\n\n        let latest = mp4Samples[mp4Samples.length - 1];\n        lastDts = latest.dts + latest.duration;\n        // console.log(latest.dts,latest.originalDts);\n        // lastDts = latest.originalDts + latest.duration;\n        this._audioNextDts = lastDts;\n        // console.log('dtsCorrection',dtsCorrection,'firstSampleOriginalDts',firstSampleOriginalDts,'_dtsBase',this._dtsBase,'this._audioNextDts',this._audioNextDts,'latest.dts',latest.dts,latest.originalDts)\n\n        // fill media segment info & add to info list\n        let info = new MediaSegmentInfo();\n        info.beginDts = firstDts;\n        info.endDts = lastDts;\n        info.beginPts = firstDts;\n        info.endPts = lastDts;\n        info.originalBeginDts = mp4Samples[0].originalDts;\n        info.originalEndDts = latest.originalDts + latest.duration;\n        info.firstSample = new SampleInfo(mp4Samples[0].dts,\n                                          mp4Samples[0].pts,\n                                          mp4Samples[0].duration,\n                                          mp4Samples[0].originalDts,\n                                          false);\n        info.lastSample = new SampleInfo(latest.dts,\n                                         latest.pts,\n                                         latest.duration,\n                                         latest.originalDts,\n                                         false);\n        if (!this._isLive) {\n            this._audioSegmentInfoList.append(info);\n        }\n\n        track.samples = mp4Samples;\n        track.sequenceNumber++;\n        // track.sequenceNumber += track.addcoefficient;\n        let moofbox = null;\n\n        if (mpegRawTrack) {\n            // Generate empty buffer, because useless for raw mpeg\n            moofbox = new Uint8Array();\n        } else {\n            // Generate moof for fmp4 segment\n            moofbox = MP4.moof(track, firstDts);\n        }\n\n        track.samples = [];\n        track.length = 0;\n\n        let segment = {\n            type: 'audio',\n            data: this._mergeBoxes(moofbox, mdatbox).buffer,\n            sampleCount: mp4Samples.length,\n            info: info\n        };\n\n        if (mpegRawTrack && firstSegmentAfterSeek) {\n            // For MPEG audio stream in MSE, if seeking occurred, before appending new buffer\n            // We need explicitly set timestampOffset to the desired point in timeline for mpeg SourceBuffer.\n            segment.timestampOffset = firstDts;\n        }\n\n        this._onMediaSegment('audio', segment);\n    }\n\n    _remuxVideo(videoTrack) {\n        if (this._videoMeta == null) {\n            return;\n        }\n\n        let track = videoTrack;\n        let samples = track.samples;\n        let dtsCorrection = undefined;\n        let firstDts = -1, lastDts = -1;\n        let firstPts = -1, lastPts = -1;\n\n        if (!samples || samples.length === 0) {\n            return;\n        }\n\n        let offset = 8;\n        let mdatBytes = 8 + videoTrack.length;\n        let mdatbox = new Uint8Array(mdatBytes);\n        mdatbox[0] = (mdatBytes >>> 24) & 0xFF;\n        mdatbox[1] = (mdatBytes >>> 16) & 0xFF;\n        mdatbox[2] = (mdatBytes >>>  8) & 0xFF;\n        mdatbox[3] = (mdatBytes) & 0xFF;\n        mdatbox.set(MP4.types.mdat, 4);\n\n        let firstSampleOriginalDts = samples[0].dts - this._dtsBase;\n\n        // calculate dtsCorrection\n        if (this._videoNextDts) {\n            dtsCorrection = firstSampleOriginalDts - this._videoNextDts;\n        } else {  // this._videoNextDts == undefined\n            if (this._videoSegmentInfoList.isEmpty()) {\n                dtsCorrection = 0;\n            } else {\n                let lastSample = this._videoSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);\n                if (lastSample != null) {\n                    let distance = (firstSampleOriginalDts - (lastSample.originalDts + lastSample.duration));\n                    if (distance <= 3) {\n                        distance = 0;\n                    }\n                    let expectedDts = lastSample.dts + lastSample.duration + distance;\n                    dtsCorrection = firstSampleOriginalDts - expectedDts;\n                } else { // lastSample == null, cannot found\n                    dtsCorrection = 0;\n                }\n            }\n        }\n\n        let info = new MediaSegmentInfo();\n        let mp4Samples = [];\n\n        // Correct dts for each sample, and calculate sample duration. Then output to mp4Samples\n        for (let i = 0; i < samples.length; i++) {\n            let sample = samples[i];\n            let originalDts = sample.dts - this._dtsBase;\n            let isKeyframe = sample.isKeyframe;\n            let dts = originalDts - dtsCorrection;\n            let cts = sample.cts;\n            let pts = dts + cts;\n\n            if (firstDts === -1) {\n                firstDts = dts;\n                firstPts = pts;\n            }\n\n            let sampleDuration = 0;\n\n            if (i !== samples.length - 1) {\n                let nextDts = samples[i + 1].dts - this._dtsBase - dtsCorrection;\n                sampleDuration = nextDts - dts;\n            } else {  // the last sample\n                if (mp4Samples.length >= 1) {  // use second last sample duration\n                    sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n                } else {  // the only one sample, use reference sample duration\n                    sampleDuration = Math.floor(this._videoMeta.refSampleDuration);\n                }\n            }\n\n            if (isKeyframe) {\n                let syncPoint = new SampleInfo(dts, pts, sampleDuration, sample.dts, true);\n                syncPoint.fileposition = sample.fileposition;\n                info.appendSyncPoint(syncPoint);\n            }\n\n            mp4Samples.push({\n                dts: dts,\n                pts: pts,\n                cts: cts,\n                units: sample.units,\n                size: sample.length,\n                isKeyframe: isKeyframe,\n                duration: sampleDuration,\n                originalDts: originalDts,\n                flags: {\n                    isLeading: 0,\n                    dependsOn: isKeyframe ? 2 : 1,\n                    isDependedOn: isKeyframe ? 1 : 0,\n                    hasRedundancy: 0,\n                    isNonSync: isKeyframe ? 0 : 1\n                }\n            });\n        }\n\n        // Write samples into mdatbox\n        for (let i = 0; i < mp4Samples.length; i++) {\n            let units = mp4Samples[i].units;\n            while (units.length) {\n                let unit = units.shift();\n                let data = unit.data;\n                mdatbox.set(data, offset);\n                offset += data.byteLength;\n            }\n        }\n\n        let latest = mp4Samples[mp4Samples.length - 1];\n        lastDts = latest.dts + latest.duration;\n        // lastDts = latest.originalDts + latest.duration;\n        lastPts = latest.pts + latest.duration;\n        this._videoNextDts = lastDts;\n\n        // fill media segment info & add to info list\n        info.beginDts = firstDts;\n        info.endDts = lastDts;\n        info.beginPts = firstPts;\n        info.endPts = lastPts;\n        info.originalBeginDts = mp4Samples[0].originalDts;\n        info.originalEndDts = latest.originalDts + latest.duration;\n        info.firstSample = new SampleInfo(mp4Samples[0].dts,\n                                          mp4Samples[0].pts,\n                                          mp4Samples[0].duration,\n                                          mp4Samples[0].originalDts,\n                                          mp4Samples[0].isKeyframe);\n        info.lastSample = new SampleInfo(latest.dts,\n                                         latest.pts,\n                                         latest.duration,\n                                         latest.originalDts,\n                                         latest.isKeyframe);\n        if (!this._isLive) {\n            this._videoSegmentInfoList.append(info);\n        }\n\n        track.samples = mp4Samples;\n        track.sequenceNumber++;\n        // track.sequenceNumber += track.addcoefficient;\n\n        // workaround for chrome < 50: force first sample as a random access point\n        // see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n        if (this._forceFirstIDR) {\n            let flags = mp4Samples[0].flags;\n            flags.dependsOn = 2;\n            flags.isNonSync = 0;\n        }\n\n        let moofbox = MP4.moof(track, firstDts);\n        track.samples = [];\n        track.length = 0;\n\n        this._onMediaSegment('video', {\n            type: 'video',\n            data: this._mergeBoxes(moofbox, mdatbox).buffer,\n            sampleCount: mp4Samples.length,\n            info: info\n        });\n    }\n\n    _mergeBoxes(moof, mdat) {\n        let result = new Uint8Array(moof.byteLength + mdat.byteLength);\n        result.set(moof, 0);\n        result.set(mdat, moof.byteLength);\n        return result;\n    }\n\n}\n\n/* eslint-disable */\nclass flv2fmp4 {\n\n    /**\n     * Creates an instance of flv2fmp4.\n     * config 里面有_isLive属性,是否是直播\n     * @param {any} config\n     *\n     * @memberof flv2fmp4\n     */\n    constructor(config) {\n        this._config = { _isLive: false };\n        this._config = Object.assign(this._config, config);\n\n        // 外部方法赋值\n        this.onInitSegment = null;\n        this.onMediaSegment = null;\n        this.onMediaInfo = null;\n        this.seekCallBack = null;\n\n        // 内部使用\n        this.loadmetadata = false;\n        this.ftyp_moov = null;//单路\n\n        this.ftyp_moov_v=null;//双路视频\n        this.ftyp_moov_a=null;//双路音频\n        this.metaSuccRun = false;\n        this.metas = [];\n        this.parseChunk = null;\n        this.hasVideo = false;\n        this.hasAudio = false;\n        this._error=null;\n        // 临时记录seek时间\n        this._pendingResolveSeekPoint = -1;\n\n        // 临时记录flv数据起始时间\n        this._tempBaseTime = 0;\n\n        // 处理flv数据入口\n        this.setflvBase = this.setflvBasefrist;\n\n        tagdemux._onTrackMetadata = this.Metadata.bind(this);\n        tagdemux._onMediaInfo = this.metaSucc.bind(this);\n        tagdemux._onDataAvailable = this.onDataAvailable.bind(this);\n        tagdemux._onError=this.error.bind(this);\n        this.m4mof = new MP4Remuxer(this._config);\n        this.m4mof.onMediaSegment = this.onMdiaSegment.bind(this);\n    }\n    seek(baseTime) {\n        this.setflvBase = this.setflvBasefrist;\n        if (baseTime == undefined || baseTime == 0) {\n            baseTime = 0;\n            this._pendingResolveSeekPoint = -1;\n        }\n        if (this._tempBaseTime != baseTime) {\n            this._tempBaseTime = baseTime;\n            tagdemux._timestampBase = baseTime;\n            this.m4mof.seek(baseTime);\n            this.m4mof.insertDiscontinuity();\n            this._pendingResolveSeekPoint = baseTime;\n        }\n    }\n\n    /**\n     * 不要主动调用这个接口!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n     * 第一次接受数据,和seek时候接受数据入口,\n     *\n     * @param {any} arraybuff\n     * @param {any} baseTime\n     * @returns\n     *\n     * @memberof flv2fmp4\n     */\n    setflvBasefrist(arraybuff, baseTime) {\n\n        let offset = 0;\n        try {\n            offset = flvparse.setFlv(new Uint8Array(arraybuff));\n        } catch (error$$1) {\n            this.error(error$$1);\n        }\n        if(flvparse.arrTag.length==0)return offset;\n        if(flvparse.arrTag[0].type!=18){\n            if(this.error)this.error(new Error('without metadata tag'));\n        }\n        if (flvparse.arrTag.length > 0) {\n            tagdemux.hasAudio=this.hasAudio = flvparse._hasAudio;\n            tagdemux.hasVideo=this.hasVideo = flvparse._hasVideo;\n            \n            if (this._tempBaseTime != 0 && this._tempBaseTime == flvparse.arrTag[0].getTime()) {\n                tagdemux._timestampBase = 0;\n            }\n            try {\n                tagdemux.moofTag(flvparse.arrTag);\n            } catch (error$$1) {\n                this.error(error$$1);\n            }\n            this.setflvBase = this.setflvBaseUsually;\n        }\n\n        return offset;\n    }\n\n    /**\n     * 不要主动调用这个接口!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n     * 后续接受数据接口\n     * @param {any} arraybuff\n     * @param {any} baseTime\n     * @returns\n     *\n     * @memberof flv2fmp4\n     */\n    setflvBaseUsually(arraybuff, baseTime) {\n        let offset =0;\n        try {\n            offset = flvparse.setFlv(new Uint8Array(arraybuff));\n        } catch (error$$1) {\n            this.error(error$$1);\n        }\n        if (flvparse.arrTag.length > 0) {\n            try {\n                tagdemux.moofTag(flvparse.arrTag);\n            } catch (error$$1) {\n                this.error(error$$1);\n            }\n        }\n\n        return offset;\n    }\n\n    /**\n     * 不要主动调用这个接口!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n     * moof回调\n     *\n     * @param {any} track\n     * @param {any} value\n     *\n     * @memberof flv2fmp4\n     */\n    onMdiaSegment(track, value) {\n\n        if (this.onMediaSegment) {\n            this.onMediaSegment(track,new Uint8Array(value.data));\n        }\n        if (this._pendingResolveSeekPoint != -1 && track == 'video') {\n            let seekpoint = this._pendingResolveSeekPoint;\n            this._pendingResolveSeekPoint = -1;\n            if (this.seekCallBack) {\n                this.seekCallBack(seekpoint);\n            }\n        }\n    }\n\n    /**\n     *\n     * 音频和视频的初始化tag\n     *\n     * @param {any} type\n     * @param {any} meta\n     *\n     * @memberof flv2fmp4\n     */\n    Metadata(type, meta) {\n        switch (type) {\n            case 'video':\n                this.metas.push(['video',meta]);\n                this.m4mof._videoMeta = meta;\n                if (this.hasVideo && !this.hasAudio) {\n                    this.metaSucc();\n                    return;\n                }\n                break;\n            case 'audio':\n                this.metas.push(['audio',meta]);\n                this.m4mof._audioMeta = meta;\n                if (!this.hasVideo && this.hasAudio) {\n                    this.metaSucc();\n                    return;\n                }\n                break;\n        }\n        if (this.hasVideo && this.hasAudio  && this.metas.length > 1) {\n            this.metaSucc();\n        }\n    }\n\n    /**\n     * metadata解读成功后触发及第一个视频tag和第一个音频tag\n     *\n     * @param {any} mi\n     * @returns\n     *\n     * @memberof flv2fmp4\n     */\n    metaSucc(mi) {\n        if (this.onMediaInfo) {\n            this.onMediaInfo(mi||tagdemux._mediaInfo, { hasAudio: this.hasAudio, hasVideo: this.hasVideo });\n        }\n        // 获取ftyp和moov\n        if (this.metas.length == 0) {\n            this.metaSuccRun = true;\n            return;\n        }\n        if(mi)return;\n        if(this.metas.length>1){\n            // this.ftyp_moov_v=\n            this.metas.map(item=>{\n                if(item[0]=='video'){\n                    this.ftyp_moov_v=MP4.generateInitSegment([item[1]]);\n                }else{\n                    this.ftyp_moov_a=MP4.generateInitSegment([item[1]]);\n                }\n            });\n        }else{\n            this.ftyp_moov = MP4.generateInitSegment([this.metas[0][1]]);\n        }\n        \n        if (this.onInitSegment && this.loadmetadata == false) {\n\n            if(this.ftyp_moov)\n            {\n                this.onInitSegment(this.ftyp_moov);\n            }else{\n                this.onInitSegment(this.ftyp_moov_v,this.ftyp_moov_a);\n            }\n            this.loadmetadata = true;\n        }\n    }\n\n    onDataAvailable(audiotrack, videotrack) {\n        // this.m4mof.remux(audiotrack, videotrack);\n\n        try{\n            this.m4mof.remux(audiotrack, videotrack);\n        }catch(e){\n            this.error(e);\n        }\n    }\n\n    /**\n     * 传入flv的二进制数据\n     * 统一入口\n     * @param {any} arraybuff\n     * @param {any} baseTime flv数据开始时间\n     * @returns\n     *\n     * @memberof flv2fmp4\n     */\n    setflv(arraybuff, baseTime) {\n        return this.setflvBase(arraybuff, baseTime);\n    }\n\n    /**\n     *\n     * 本地调试代码,不用理会\n     * @param {any} arraybuff\n     * @returns\n     *\n     * @memberof flv2fmp4\n     */\n    setflvloc(arraybuff) {\n        const offset = flvparse.setFlv(new Uint8Array(arraybuff));\n\n        if (flvparse.arrTag.length > 0) {\n            return flvparse.arrTag;\n        }\n    }\n    /**\n     * \n     *  异常抛出处理\n     * @param {any} e \n     * @memberof flv2fmp4\n     */\n    error(e) {\n        if(this._error){\n            this._error(e);\n        }\n    }\n}\n\n/**\n * 封装的对外类,有些方法不想对外暴露,所以封装这么一个类\n *\n * @class foreign\n */\nclass foreign extends __WEBPACK_IMPORTED_MODULE_0_chimee_helper__[\"CustEvent\"] {\n    constructor(config) {\n        super();\n        this.f2m = new flv2fmp4(config);\n        this.f2m._error=this.error;\n        // 外部方法赋值\n        this._onInitSegment = null;\n        this._onMediaSegment = null;\n        this._onMediaInfo = null;\n        this._seekCallBack = null;\n    }\n    error(e){\n        this.emit('error',e.type);\n    }\n    /**\n     *\n     * 跳转\n     * @param {any} basetime  跳转时间\n     *\n     * @memberof foreign\n     */\n    seek(basetime) {\n        this.f2m.seek(basetime);\n    }\n\n    /**\n     * 传入flv的二进制数据\n     * 统一入口\n     * @param {any} arraybuff\n     * @returns\n     *\n     * @memberof flv2fmp4\n     */\n    setflv(arraybuff) {\n        return this.f2m.setflv(arraybuff, 0);\n    }\n\n    /**\n     *\n     * 本地调试代码,不用理会\n     * @param {any} arraybuff\n     * @returns\n     *\n     * @memberof flv2fmp4\n     */\n    setflvloc(arraybuff) {\n        return this.f2m.setflvloc(arraybuff);\n    }\n\n    /**\n     * 赋值初始化seg接受方法\n     *\n     *\n     * @memberof foreign\n     */\n    set onInitSegment(fun) {\n        this._onInitSegment = fun;\n        this.f2m.onInitSegment = fun;\n    }\n\n    /**\n     * 赋值moof接受方法\n     *\n     *\n     * @memberof foreign\n     */\n    set onMediaSegment(fun) {\n        this._onMediaSegment = fun;\n        this.f2m.onMediaSegment = fun;\n    }\n\n    /**\n     * 赋值metadata接受方法\n     *\n     *\n     * @memberof foreign\n     */\n    set onMediaInfo(fun) {\n        this._onMediaInfo = fun;\n        this.f2m.onMediaInfo = fun;\n    }\n\n    /**\n     * 赋值是否跳转回调接受方法\n     *\n     *\n     * @memberof foreign\n     */\n    set seekCallBack(fun) {\n        this._seekCallBack = fun;\n        this.f2m.seekCallBack = fun;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (foreign);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvaW5kZXhfcm9sbHVwLmpzPzE3MmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyx5RkFBeUY7O0FBRTlIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qix1RkFBdUY7O0FBRS9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1QkFBdUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNB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QW1EO0FBQ3BKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUgsbUJBQW1CO0FBQ3BJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixzRUFBc0UsRUFBRSxPQUFPLG1EQUFtRDtBQUNoSzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsaUJBQWlCOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQjs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ3VzdEV2ZW50IH0gZnJvbSAnY2hpbWVlLWhlbHBlcic7XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5jbGFzcyBGbHZUYWcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRhZ1R5cGUgPSAtMTtcbiAgICAgICAgdGhpcy5kYXRhU2l6ZSA9IC0xO1xuICAgICAgICB0aGlzLlRpbWVzdGFtcCA9IC0xO1xuICAgICAgICB0aGlzLlN0cmVhbUlEID0gLTE7XG4gICAgICAgIHRoaXMuYm9keSA9IC0xO1xuICAgICAgICB0aGlzLnRpbWUgPSAtMTtcbiAgICAgICAgdGhpcy5hcnIgPSBbXTtcbiAgICAgICAgdGhpcy5zaXplPS0xO1xuICAgIH1cbiAgICBnZXRUaW1lKCkge1xuICAgICAgICAvLyB0aGlzLlRpbWVzdGFtcC5wb3AoKTtcbiAgICAgICAgdGhpcy5hcnIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLlRpbWVzdGFtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hcnIucHVzaCgodGhpcy5UaW1lc3RhbXBbaV0udG9TdHJpbmcoMTYpLmxlbmd0aCA9PSAxID8gJzAnICsgdGhpcy5UaW1lc3RhbXBbaV0udG9TdHJpbmcoMTYpIDogdGhpcy5UaW1lc3RhbXBbaV0udG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcnIucG9wKCk7XG4gICAgICAgIGNvbnN0IHRpbWUgPSB0aGlzLmFyci5qb2luKCcnKTtcbiAgICAgICAgdGhpcy50aW1lID0gcGFyc2VJbnQodGltZSwgMTYpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGltZSwgMTYpO1xuICAgIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmZ1bmN0aW9uIGRlY29kZVVURjgodWludDhhcnJheSkge1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGNvbnN0IGlucHV0ID0gdWludDhhcnJheTtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbGVuZ3RoID0gdWludDhhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoaW5wdXRbaV0gPCAweDgwKSB7XG4gICAgICAgICAgICBvdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGlucHV0W2ldKSk7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dFtpXSA8IDB4QzApIHtcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRbaV0gPCAweEUwKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tDb250aW51YXRpb24oaW5wdXQsIGksIDEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdWNzNCA9IChpbnB1dFtpXSAmIDB4MUYpIDw8IDYgfCAoaW5wdXRbaSArIDFdICYgMHgzRik7XG4gICAgICAgICAgICAgICAgaWYgKHVjczQgPj0gMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHVjczQgJiAweEZGRkYpKTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRbaV0gPCAweEYwKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tDb250aW51YXRpb24oaW5wdXQsIGksIDIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdWNzNCA9IChpbnB1dFtpXSAmIDB4RikgPDwgMTIgfCAoaW5wdXRbaSArIDFdICYgMHgzRikgPDwgNiB8IGlucHV0W2kgKyAyXSAmIDB4M0Y7XG4gICAgICAgICAgICAgICAgaWYgKHVjczQgPj0gMHg4MDAgJiYgKHVjczQgJiAweEY4MDApICE9PSAweEQ4MDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSh1Y3M0ICYgMHhGRkZGKSk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0W2ldIDwgMHhGOCkge1xuICAgICAgICAgICAgaWYgKGNoZWNrQ29udGludWF0aW9uKGlucHV0LCBpLCAzKSkge1xuICAgICAgICAgICAgICAgIGxldCB1Y3M0ID0gKGlucHV0W2ldICYgMHg3KSA8PCAxOCB8IChpbnB1dFtpICsgMV0gJiAweDNGKSA8PCAxMiB8XG4gICAgICAgICAgICAgICAgICAgIChpbnB1dFtpICsgMl0gJiAweDNGKSA8PCA2IHwgKGlucHV0W2kgKyAzXSAmIDB4M0YpO1xuICAgICAgICAgICAgICAgIGlmICh1Y3M0ID4gMHgxMDAwMCAmJiB1Y3M0IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgdWNzNCAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKCh1Y3M0ID4+PiAxMCkgfCAweEQ4MDApKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgodWNzNCAmIDB4M0ZGKSB8IDB4REMwMCkpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkpO1xuICAgICAgICArK2k7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDb250aW51YXRpb24odWludDhhcnJheSwgc3RhcnQsIGNoZWNrTGVuZ3RoKSB7XG4gICAgbGV0IGFycmF5ID0gdWludDhhcnJheTtcbiAgICBpZiAoc3RhcnQgKyBjaGVja0xlbmd0aCA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICB3aGlsZSAoY2hlY2tMZW5ndGgtLSkge1xuICAgICAgICAgICAgaWYgKChhcnJheVsrK3N0YXJ0XSAmIDB4QzApICE9PSAweDgwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IEJpbGliaWxpLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIEBhdXRob3IgemhlbmcgcWlhbiA8eHFxQHhxcS5pbT5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBFeHBvbmVudGlhbC1Hb2xvbWIgYnVmZmVyIGRlY29kZXJcbmNsYXNzIEV4cEdvbG9tYiB7XG5cbiAgICBjb25zdHJ1Y3Rvcih1aW50OGFycmF5KSB7XG4gICAgICAgIHRoaXMuVEFHID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IHVpbnQ4YXJyYXk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcl9pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX3RvdGFsX2J5dGVzID0gdWludDhhcnJheS5ieXRlTGVuZ3RoO1xuICAgICAgICB0aGlzLl90b3RhbF9iaXRzID0gdWludDhhcnJheS5ieXRlTGVuZ3RoICogODtcbiAgICAgICAgdGhpcy5fY3VycmVudF93b3JkID0gMDtcbiAgICAgICAgdGhpcy5fY3VycmVudF93b3JkX2JpdHNfbGVmdCA9IDA7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBfZmlsbEN1cnJlbnRXb3JkKCkge1xuICAgICAgICBjb25zdCBidWZmZXJfYnl0ZXNfbGVmdCA9IHRoaXMuX3RvdGFsX2J5dGVzIC0gdGhpcy5fYnVmZmVyX2luZGV4O1xuICAgICAgICBpZiAoYnVmZmVyX2J5dGVzX2xlZnQgPD0gMCkgeyB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCdFeHBHb2xvbWI6IF9maWxsQ3VycmVudFdvcmQoKSBidXQgbm8gYnl0ZXMgYXZhaWxhYmxlJyk7IH1cblxuICAgICAgICBjb25zdCBieXRlc19yZWFkID0gTWF0aC5taW4oNCwgYnVmZmVyX2J5dGVzX2xlZnQpO1xuICAgICAgICBjb25zdCB3b3JkID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIHdvcmQuc2V0KHRoaXMuX2J1ZmZlci5zdWJhcnJheSh0aGlzLl9idWZmZXJfaW5kZXgsIHRoaXMuX2J1ZmZlcl9pbmRleCArIGJ5dGVzX3JlYWQpKTtcbiAgICAgICAgdGhpcy5fY3VycmVudF93b3JkID0gbmV3IERhdGFWaWV3KHdvcmQuYnVmZmVyKS5nZXRVaW50MzIoMCwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuX2J1ZmZlcl9pbmRleCArPSBieXRlc19yZWFkO1xuICAgICAgICB0aGlzLl9jdXJyZW50X3dvcmRfYml0c19sZWZ0ID0gYnl0ZXNfcmVhZCAqIDg7XG4gICAgfVxuXG4gICAgcmVhZEJpdHMoYml0cykge1xuICAgICAgICBpZiAoYml0cyA+IDMyKSB7IHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oJ0V4cEdvbG9tYjogcmVhZEJpdHMoKSBiaXRzIGV4Y2VlZGVkIG1heCAzMmJpdHMhJyk7IH1cblxuICAgICAgICBpZiAoYml0cyA8PSB0aGlzLl9jdXJyZW50X3dvcmRfYml0c19sZWZ0KSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jdXJyZW50X3dvcmQgPj4+ICgzMiAtIGJpdHMpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudF93b3JkIDw8PSBiaXRzO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudF93b3JkX2JpdHNfbGVmdCAtPSBiaXRzO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9jdXJyZW50X3dvcmRfYml0c19sZWZ0ID8gdGhpcy5fY3VycmVudF93b3JkIDogMDtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID4+PiAoMzIgLSB0aGlzLl9jdXJyZW50X3dvcmRfYml0c19sZWZ0KTtcbiAgICAgICAgY29uc3QgYml0c19uZWVkX2xlZnQgPSBiaXRzIC0gdGhpcy5fY3VycmVudF93b3JkX2JpdHNfbGVmdDtcblxuICAgICAgICB0aGlzLl9maWxsQ3VycmVudFdvcmQoKTtcbiAgICAgICAgY29uc3QgYml0c19yZWFkX25leHQgPSBNYXRoLm1pbihiaXRzX25lZWRfbGVmdCwgdGhpcy5fY3VycmVudF93b3JkX2JpdHNfbGVmdCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0MiA9IHRoaXMuX2N1cnJlbnRfd29yZCA+Pj4gKDMyIC0gYml0c19yZWFkX25leHQpO1xuICAgICAgICB0aGlzLl9jdXJyZW50X3dvcmQgPDw9IGJpdHNfcmVhZF9uZXh0O1xuICAgICAgICB0aGlzLl9jdXJyZW50X3dvcmRfYml0c19sZWZ0IC09IGJpdHNfcmVhZF9uZXh0O1xuXG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgYml0c19yZWFkX25leHQpIHwgcmVzdWx0MjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZWFkQm9vbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMSkgPT09IDE7XG4gICAgfVxuXG4gICAgcmVhZEJ5dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDgpO1xuICAgIH1cblxuICAgIF9za2lwTGVhZGluZ1plcm8oKSB7XG4gICAgICAgIGxldCB6ZXJvX2NvdW50O1xuICAgICAgICBmb3IgKHplcm9fY291bnQgPSAwOyB6ZXJvX2NvdW50IDwgdGhpcy5fY3VycmVudF93b3JkX2JpdHNfbGVmdDsgemVyb19jb3VudCsrKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuX2N1cnJlbnRfd29yZCAmICgweDgwMDAwMDAwID4+PiB6ZXJvX2NvdW50KSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50X3dvcmQgPDw9IHplcm9fY291bnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudF93b3JkX2JpdHNfbGVmdCAtPSB6ZXJvX2NvdW50O1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvX2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZpbGxDdXJyZW50V29yZCgpO1xuICAgICAgICByZXR1cm4gemVyb19jb3VudCArIHRoaXMuX3NraXBMZWFkaW5nWmVybygpO1xuICAgIH1cblxuICAgIHJlYWRVRUcoKSB7IC8vIHVuc2lnbmVkIGV4cG9uZW50aWFsIGdvbG9tYlxuICAgICAgICBjb25zdCBsZWFkaW5nX3plcm9zID0gdGhpcy5fc2tpcExlYWRpbmdaZXJvKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGxlYWRpbmdfemVyb3MgKyAxKSAtIDE7XG4gICAgfVxuXG4gICAgcmVhZFNFRygpIHsgLy8gc2lnbmVkIGV4cG9uZW50aWFsIGdvbG9tYlxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucmVhZFVFRygpO1xuICAgICAgICBpZiAodmFsdWUgJiAweDAxKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlICsgMSkgPj4+IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTEgKiAodmFsdWUgPj4+IDEpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgQmlsaWJpbGkuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogQGF1dGhvciB6aGVuZyBxaWFuIDx4cXFAeHFxLmltPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNsYXNzIFNQU1BhcnNlciB7XG5cbiAgICBzdGF0aWMgX2Vic3AycmJzcCh1aW50OGFycmF5KSB7XG4gICAgICAgIGNvbnN0IHNyYyA9IHVpbnQ4YXJyYXk7XG4gICAgICAgIGNvbnN0IHNyY19sZW5ndGggPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICAgICAgY29uc3QgZHN0ID0gbmV3IFVpbnQ4QXJyYXkoc3JjX2xlbmd0aCk7XG4gICAgICAgIGxldCBkc3RfaWR4ID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNyY19sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPj0gMikge1xuICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlOiBTa2lwIDB4MDMgYWZ0ZXIgMDAgMDBcbiAgICAgICAgICAgICAgICBpZiAoc3JjW2ldID09PSAweDAzICYmIHNyY1tpIC0gMV0gPT09IDB4MDAgJiYgc3JjW2kgLSAyXSA9PT0gMHgwMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkc3RbZHN0X2lkeF0gPSBzcmNbaV07XG4gICAgICAgICAgICBkc3RfaWR4Kys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZHN0LmJ1ZmZlciwgMCwgZHN0X2lkeCk7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlU1BTKHVpbnQ4YXJyYXkpIHtcbiAgICAgICAgY29uc3QgcmJzcCA9IFNQU1BhcnNlci5fZWJzcDJyYnNwKHVpbnQ4YXJyYXkpO1xuICAgICAgICBsZXQgZ2IgPSBuZXcgRXhwR29sb21iKHJic3ApO1xuXG4gICAgICAgIGdiLnJlYWRCeXRlKCk7XG4gICAgICAgIGNvbnN0IHByb2ZpbGVfaWRjID0gZ2IucmVhZEJ5dGUoKTsgLy8gcHJvZmlsZV9pZGNcbiAgICAgICAgZ2IucmVhZEJ5dGUoKTsgLy8gY29uc3RyYWludF9zZXRfZmxhZ3NbNV0gKyByZXNlcnZlZF96ZXJvWzNdXG4gICAgICAgIGNvbnN0IGxldmVsX2lkYyA9IGdiLnJlYWRCeXRlKCk7IC8vIGxldmVsX2lkY1xuICAgICAgICBnYi5yZWFkVUVHKCk7IC8vIHNlcV9wYXJhbWV0ZXJfc2V0X2lkXG5cbiAgICAgICAgY29uc3QgcHJvZmlsZV9zdHJpbmcgPSBTUFNQYXJzZXIuZ2V0UHJvZmlsZVN0cmluZyhwcm9maWxlX2lkYyk7XG4gICAgICAgIGNvbnN0IGxldmVsX3N0cmluZyA9IFNQU1BhcnNlci5nZXRMZXZlbFN0cmluZyhsZXZlbF9pZGMpO1xuICAgICAgICBsZXQgY2hyb21hX2Zvcm1hdF9pZGMgPSAxO1xuICAgICAgICBsZXQgY2hyb21hX2Zvcm1hdCA9IDQyMDtcbiAgICAgICAgY29uc3QgY2hyb21hX2Zvcm1hdF90YWJsZSA9IFswLCA0MjAsIDQyMiwgNDQ0XTtcbiAgICAgICAgbGV0IGJpdF9kZXB0aCA9IDg7XG5cbiAgICAgICAgaWYgKHByb2ZpbGVfaWRjID09PSAxMDAgfHwgcHJvZmlsZV9pZGMgPT09IDExMCB8fCBwcm9maWxlX2lkYyA9PT0gMTIyIHx8XG4gICAgICAgICAgICBwcm9maWxlX2lkYyA9PT0gMjQ0IHx8IHByb2ZpbGVfaWRjID09PSA0NCB8fCBwcm9maWxlX2lkYyA9PT0gODMgfHxcbiAgICAgICAgICAgIHByb2ZpbGVfaWRjID09PSA4NiB8fCBwcm9maWxlX2lkYyA9PT0gMTE4IHx8IHByb2ZpbGVfaWRjID09PSAxMjggfHxcbiAgICAgICAgICAgIHByb2ZpbGVfaWRjID09PSAxMzggfHwgcHJvZmlsZV9pZGMgPT09IDE0NCkge1xuXG4gICAgICAgICAgICBjaHJvbWFfZm9ybWF0X2lkYyA9IGdiLnJlYWRVRUcoKTtcbiAgICAgICAgICAgIGlmIChjaHJvbWFfZm9ybWF0X2lkYyA9PT0gMykge1xuICAgICAgICAgICAgICAgIGdiLnJlYWRCaXRzKDEpOyAvLyBzZXBhcmF0ZV9jb2xvdXJfcGxhbmVfZmxhZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNocm9tYV9mb3JtYXRfaWRjIDw9IDMpIHtcbiAgICAgICAgICAgICAgICBjaHJvbWFfZm9ybWF0ID0gY2hyb21hX2Zvcm1hdF90YWJsZVtjaHJvbWFfZm9ybWF0X2lkY107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJpdF9kZXB0aCA9IGdiLnJlYWRVRUcoKSArIDg7IC8vIGJpdF9kZXB0aF9sdW1hX21pbnVzOFxuICAgICAgICAgICAgZ2IucmVhZFVFRygpOyAvLyBiaXRfZGVwdGhfY2hyb21hX21pbnVzOFxuICAgICAgICAgICAgZ2IucmVhZEJpdHMoMSk7IC8vIHFwcHJpbWVfeV96ZXJvX3RyYW5zZm9ybV9ieXBhc3NfZmxhZ1xuICAgICAgICAgICAgaWYgKGdiLnJlYWRCb29sKCkpIHsgLy8gc2VxX3NjYWxpbmdfbWF0cml4X3ByZXNlbnRfZmxhZ1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxpbmdfbGlzdF9jb3VudCA9IChjaHJvbWFfZm9ybWF0X2lkYyAhPT0gMykgPyA4IDogMTI7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2FsaW5nX2xpc3RfY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2IucmVhZEJvb2woKSkgeyAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCA2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU1BTUGFyc2VyLl9za2lwU2NhbGluZ0xpc3QoZ2IsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU1BTUGFyc2VyLl9za2lwU2NhbGluZ0xpc3QoZ2IsIDY0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnYi5yZWFkVUVHKCk7IC8vIGxvZzJfbWF4X2ZyYW1lX251bV9taW51czRcbiAgICAgICAgY29uc3QgcGljX29yZGVyX2NudF90eXBlID0gZ2IucmVhZFVFRygpO1xuICAgICAgICBpZiAocGljX29yZGVyX2NudF90eXBlID09PSAwKSB7XG4gICAgICAgICAgICBnYi5yZWFkVUVHKCk7IC8vIGxvZzJfbWF4X3BpY19vcmRlcl9jbnRfbHNiX21pbnVzXzRcbiAgICAgICAgfSBlbHNlIGlmIChwaWNfb3JkZXJfY250X3R5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGdiLnJlYWRCaXRzKDEpOyAvLyBkZWx0YV9waWNfb3JkZXJfYWx3YXlzX3plcm9fZmxhZ1xuICAgICAgICAgICAgZ2IucmVhZFNFRygpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG4gICAgICAgICAgICBnYi5yZWFkU0VHKCk7IC8vIG9mZnNldF9mb3JfdG9wX3RvX2JvdHRvbV9maWVsZFxuICAgICAgICAgICAgY29uc3QgbnVtX3JlZl9mcmFtZXNfaW5fcGljX29yZGVyX2NudF9jeWNsZSA9IGdiLnJlYWRVRUcoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtX3JlZl9mcmFtZXNfaW5fcGljX29yZGVyX2NudF9jeWNsZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZ2IucmVhZFNFRygpOyAvLyBvZmZzZXRfZm9yX3JlZl9mcmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdiLnJlYWRVRUcoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXG4gICAgICAgIGdiLnJlYWRCaXRzKDEpOyAvLyBnYXBzX2luX2ZyYW1lX251bV92YWx1ZV9hbGxvd2VkX2ZsYWdcblxuICAgICAgICBjb25zdCBwaWNfd2lkdGhfaW5fbWJzX21pbnVzMSA9IGdiLnJlYWRVRUcoKTtcbiAgICAgICAgY29uc3QgcGljX2hlaWdodF9pbl9tYXBfdW5pdHNfbWludXMxID0gZ2IucmVhZFVFRygpO1xuXG4gICAgICAgIGNvbnN0IGZyYW1lX21ic19vbmx5X2ZsYWcgPSBnYi5yZWFkQml0cygxKTtcbiAgICAgICAgaWYgKGZyYW1lX21ic19vbmx5X2ZsYWcgPT09IDApIHtcbiAgICAgICAgICAgIGdiLnJlYWRCaXRzKDEpOyAvLyBtYl9hZGFwdGl2ZV9mcmFtZV9maWVsZF9mbGFnXG4gICAgICAgIH1cbiAgICAgICAgZ2IucmVhZEJpdHMoMSk7IC8vIGRpcmVjdF84eDhfaW5mZXJlbmNlX2ZsYWdcblxuICAgICAgICBsZXQgZnJhbWVfY3JvcF9sZWZ0X29mZnNldCA9IDA7XG4gICAgICAgIGxldCBmcmFtZV9jcm9wX3JpZ2h0X29mZnNldCA9IDA7XG4gICAgICAgIGxldCBmcmFtZV9jcm9wX3RvcF9vZmZzZXQgPSAwO1xuICAgICAgICBsZXQgZnJhbWVfY3JvcF9ib3R0b21fb2Zmc2V0ID0gMDtcblxuICAgICAgICBjb25zdCBmcmFtZV9jcm9wcGluZ19mbGFnID0gZ2IucmVhZEJvb2woKTtcbiAgICAgICAgaWYgKGZyYW1lX2Nyb3BwaW5nX2ZsYWcpIHtcbiAgICAgICAgICAgIGZyYW1lX2Nyb3BfbGVmdF9vZmZzZXQgPSBnYi5yZWFkVUVHKCk7XG4gICAgICAgICAgICBmcmFtZV9jcm9wX3JpZ2h0X29mZnNldCA9IGdiLnJlYWRVRUcoKTtcbiAgICAgICAgICAgIGZyYW1lX2Nyb3BfdG9wX29mZnNldCA9IGdiLnJlYWRVRUcoKTtcbiAgICAgICAgICAgIGZyYW1lX2Nyb3BfYm90dG9tX29mZnNldCA9IGdiLnJlYWRVRUcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzYXJfd2lkdGggPSAxLFxuICAgICAgICAgICAgc2FyX2hlaWdodCA9IDE7XG4gICAgICAgIGxldCBmcHMgPSAwLFxuICAgICAgICAgICAgZnBzX2ZpeGVkID0gdHJ1ZSxcbiAgICAgICAgICAgIGZwc19udW0gPSAwLFxuICAgICAgICAgICAgZnBzX2RlbiA9IDA7XG5cbiAgICAgICAgY29uc3QgdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnID0gZ2IucmVhZEJvb2woKTtcbiAgICAgICAgaWYgKHZ1aV9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZykge1xuICAgICAgICAgICAgaWYgKGdiLnJlYWRCb29sKCkpIHsgLy8gYXNwZWN0X3JhdGlvX2luZm9fcHJlc2VudF9mbGFnXG4gICAgICAgICAgICAgICAgY29uc3QgYXNwZWN0X3JhdGlvX2lkYyA9IGdiLnJlYWRCeXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FyX3dfdGFibGUgPSBbMSwgMTIsIDEwLCAxNiwgNDAsIDI0LCAyMCwgMzIsIDgwLCAxOCwgMTUsIDY0LCAxNjAsIDQsIDMsIDJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNhcl9oX3RhYmxlID0gWzEsIDExLCAxMSwgMTEsIDMzLCAxMSwgMTEsIDExLCAzMywgMTEsIDExLCAzMywgOTksIDMsIDIsIDFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFzcGVjdF9yYXRpb19pZGMgPiAwICYmIGFzcGVjdF9yYXRpb19pZGMgPCAxNikge1xuICAgICAgICAgICAgICAgICAgICBzYXJfd2lkdGggPSBzYXJfd190YWJsZVthc3BlY3RfcmF0aW9faWRjIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHNhcl9oZWlnaHQgPSBzYXJfaF90YWJsZVthc3BlY3RfcmF0aW9faWRjIC0gMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhc3BlY3RfcmF0aW9faWRjID09PSAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FyX3dpZHRoID0gZ2IucmVhZEJ5dGUoKSA8PCA4IHwgZ2IucmVhZEJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2FyX2hlaWdodCA9IGdiLnJlYWRCeXRlKCkgPDwgOCB8IGdiLnJlYWRCeXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ2IucmVhZEJvb2woKSkgeyAvLyBvdmVyc2Nhbl9pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICAgICAgICAgIGdiLnJlYWRCb29sKCk7IC8vIG92ZXJzY2FuX2FwcHJvcHJpYXRlX2ZsYWdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnYi5yZWFkQm9vbCgpKSB7IC8vIHZpZGVvX3NpZ25hbF90eXBlX3ByZXNlbnRfZmxhZ1xuICAgICAgICAgICAgICAgIGdiLnJlYWRCaXRzKDQpOyAvLyB2aWRlb19mb3JtYXQgJiB2aWRlb19mdWxsX3JhbmdlX2ZsYWdcbiAgICAgICAgICAgICAgICBpZiAoZ2IucmVhZEJvb2woKSkgeyAvLyBjb2xvdXJfZGVzY3JpcHRpb25fcHJlc2VudF9mbGFnXG4gICAgICAgICAgICAgICAgICAgIGdiLnJlYWRCaXRzKDI0KTsgLy8gY29sb3VyX3ByaW1hcmllcyAmIHRyYW5zZmVyX2NoYXJhY3RlcmlzdGljcyAmIG1hdHJpeF9jb2VmZmljaWVudHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2IucmVhZEJvb2woKSkgeyAvLyBjaHJvbWFfbG9jX2luZm9fcHJlc2VudF9mbGFnXG4gICAgICAgICAgICAgICAgZ2IucmVhZFVFRygpOyAvLyBjaHJvbWFfc2FtcGxlX2xvY190eXBlX3RvcF9maWVsZFxuICAgICAgICAgICAgICAgIGdiLnJlYWRVRUcoKTsgLy8gY2hyb21hX3NhbXBsZV9sb2NfdHlwZV9ib3R0b21fZmllbGRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnYi5yZWFkQm9vbCgpKSB7IC8vIHRpbWluZ19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bV91bml0c19pbl90aWNrID0gZ2IucmVhZEJpdHMoMzIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVfc2NhbGUgPSBnYi5yZWFkQml0cygzMik7XG4gICAgICAgICAgICAgICAgZnBzX2ZpeGVkID0gZ2IucmVhZEJvb2woKTsgLy8gZml4ZWRfZnJhbWVfcmF0ZV9mbGFnXG5cbiAgICAgICAgICAgICAgICBmcHNfbnVtID0gdGltZV9zY2FsZTtcbiAgICAgICAgICAgICAgICBmcHNfZGVuID0gbnVtX3VuaXRzX2luX3RpY2sgKiAyO1xuICAgICAgICAgICAgICAgIGZwcyA9IGZwc19udW0gLyBmcHNfZGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNhclNjYWxlID0gMTtcbiAgICAgICAgaWYgKHNhcl93aWR0aCAhPT0gMSB8fCBzYXJfaGVpZ2h0ICE9PSAxKSB7XG4gICAgICAgICAgICBzYXJTY2FsZSA9IHNhcl93aWR0aCAvIHNhcl9oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3JvcF91bml0X3ggPSAwLFxuICAgICAgICAgICAgY3JvcF91bml0X3kgPSAwO1xuICAgICAgICBpZiAoY2hyb21hX2Zvcm1hdF9pZGMgPT09IDApIHtcbiAgICAgICAgICAgIGNyb3BfdW5pdF94ID0gMTtcbiAgICAgICAgICAgIGNyb3BfdW5pdF95ID0gMiAtIGZyYW1lX21ic19vbmx5X2ZsYWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdWJfd2MgPSAoY2hyb21hX2Zvcm1hdF9pZGMgPT09IDMpID8gMSA6IDI7XG4gICAgICAgICAgICBjb25zdCBzdWJfaGMgPSAoY2hyb21hX2Zvcm1hdF9pZGMgPT09IDEpID8gMiA6IDE7XG4gICAgICAgICAgICBjcm9wX3VuaXRfeCA9IHN1Yl93YztcbiAgICAgICAgICAgIGNyb3BfdW5pdF95ID0gc3ViX2hjICogKDIgLSBmcmFtZV9tYnNfb25seV9mbGFnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2RlY193aWR0aCA9IChwaWNfd2lkdGhfaW5fbWJzX21pbnVzMSArIDEpICogMTY7XG4gICAgICAgIGxldCBjb2RlY19oZWlnaHQgPSAoMiAtIGZyYW1lX21ic19vbmx5X2ZsYWcpICogKChwaWNfaGVpZ2h0X2luX21hcF91bml0c19taW51czEgKyAxKSAqIDE2KTtcblxuICAgICAgICBjb2RlY193aWR0aCAtPSAoZnJhbWVfY3JvcF9sZWZ0X29mZnNldCArIGZyYW1lX2Nyb3BfcmlnaHRfb2Zmc2V0KSAqIGNyb3BfdW5pdF94O1xuICAgICAgICBjb2RlY19oZWlnaHQgLT0gKGZyYW1lX2Nyb3BfdG9wX29mZnNldCArIGZyYW1lX2Nyb3BfYm90dG9tX29mZnNldCkgKiBjcm9wX3VuaXRfeTtcblxuICAgICAgICBjb25zdCBwcmVzZW50X3dpZHRoID0gTWF0aC5jZWlsKGNvZGVjX3dpZHRoICogc2FyU2NhbGUpO1xuXG4gICAgICAgIGdiLmRlc3Ryb3koKTtcbiAgICAgICAgZ2IgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9maWxlX3N0cmluZywgLy8gYmFzZWxpbmUsIGhpZ2gsIGhpZ2gxMCwgLi4uXG4gICAgICAgICAgICBsZXZlbF9zdHJpbmcsIC8vIDMsIDMuMSwgNCwgNC4xLCA1LCA1LjEsIC4uLlxuICAgICAgICAgICAgYml0X2RlcHRoLCAvLyA4Yml0LCAxMGJpdCwgLi4uXG4gICAgICAgICAgICBjaHJvbWFfZm9ybWF0LCAvLyA0OjI6MCwgNDoyOjIsIC4uLlxuICAgICAgICAgICAgY2hyb21hX2Zvcm1hdF9zdHJpbmc6IFNQU1BhcnNlci5nZXRDaHJvbWFGb3JtYXRTdHJpbmcoY2hyb21hX2Zvcm1hdCksXG5cbiAgICAgICAgICAgIGZyYW1lX3JhdGU6IHtcbiAgICAgICAgICAgICAgICBmaXhlZDogZnBzX2ZpeGVkLFxuICAgICAgICAgICAgICAgIGZwcyxcbiAgICAgICAgICAgICAgICBmcHNfZGVuLFxuICAgICAgICAgICAgICAgIGZwc19udW1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNhcl9yYXRpbzoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBzYXJfd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzYXJfaGVpZ2h0XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjb2RlY19zaXplOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGNvZGVjX3dpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogY29kZWNfaGVpZ2h0XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwcmVzZW50X3NpemU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogcHJlc2VudF93aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGNvZGVjX2hlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyBfc2tpcFNjYWxpbmdMaXN0KGdiLCBjb3VudCkge1xuICAgICAgICBsZXQgbGFzdF9zY2FsZSA9IDgsXG4gICAgICAgICAgICBuZXh0X3NjYWxlID0gODtcbiAgICAgICAgbGV0IGRlbHRhX3NjYWxlID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobmV4dF9zY2FsZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbHRhX3NjYWxlID0gZ2IucmVhZFNFRygpO1xuICAgICAgICAgICAgICAgIG5leHRfc2NhbGUgPSAobGFzdF9zY2FsZSArIGRlbHRhX3NjYWxlICsgMjU2KSAlIDI1NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3Rfc2NhbGUgPSAobmV4dF9zY2FsZSA9PT0gMCkgPyBsYXN0X3NjYWxlIDogbmV4dF9zY2FsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRQcm9maWxlU3RyaW5nKHByb2ZpbGVfaWRjKSB7XG4gICAgICAgIHN3aXRjaCAocHJvZmlsZV9pZGMpIHtcbiAgICAgICAgICAgIGNhc2UgNjY6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdCYXNlbGluZSc7XG4gICAgICAgICAgICBjYXNlIDc3OlxuICAgICAgICAgICAgICAgIHJldHVybiAnTWFpbic7XG4gICAgICAgICAgICBjYXNlIDg4OlxuICAgICAgICAgICAgICAgIHJldHVybiAnRXh0ZW5kZWQnO1xuICAgICAgICAgICAgY2FzZSAxMDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdIaWdoJztcbiAgICAgICAgICAgIGNhc2UgMTEwOlxuICAgICAgICAgICAgICAgIHJldHVybiAnSGlnaDEwJztcbiAgICAgICAgICAgIGNhc2UgMTIyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnSGlnaDQyMic7XG4gICAgICAgICAgICBjYXNlIDI0NDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0hpZ2g0NDQnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldExldmVsU3RyaW5nKGxldmVsX2lkYykge1xuICAgICAgICByZXR1cm4gKGxldmVsX2lkYyAvIDEwKS50b0ZpeGVkKDEpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRDaHJvbWFGb3JtYXRTdHJpbmcoY2hyb21hKSB7XG4gICAgICAgIHN3aXRjaCAoY2hyb21hKSB7XG4gICAgICAgICAgICBjYXNlIDQyMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJzQ6MjowJztcbiAgICAgICAgICAgIGNhc2UgNDIyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnNDoyOjInO1xuICAgICAgICAgICAgY2FzZSA0NDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICc0OjQ6NCc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxlID0gKGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigyKTtcbiAgICAobmV3IERhdGFWaWV3KGJ1ZikpLnNldEludDE2KDAsIDI1NiwgdHJ1ZSk7IC8vIGxpdHRsZS1lbmRpYW4gd3JpdGVcbiAgICByZXR1cm4gKG5ldyBJbnQxNkFycmF5KGJ1ZikpWzBdID09PSAyNTY7IC8vIHBsYXRmb3JtLXNwZWMgcmVhZCwgaWYgZXF1YWwgdGhlbiBMRVxufSkoKTtcbmNsYXNzIGZsdkRlbXV4IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZU9iamVjdChhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCwgZGF0YVNpemUpIHtcblxuICAgICAgICBjb25zdCBuYW1lID0gZmx2RGVtdXgucGFyc2VTdHJpbmcoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBmbHZEZW11eC5wYXJzZVNjcmlwdChhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCArIG5hbWUuc2l6ZSk7XG4gICAgICAgIGNvbnN0IGlzT2JqZWN0RW5kID0gdmFsdWUub2JqZWN0RW5kO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZS5kYXRhLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5kYXRhXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2l6ZTogdmFsdWUuc2l6ZSxcbiAgICAgICAgICAgIG9iamVjdEVuZDogaXNPYmplY3RFbmRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2VWYXJpYWJsZShhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCwgZGF0YVNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZsdkRlbXV4LnBhcnNlT2JqZWN0KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0LCBkYXRhU2l6ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZUxvbmdTdHJpbmcoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKSB7XG5cbiAgICAgICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHYuZ2V0VWludDMyKDAsICFsZSk7XG5cbiAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN0ciA9IGRlY29kZVVURjgobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQgKyA0LCBsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHN0cixcbiAgICAgICAgICAgIHNpemU6IDQgKyBsZW5ndGhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlRGF0ZShhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCwgZGF0YVNpemUpIHtcblxuICAgICAgICBjb25zdCB2ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0KTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHYuZ2V0RmxvYXQ2NCgwLCAhbGUpO1xuICAgICAgICBjb25zdCBsb2NhbFRpbWVPZmZzZXQgPSB2LmdldEludDE2KDgsICFsZSk7XG4gICAgICAgIHRpbWVzdGFtcCArPSBsb2NhbFRpbWVPZmZzZXQgKiA2MCAqIDEwMDA7IC8vIGdldCBVVEMgdGltZVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBuZXcgRGF0ZSh0aW1lc3RhbXApLFxuICAgICAgICAgICAgc2l6ZTogOCArIDJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlU3RyaW5nKGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0LCBkYXRhU2l6ZSkge1xuICAgICAgICBjb25zdCB2ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdi5nZXRVaW50MTYoMCwgIWxlKTtcbiAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN0ciA9IGRlY29kZVVURjgobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQgKyAyLCBsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBzdHIsXG4gICAgICAgICAgICBzaXplOiAyICsgbGVuZ3RoXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6Kej5p6QbWV0YWRhdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VNZXRhZGF0YShhcnIpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZsdkRlbXV4LnBhcnNlU2NyaXB0KGFyciwgMCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZmx2RGVtdXgucGFyc2VTY3JpcHQoYXJyLCBuYW1lLnNpemUsIGFyci5sZW5ndGggLSBuYW1lLnNpemUpO1xuICAgICAgICAvLyByZXR1cm4ge31cbiAgICAgICAgY29uc3QgZGF0YSA9IHt9O1xuICAgICAgICBkYXRhW25hbWUuZGF0YV0gPSB2YWx1ZS5kYXRhO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2VTY3JpcHQoYXJyLCBvZmZzZXQsIGRhdGFTaXplKSB7XG4gICAgICAgIGxldCBkYXRhT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBjb25zdCBvYmplY3QgPSB7fTtcbiAgICAgICAgY29uc3QgdWludDggPSBuZXcgVWludDhBcnJheShhcnIpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OC5idWZmZXI7XG4gICAgICAgIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgMCwgZGF0YVNpemUpO1xuICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICBsZXQgb2JqZWN0RW5kID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoZHYuZ2V0VWludDgoZGF0YU9mZnNldCkpO1xuICAgICAgICBkYXRhT2Zmc2V0ICs9IDE7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDA6IC8vIE51bWJlcihEb3VibGUpIHR5cGVcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGR2LmdldEZsb2F0NjQoZGF0YU9mZnNldCwgIWxlKTtcbiAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgeyAvLyBCb29sZWFuIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IGR2LmdldFVpbnQ4KGRhdGFPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICEhYjtcbiAgICAgICAgICAgICAgICAgICAgZGF0YU9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgeyAvLyBTdHJpbmcgdHlwZVxuICAgICAgICAgICAgICAgICAgICAvLyBkYXRhT2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFtZnN0ciA9IGZsdkRlbXV4LnBhcnNlU3RyaW5nKGJ1ZmZlciwgZGF0YU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYW1mc3RyLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQgKz0gYW1mc3RyLnNpemU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMzpcblxuICAgICAgICAgICAgICAgIHsgLy8gT2JqZWN0KHMpIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlcm1pbmFsID0gMDsgLy8gd29ya2Fyb3VuZCBmb3IgbWFsZm9ybWVkIE9iamVjdHMgd2hpY2ggaGFzIG1pc3NpbmcgU2NyaXB0RGF0YU9iamVjdEVuZFxuICAgICAgICAgICAgICAgICAgICBpZiAoKGR2LmdldFVpbnQzMihkYXRhU2l6ZSAtIDQsICFsZSkgJiAweDAwRkZGRkZGKSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChkYXRhT2Zmc2V0IDwgZGF0YVNpemUgLSA0KSB7IC8vIDQgPT09IHR5cGUoVUk4KSArIFNjcmlwdERhdGFPYmplY3RFbmQoVUkyNClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFtZm9iaiA9IGZsdkRlbXV4LnBhcnNlT2JqZWN0KGJ1ZmZlciwgZGF0YU9mZnNldCwgZGF0YVNpemUgLSBvZmZzZXQgLSB0ZXJtaW5hbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbWZvYmoub2JqZWN0RW5kKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVthbWZvYmouZGF0YS5uYW1lXSA9IGFtZm9iai5kYXRhLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YU9mZnNldCArPSBhbWZvYmouc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQgPSBhbWZvYmouc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YU9mZnNldCA8PSBkYXRhU2l6ZSAtIDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IHYuZ2V0VWludDMyKGRhdGFPZmZzZXQgLSAxLCAhbGUpICYgMHgwMEZGRkZGRjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXJrZXIgPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHsgLy8gRUNNQSBhcnJheSB0eXBlIChNaXhlZCBhcnJheSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGF0YU9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0ICs9IDQ7IC8vIEVDTUFBcnJheUxlbmd0aChVSTMyKVxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVybWluYWwgPSAwOyAvLyB3b3JrYXJvdW5kIGZvciBtYWxmb3JtZWQgTWl4ZWRBcnJheXMgd2hpY2ggaGFzIG1pc3NpbmcgU2NyaXB0RGF0YU9iamVjdEVuZFxuICAgICAgICAgICAgICAgICAgICBpZiAoKGR2LmdldFVpbnQzMihkYXRhU2l6ZSAtIDQsICFsZSkgJiAweDAwRkZGRkZGKSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChkYXRhT2Zmc2V0IDwgZGF0YVNpemUgLSA4KSB7IC8vIDggPT09IHR5cGUoVUk4KSArIEVDTUFBcnJheUxlbmd0aChVSTMyKSArIFNjcmlwdERhdGFWYXJpYWJsZUVuZChVSTI0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYW1mdmFyID0gZmx2RGVtdXgucGFyc2VWYXJpYWJsZShidWZmZXIsIGRhdGFPZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW1mdmFyLm9iamVjdEVuZCkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbYW1mdmFyLmRhdGEubmFtZV0gPSBhbWZ2YXIuZGF0YS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQgPSBhbWZ2YXIuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YU9mZnNldCA8PSBkYXRhU2l6ZSAtIDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IGR2LmdldFVpbnQzMihkYXRhT2Zmc2V0IC0gMSwgIWxlKSAmIDB4MDBGRkZGRkY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFya2VyID09PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YU9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgOTogLy8gU2NyaXB0RGF0YU9iamVjdEVuZFxuICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQgPSAxO1xuICAgICAgICAgICAgICAgIG9iamVjdEVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIHsgLy8gU3RyaWN0IGFycmF5IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NyaXB0RGF0YVZhbHVlW25dLiBOT1RFOiBhY2NvcmRpbmcgdG8gdmlkZW9fZmlsZV9mb3JtYXRfc3BlY192MTBfMS5wZGZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaWN0QXJyYXlMZW5ndGggPSBkdi5nZXRVaW50MzIoZGF0YU9mZnNldCwgIWxlKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YU9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmljdEFycmF5TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGZsdkRlbXV4LnBhcnNlU2NyaXB0KGJ1ZmZlciwgZGF0YU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKHZhbC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQgPSB2YWwuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIHsgLy8gRGF0ZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBmbHZEZW11eC5wYXJzZURhdGUoYnVmZmVyLCBkYXRhT2Zmc2V0ICsgMSwgZGF0YVNpemUgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBkYXRlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQgKz0gZGF0ZS5zaXplO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIHsgLy8gTG9uZyBzdHJpbmcgdHlwZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbWZMb25nU3RyID0gZmx2RGVtdXgucGFyc2VTdHJpbmcoYnVmZmVyLCBkYXRhT2Zmc2V0ICsgMSwgZGF0YVNpemUgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhbWZMb25nU3RyLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQgKz0gYW1mTG9uZ1N0ci5zaXplO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBhbmQgc2tpcFxuICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQgPSBkYXRhU2l6ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQU1GJywgJ1Vuc3VwcG9ydGVkIEFNRiB2YWx1ZSB0eXBlICcgKyB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdmFsdWUsXG4gICAgICAgICAgICBzaXplOiBkYXRhT2Zmc2V0LFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLypcbiAqIENvcHlyaWdodCAoQykgMjAxNiBCaWxpYmlsaS4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBAYXV0aG9yIHpoZW5nIHFpYW4gPHhxcUB4cXEuaW0+XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY2xhc3MgTWVkaWFJbmZvIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1pbWVUeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5oYXNBdWRpbyA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzVmlkZW8gPSBudWxsO1xuICAgICAgICB0aGlzLmF1ZGlvQ29kZWMgPSBudWxsO1xuICAgICAgICB0aGlzLnZpZGVvQ29kZWMgPSBudWxsO1xuICAgICAgICB0aGlzLmF1ZGlvRGF0YVJhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnZpZGVvRGF0YVJhdGUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuYXVkaW9TYW1wbGVSYXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdWRpb0NoYW5uZWxDb3VudCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy53aWR0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mcHMgPSBudWxsO1xuICAgICAgICB0aGlzLnByb2ZpbGUgPSBudWxsO1xuICAgICAgICB0aGlzLmxldmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaHJvbWFGb3JtYXQgPSBudWxsO1xuICAgICAgICB0aGlzLnNhck51bSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FyRGVuID0gbnVsbDtcblxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZWdtZW50cyA9IG51bGw7IC8vIE1lZGlhSW5mb1tdXG4gICAgICAgIHRoaXMuc2VnbWVudENvdW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNLZXlmcmFtZXNJbmRleCA9IG51bGw7XG4gICAgICAgIHRoaXMua2V5ZnJhbWVzSW5kZXggPSBudWxsO1xuICAgIH1cblxuICAgIGlzQ29tcGxldGUoKSB7XG4gICAgICAgIGNvbnN0IGF1ZGlvSW5mb0NvbXBsZXRlID0gKHRoaXMuaGFzQXVkaW8gPT09IGZhbHNlKSB8fFxuICAgICAgICAgICAgKHRoaXMuaGFzQXVkaW8gPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvQ29kZWMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9TYW1wbGVSYXRlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvQ2hhbm5lbENvdW50ICE9IG51bGwpO1xuXG4gICAgICAgIGNvbnN0IHZpZGVvSW5mb0NvbXBsZXRlID0gKHRoaXMuaGFzVmlkZW8gPT09IGZhbHNlKSB8fFxuICAgICAgICAgICAgKHRoaXMuaGFzVmlkZW8gPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvQ29kZWMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmZwcyAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9maWxlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmxldmVsICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNocm9tYUZvcm1hdCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zYXJOdW0gIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2FyRGVuICE9IG51bGwpO1xuXG4gICAgICAgIC8vIGtleWZyYW1lc0luZGV4IG1heSBub3QgYmUgcHJlc2VudFxuICAgICAgICByZXR1cm4gdGhpcy5taW1lVHlwZSAhPSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uICE9IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdGhpcy5oYXNLZXlmcmFtZXNJbmRleCAhPSBudWxsICYmXG4gICAgICAgICAgICBhdWRpb0luZm9Db21wbGV0ZSAmJlxuICAgICAgICAgICAgdmlkZW9JbmZvQ29tcGxldGU7XG4gICAgfVxuXG4gICAgaXNTZWVrYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzS2V5ZnJhbWVzSW5kZXggPT09IHRydWU7XG4gICAgfVxufVxuXG5jbGFzcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IgKHR5cGUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5jbGFzcyB0YWdEZW11eCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuVEFHID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX29uRXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLl9vbk1lZGlhSW5mbyA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uVHJhY2tNZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uRGF0YUF2YWlsYWJsZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fZGF0YU9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuX2ZpcnN0UGFyc2UgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2hhc0F1ZGlvID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hhc1ZpZGVvID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fYXVkaW9Jbml0aWFsTWV0YWRhdGFEaXNwYXRjaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ZpZGVvSW5pdGlhbE1ldGFkYXRhRGlzcGF0Y2hlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX21lZGlhSW5mbyA9IG5ldyBNZWRpYUluZm8oKTtcbiAgICAgICAgdGhpcy5fbWVkaWFJbmZvLmhhc0F1ZGlvID0gdGhpcy5faGFzQXVkaW87XG4gICAgICAgIHRoaXMuX21lZGlhSW5mby5oYXNWaWRlbyA9IHRoaXMuX2hhc1ZpZGVvO1xuICAgICAgICB0aGlzLl9tZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2F1ZGlvTWV0YWRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLl92aWRlb01ldGFkYXRhID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9uYWx1TGVuZ3RoU2l6ZSA9IDQ7XG4gICAgICAgIHRoaXMuX3RpbWVzdGFtcEJhc2UgPSAwOyAvLyBpbnQzMiwgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgIHRoaXMuX3RpbWVzY2FsZSA9IDEwMDA7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gMDsgLy8gaW50MzIsIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICB0aGlzLl9kdXJhdGlvbk92ZXJyaWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZWZlcmVuY2VGcmFtZVJhdGUgPSB7XG4gICAgICAgICAgICBmaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgIGZwczogMjMuOTc2LFxuICAgICAgICAgICAgZnBzX251bTogMjM5NzYsXG4gICAgICAgICAgICBmcHNfZGVuOiAxMDAwXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fdmlkZW9UcmFjayA9IHsgdHlwZTogJ3ZpZGVvJywgaWQ6IDEsIHNlcXVlbmNlTnVtYmVyOiAwLCBhZGRjb2VmZmljaWVudDogMiwgc2FtcGxlczogW10sIGxlbmd0aDogMCB9O1xuICAgICAgICB0aGlzLl9hdWRpb1RyYWNrID0geyB0eXBlOiAnYXVkaW8nLCBpZDogMiwgc2VxdWVuY2VOdW1iZXI6IDAsIGFkZGNvZWZmaWNpZW50OiAyLCBzYW1wbGVzOiBbXSwgbGVuZ3RoOiAwIH07XG5cbiAgICAgICAgdGhpcy5fbGl0dGxlRW5kaWFuID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gbmV3IEFycmF5QnVmZmVyKDIpO1xuICAgICAgICAgICAgKG5ldyBEYXRhVmlldyhidWYpKS5zZXRJbnQxNigwLCAyNTYsIHRydWUpOyAvLyBsaXR0bGUtZW5kaWFuIHdyaXRlXG4gICAgICAgICAgICByZXR1cm4gKG5ldyBJbnQxNkFycmF5KGJ1ZikpWzBdID09PSAyNTY7IC8vIHBsYXRmb3JtLXNwZWMgcmVhZCwgaWYgZXF1YWwgdGhlbiBMRVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBzZXQgaGFzQXVkaW8ocyl7XG4gICAgICAgIHRoaXMuX21lZGlhSW5mby5oYXNBdWRpbyA9IHRoaXMuX2hhc0F1ZGlvPXM7XG4gICAgfVxuICAgIHNldCBoYXNWaWRlbyhzKXtcbiAgICAgICAgdGhpcy5fbWVkaWFJbmZvLmhhc1ZpZGVvID0gdGhpcy5faGFzVmlkZW89cztcbiAgICB9XG4gICAgb25NZWRpYUluZm8oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb25NZWRpYUluZm8gPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcGFyc2VNZXRhZGF0YShhcnIpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGZsdkRlbXV4LnBhcnNlTWV0YWRhdGEoYXJyKTtcbiAgICAgICAgdGhpcy5fcGFyc2VTY3JpcHREYXRhKGRhdGEpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLl9tZWRpYUluZm8sIHRoaXMuX21lZGlhSW5mby5pc0NvbXBsZXRlKCkpO1xuICAgIH1cbiAgICBfcGFyc2VTY3JpcHREYXRhKG9iaikge1xuICAgICAgICBjb25zdCBzY3JpcHREYXRhID0gb2JqO1xuXG4gICAgICAgIGlmIChzY3JpcHREYXRhLmhhc093blByb3BlcnR5KCdvbk1ldGFEYXRhJykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuVEFHLCAnRm91bmQgYW5vdGhlciBvbk1ldGFEYXRhIHRhZyEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhID0gc2NyaXB0RGF0YTtcbiAgICAgICAgICAgIGNvbnN0IG9uTWV0YURhdGEgPSB0aGlzLl9tZXRhZGF0YS5vbk1ldGFEYXRhO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uTWV0YURhdGEuaGFzQXVkaW8gPT09ICdib29sZWFuJykgeyAvLyBoYXNBdWRpb1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc0F1ZGlvID0gb25NZXRhRGF0YS5oYXNBdWRpbztcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYUluZm8uaGFzQXVkaW8gPSB0aGlzLl9oYXNBdWRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25NZXRhRGF0YS5oYXNWaWRlbyA9PT0gJ2Jvb2xlYW4nKSB7IC8vIGhhc1ZpZGVvXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVmlkZW8gPSBvbk1ldGFEYXRhLmhhc1ZpZGVvO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhSW5mby5oYXNWaWRlbyA9IHRoaXMuX2hhc1ZpZGVvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbk1ldGFEYXRhLmF1ZGlvZGF0YXJhdGUgPT09ICdudW1iZXInKSB7IC8vIGF1ZGlvZGF0YXJhdGVcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYUluZm8uYXVkaW9EYXRhUmF0ZSA9IG9uTWV0YURhdGEuYXVkaW9kYXRhcmF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25NZXRhRGF0YS52aWRlb2RhdGFyYXRlID09PSAnbnVtYmVyJykgeyAvLyB2aWRlb2RhdGFyYXRlXG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFJbmZvLnZpZGVvRGF0YVJhdGUgPSBvbk1ldGFEYXRhLnZpZGVvZGF0YXJhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uTWV0YURhdGEud2lkdGggPT09ICdudW1iZXInKSB7IC8vIHdpZHRoXG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFJbmZvLndpZHRoID0gb25NZXRhRGF0YS53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25NZXRhRGF0YS5oZWlnaHQgPT09ICdudW1iZXInKSB7IC8vIGhlaWdodFxuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhSW5mby5oZWlnaHQgPSBvbk1ldGFEYXRhLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25NZXRhRGF0YS5kdXJhdGlvbiA9PT0gJ251bWJlcicpIHsgLy8gZHVyYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2R1cmF0aW9uT3ZlcnJpZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gTWF0aC5mbG9vcihvbk1ldGFEYXRhLmR1cmF0aW9uICogdGhpcy5fdGltZXNjYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFJbmZvLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYUluZm8uZHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbk1ldGFEYXRhLmZyYW1lcmF0ZSA9PT0gJ251bWJlcicpIHsgLy8gZnJhbWVyYXRlXG4gICAgICAgICAgICAgICAgY29uc3QgZnBzX251bSA9IE1hdGguZmxvb3Iob25NZXRhRGF0YS5mcmFtZXJhdGUgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZnBzX251bSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnBzID0gZnBzX251bSAvIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZmVyZW5jZUZyYW1lUmF0ZS5maXhlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZmVyZW5jZUZyYW1lUmF0ZS5mcHMgPSBmcHM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZmVyZW5jZUZyYW1lUmF0ZS5mcHNfbnVtID0gZnBzX251bTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVmZXJlbmNlRnJhbWVSYXRlLmZwc19kZW4gPSAxMDAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYUluZm8uZnBzID0gZnBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25NZXRhRGF0YS5rZXlmcmFtZXMgPT09ICdvYmplY3QnKSB7IC8vIGtleWZyYW1lc1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhSW5mby5oYXNLZXlmcmFtZXNJbmRleCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ZnJhbWVzID0gb25NZXRhRGF0YS5rZXlmcmFtZXM7XG4gICAgICAgICAgICAgICAga2V5ZnJhbWVzLnRpbWVzID0gb25NZXRhRGF0YS50aW1lcztcbiAgICAgICAgICAgICAgICBrZXlmcmFtZXMuZmlsZXBvc2l0aW9ucyA9IG9uTWV0YURhdGEuZmlsZXBvc2l0aW9ucztcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYUluZm8ua2V5ZnJhbWVzSW5kZXggPSB0aGlzLl9wYXJzZUtleWZyYW1lc0luZGV4KGtleWZyYW1lcyk7XG4gICAgICAgICAgICAgICAgb25NZXRhRGF0YS5rZXlmcmFtZXMgPSBudWxsOyAvLyBrZXlmcmFtZXMgaGFzIGJlZW4gZXh0cmFjdGVkLCByZW1vdmUgaXRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFJbmZvLmhhc0tleWZyYW1lc0luZGV4ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFJbmZvLm1ldGFkYXRhID0gb25NZXRhRGF0YTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuVEFHLCAnUGFyc2VkIG9uTWV0YURhdGEnKTtcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLl9tZWRpYUluZm8uaXNDb21wbGV0ZSgpKSB7XG4gICAgICAgICAgICAvLyB0aGlzLl9vbk1lZGlhSW5mbyh0aGlzLl9tZWRpYUluZm8pO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhSW5mbztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9wYXJzZUtleWZyYW1lc0luZGV4KGtleWZyYW1lcykge1xuICAgICAgICBjb25zdCB0aW1lcyA9IFtdO1xuICAgICAgICBjb25zdCBmaWxlcG9zaXRpb25zID0gW107XG5cbiAgICAgICAgLy8gaWdub3JlIGZpcnN0IGtleWZyYW1lIHdoaWNoIGlzIGFjdHVhbGx5IEFWQyBTZXF1ZW5jZSBIZWFkZXIgKEFWQ0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkKVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGtleWZyYW1lcy50aW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGltZSA9IHRoaXMuX3RpbWVzdGFtcEJhc2UgKyBNYXRoLmZsb29yKGtleWZyYW1lcy50aW1lc1tpXSAqIDEwMDApO1xuICAgICAgICAgICAgdGltZXMucHVzaCh0aW1lKTtcbiAgICAgICAgICAgIGZpbGVwb3NpdGlvbnMucHVzaChrZXlmcmFtZXMuZmlsZXBvc2l0aW9uc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGltZXMsXG4gICAgICAgICAgICBmaWxlcG9zaXRpb25zXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Lyg5YWldGFnc+i+k+WHum1vb2blkoxtZGF0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gdGFnc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIHRhZ0RlbXV4XG4gICAgICovXG4gICAgbW9vZlRhZyh0YWdzKSB7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnBhcnNlQ2h1bmtzKHRhZ3NbaV0pO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJ0YWdUaW1lc3RhbXBcIiwgdGFnc1tpXS5nZXRUaW1lKCksIHRhZ3NbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc0luaXRpYWxNZXRhZGF0YURpc3BhdGNoZWQoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc3BhdGNoICYmICh0aGlzLl9hdWRpb1RyYWNrLmxlbmd0aCB8fCB0aGlzLl92aWRlb1RyYWNrLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRhdGFBdmFpbGFibGUodGhpcy5fYXVkaW9UcmFjaywgdGhpcy5fdmlkZW9UcmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZUNodW5rcyhmbHZ0YWcpIHtcblxuICAgICAgICBzd2l0Y2ggKGZsdnRhZy50YWdUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIDg6IC8vIEF1ZGlvXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBdWRpb0RhdGEoZmx2dGFnLmJvZHkuYnVmZmVyLCAwLCBmbHZ0YWcuYm9keS5sZW5ndGgsIGZsdnRhZy5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA5OiAvLyBWaWRlb1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlVmlkZW9EYXRhKGZsdnRhZy5ib2R5LmJ1ZmZlciwgMCwgZmx2dGFnLmJvZHkubGVuZ3RoLCBmbHZ0YWcuZ2V0VGltZSgpLCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTg6IC8vIFNjcmlwdERhdGFPYmplY3RcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlTWV0YWRhdGEoZmx2dGFnLmJvZHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3BhcnNlVmlkZW9EYXRhKGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0LCBkYXRhU2l6ZSwgdGFnVGltZXN0YW1wLCB0YWdQb3NpdGlvbikge1xuICAgICAgICBpZiAodGFnVGltZXN0YW1wID09IHRoaXMuX3RpbWVzdGFtcEJhc2UgJiYgdGhpcy5fdGltZXN0YW1wQmFzZSAhPSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGFnVGltZXN0YW1wLCB0aGlzLl90aW1lc3RhbXBCYXNlLCAn5aSt5a+/5ZWm6L+Z5Liq6KeG6aKR5LiN5piv5LuOMOW8gOWniycpO1xuICAgICAgICAgICAgLy8gdGhpcy50aW1lc3RhbXBCYXNlKDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhU2l6ZSA8PSAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLlRBRywgJ0ZsdjogSW52YWxpZCB2aWRlbyBwYWNrZXQsIG1pc3NpbmcgVmlkZW9EYXRhIHBheWxvYWQhJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8g6I635Y+WIHZpZGVvIHRhZyBib2R5IOesrOS4gOWtl+iKglxuICAgICAgICBjb25zdCBzcGVjID0gKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0LCBkYXRhU2l6ZSkpWzBdO1xuICAgICAgICAvLyDojrflj5bmmK/lkKbmmK/lhbPplK7luKdcbiAgICAgICAgY29uc3QgZnJhbWVUeXBlID0gKHNwZWMgJiAyNDApID4+PiA0O1xuICAgICAgICAvLyDojrflj5bnvJbnoIHmoLzlvI9cbiAgICAgICAgY29uc3QgY29kZWNJZCA9IHNwZWMgJiAxNTtcblxuICAgICAgICBpZiAoY29kZWNJZCAhPT0gNykge1xuICAgICAgICAgICAgaWYodGhpcy5fb25FcnJvcilcbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoYEZsdjogVW5zdXBwb3J0ZWQgY29kZWMgaW4gdmlkZW8gZnJhbWU6ICR7Y29kZWNJZH1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BhcnNlQVZDVmlkZW9QYWNrZXQoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQgKyAxLCBkYXRhU2l6ZSAtIDEsIHRhZ1RpbWVzdGFtcCwgdGFnUG9zaXRpb24sIGZyYW1lVHlwZSk7XG4gICAgfVxuXG4gICAgX3BhcnNlQVZDVmlkZW9QYWNrZXQoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplLCB0YWdUaW1lc3RhbXAsIHRhZ1Bvc2l0aW9uLCBmcmFtZVR5cGUpIHtcblxuICAgICAgICBpZiAoZGF0YVNpemUgPCA0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLlRBRywgJ0ZsdjogSW52YWxpZCBBVkMgcGFja2V0LCBtaXNzaW5nIEFWQ1BhY2tldFR5cGUgb3IvYW5kIENvbXBvc2l0aW9uVGltZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGUgPSB0aGlzLl9saXR0bGVFbmRpYW47XG4gICAgICAgIC8vIOiOt+WPliB2aWRlbyB0YWcgYm9keSDnrKwy5a2X6IqC5Yiw57uT5bC+XG4gICAgICAgIGNvbnN0IHYgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKTtcblxuICAgICAgICAvLyBJRiBDb2RlY0lEID09IDcgIEFWQ1BhY2tldFR5cGVcbiAgICAgICAgLy8gMCA9IEFWQyBzZXF1ZW5jZSBoZWFkZXJcbiAgICAgICAgLy8gMSA9IEFWQyBOQUxVXG4gICAgICAgIC8vIDIgPSBBVkMgZW5kIG9mIHNlcXVlbmNlIChsb3dlciBsZXZlbCBOQUxVIHNlcXVlbmNlIGVuZGVyIGlzIG5vdCByZXF1aXJlZCBvciBzdXBwb3J0ZWQpXG4gICAgICAgIGNvbnN0IHBhY2tldFR5cGUgPSB2LmdldFVpbnQ4KDApO1xuICAgICAgICAvLyAz5a2X6IqCXG4gICAgICAgIC8vIElGIEFWQ1BhY2tldFR5cGUgPT0gMVxuICAgICAgICAvLyAgQ29tcG9zaXRpb24gdGltZSBvZmZzZXRcbiAgICAgICAgLy8gRUxTRVxuICAgICAgICAvLyAgMFxuICAgICAgICBjb25zdCBjdHMgPSB2LmdldFVpbnQzMigwLCAhbGUpICYgMHgwMEZGRkZGRjtcblxuICAgICAgICAvLyBJRiBBVkNQYWNrZXRUeXBlID09IDAgQVZDRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmTvvIhBVkMgc2VxdWVuY2UgaGVhZGVy77yJXG4gICAgICAgIC8vIElGIEFWQ1BhY2tldFR5cGUgPT0gMSBPbmUgb3IgbW9yZSBOQUxVcyAoRnVsbCBmcmFtZXMgYXJlIHJlcXVpcmVkKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKkFWQ0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkLuWMheWQq+edgOaYr0guMjY06Kej56CB55u45YWz5q+U6L6D6YeN6KaB55qEc3Bz5ZKMcHBz5L+h5oGv77yMXG4gICAgICAgICAq5YaN57uZQVZD6Kej56CB5Zmo6YCB5pWw5o2uIOa1geS5i+WJjeS4gOWumuimgeaKinNwc+WSjHBwc+S/oeaBr+mAgeWHuu+8jOWQpuWImeeahOivneino+eggeWZqOS4jeiDveato+W4uOino+eggeOAglxuICAgICAgICAgKuiAjOS4lOWcqOino+eggeWZqHN0b3DkuYvlkI7lho3mrKFzdGFydOS5i+WJje+8jOWmgnNlZWvjgIHlv6vov5vlv6vpgIDnirbmgIHliIfmjaLnrYnvvIxcbiAgICAgICAgICrpg70g6ZyA6KaB6YeN5paw6YCB5LiA6YGNc3Bz5ZKMcHBz55qE5L+h5oGvLkFWQ0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3Jk5ZyoRkxW5paH5Lu25Lit5LiA6Iis5oOF5Ya15Lmf5piv5Ye6546wMeasoe+8jFxuICAgICAgICAgKuS5n+WwseaYr+esrOS4gOS4qiB2aWRlbyB0YWcuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocGFja2V0VHlwZSA9PT0gMCkgeyAvLyBBVkNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZFxuICAgICAgICAgICAgdGhpcy5fcGFyc2VBVkNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZChhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCArIDQsIGRhdGFTaXplIC0gNCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFja2V0VHlwZSA9PT0gMSkgeyAvLyBPbmUgb3IgbW9yZSBOYWx1c1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VBVkNWaWRlb0RhdGEoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQgKyA0LCBkYXRhU2l6ZSAtIDQsIHRhZ1RpbWVzdGFtcCwgdGFnUG9zaXRpb24sIGZyYW1lVHlwZSwgY3RzKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYWNrZXRUeXBlID09PSAyKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSwgQVZDIGVuZCBvZiBzZXF1ZW5jZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb25FcnJvcihgRmx2OiBJbnZhbGlkIHZpZGVvIHBhY2tldCB0eXBlICR7cGFja2V0VHlwZX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFWQyDliJ3lp4vljJZcbiAgICAgKi9cbiAgICBfcGFyc2VBVkNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZChhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCwgZGF0YVNpemUpIHtcbiAgICAgICAgaWYgKGRhdGFTaXplIDwgNykge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5UQUcsICdGbHY6IEludmFsaWQgQVZDRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmQsIGxhY2sgb2YgZGF0YSEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZXRhID0gdGhpcy5fdmlkZW9NZXRhZGF0YTtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLl92aWRlb1RyYWNrO1xuICAgICAgICBjb25zdCBsZSA9IHRoaXMuX2xpdHRsZUVuZGlhbjtcbiAgICAgICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCwgZGF0YVNpemUpO1xuXG4gICAgICAgIGlmICghbWV0YSkge1xuICAgICAgICAgICAgbWV0YSA9IHRoaXMuX3ZpZGVvTWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgIG1ldGEudHlwZSA9ICd2aWRlbyc7XG4gICAgICAgICAgICBtZXRhLmlkID0gdHJhY2suaWQ7XG4gICAgICAgICAgICBtZXRhLnRpbWVzY2FsZSA9IHRoaXMuX3RpbWVzY2FsZTtcbiAgICAgICAgICAgIG1ldGEuZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0YS5hdmNjICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuVEFHLCAnRm91bmQgYW5vdGhlciBBVkNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZCEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSB2LmdldFVpbnQ4KDApOyAvLyBjb25maWd1cmF0aW9uVmVyc2lvblxuICAgICAgICBjb25zdCBhdmNQcm9maWxlID0gdi5nZXRVaW50OCgxKTsgLy8gYXZjUHJvZmlsZUluZGljYXRpb25cbiAgICAgICAgY29uc3QgcHJvZmlsZUNvbXBhdGliaWxpdHkgPSB2LmdldFVpbnQ4KDIpOyAvLyBwcm9maWxlX2NvbXBhdGliaWxpdHlcbiAgICAgICAgY29uc3QgYXZjTGV2ZWwgPSB2LmdldFVpbnQ4KDMpOyAvLyBBVkNMZXZlbEluZGljYXRpb25cblxuICAgICAgICBpZiAodmVyc2lvbiAhPT0gMSB8fCBhdmNQcm9maWxlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKERlbXV4RXJyb3JzLkZPUk1BVF9FUlJPUiwgJ0ZsdjogSW52YWxpZCBBVkNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbmFsdUxlbmd0aFNpemUgPSAodi5nZXRVaW50OCg0KSAmIDMpICsgMTsgLy8gbGVuZ3RoU2l6ZU1pbnVzT25lXG4gICAgICAgIGlmICh0aGlzLl9uYWx1TGVuZ3RoU2l6ZSAhPT0gMyAmJiB0aGlzLl9uYWx1TGVuZ3RoU2l6ZSAhPT0gNCkgeyAvLyBob2x5IHNoaXQhISFcbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoRGVtdXhFcnJvcnMuRk9STUFUX0VSUk9SLCBgRmx2OiBTdHJhbmdlIE5hbHVMZW5ndGhTaXplTWludXNPbmU6ICR7dGhpcy5fbmFsdUxlbmd0aFNpemUgLSAxfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3BzQ291bnQgPSB2LmdldFVpbnQ4KDUpICYgMzE7IC8vIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXG4gICAgICAgIGlmIChzcHNDb3VudCA9PT0gMCB8fCBzcHNDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoRGVtdXhFcnJvcnMuRk9STUFUX0VSUk9SLCBgRmx2OiBJbnZhbGlkIEgyNjQgU1BTIGNvdW50OiAke3Nwc0NvdW50fWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9mZnNldCA9IDY7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcHNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSB2LmdldFVpbnQxNihvZmZzZXQsICFsZSk7IC8vIHNlcXVlbmNlUGFyYW1ldGVyU2V0TGVuZ3RoXG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcblxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3RpY2U6IE5hbHUgd2l0aG91dCBzdGFydGNvZGUgaGVhZGVyICgwMCAwMCAwMCAwMSlcbiAgICAgICAgICAgIGNvbnN0IHNwcyA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0ICsgb2Zmc2V0LCBsZW4pO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGxlbjtcblxuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gU1BTUGFyc2VyLnBhcnNlU1BTKHNwcyk7XG4gICAgICAgICAgICBtZXRhLmNvZGVjV2lkdGggPSBjb25maWcuY29kZWNfc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIG1ldGEuY29kZWNIZWlnaHQgPSBjb25maWcuY29kZWNfc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICBtZXRhLnByZXNlbnRXaWR0aCA9IGNvbmZpZy5wcmVzZW50X3NpemUud2lkdGg7XG4gICAgICAgICAgICBtZXRhLnByZXNlbnRIZWlnaHQgPSBjb25maWcucHJlc2VudF9zaXplLmhlaWdodDtcbiAgICAgICAgICAgIG1ldGEuY29uZmlnPWNvbmZpZztcbiAgICAgICAgICAgIG1ldGEucHJvZmlsZSA9IGNvbmZpZy5wcm9maWxlX3N0cmluZztcbiAgICAgICAgICAgIG1ldGEubGV2ZWwgPSBjb25maWcubGV2ZWxfc3RyaW5nO1xuICAgICAgICAgICAgbWV0YS5iaXREZXB0aCA9IGNvbmZpZy5iaXRfZGVwdGg7XG4gICAgICAgICAgICBtZXRhLmNocm9tYUZvcm1hdCA9IGNvbmZpZy5jaHJvbWFfZm9ybWF0O1xuICAgICAgICAgICAgbWV0YS5zYXJSYXRpbyA9IGNvbmZpZy5zYXJfcmF0aW87XG4gICAgICAgICAgICBtZXRhLmZyYW1lUmF0ZSA9IGNvbmZpZy5mcmFtZV9yYXRlO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLmZyYW1lX3JhdGUuZml4ZWQgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgY29uZmlnLmZyYW1lX3JhdGUuZnBzX251bSA9PT0gMCB8fFxuICAgICAgICAgICAgICAgIGNvbmZpZy5mcmFtZV9yYXRlLmZwc19kZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICBtZXRhLmZyYW1lUmF0ZSA9IHRoaXMuX3JlZmVyZW5jZUZyYW1lUmF0ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZnBzX2RlbiA9IG1ldGEuZnJhbWVSYXRlLmZwc19kZW47XG4gICAgICAgICAgICBjb25zdCBmcHNfbnVtID0gbWV0YS5mcmFtZVJhdGUuZnBzX251bTtcbiAgICAgICAgICAgIG1ldGEucmVmU2FtcGxlRHVyYXRpb24gPSBNYXRoLmZsb29yKG1ldGEudGltZXNjYWxlICogKGZwc19kZW4gLyBmcHNfbnVtKSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNvZGVjQXJyYXkgPSBzcHMuc3ViYXJyYXkoMSwgNCk7XG4gICAgICAgICAgICBsZXQgY29kZWNTdHJpbmcgPSAnYXZjMS4nO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaCA9IGNvZGVjQXJyYXlbal0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGVjU3RyaW5nICs9IGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRhLmNvZGVjID0gY29kZWNTdHJpbmc7XG5cbiAgICAgICAgICAgIGNvbnN0IG1pID0gdGhpcy5fbWVkaWFJbmZvO1xuICAgICAgICAgICAgbWkud2lkdGggPSBtZXRhLmNvZGVjV2lkdGg7XG4gICAgICAgICAgICBtaS5oZWlnaHQgPSBtZXRhLmNvZGVjSGVpZ2h0O1xuICAgICAgICAgICAgbWkuZnBzID0gbWV0YS5mcmFtZVJhdGUuZnBzO1xuICAgICAgICAgICAgbWkucHJvZmlsZSA9IG1ldGEucHJvZmlsZTtcbiAgICAgICAgICAgIG1pLmxldmVsID0gbWV0YS5sZXZlbDtcbiAgICAgICAgICAgIG1pLmNocm9tYUZvcm1hdCA9IGNvbmZpZy5jaHJvbWFfZm9ybWF0X3N0cmluZztcbiAgICAgICAgICAgIG1pLnNhck51bSA9IG1ldGEuc2FyUmF0aW8ud2lkdGg7XG4gICAgICAgICAgICBtaS5zYXJEZW4gPSBtZXRhLnNhclJhdGlvLmhlaWdodDtcbiAgICAgICAgICAgIG1pLnZpZGVvQ29kZWMgPSBjb2RlY1N0cmluZztcbiAgICAgICAgICAgIG1pLm1ldGE9bWV0YTtcbiAgICAgICAgICAgIGlmIChtaS5oYXNBdWRpbykge1xuICAgICAgICAgICAgICAgIGlmIChtaS5hdWRpb0NvZGVjICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbWkubWltZVR5cGUgPSAndmlkZW8veC1mbHY7IGNvZGVjcz1cIicgKyBtaS52aWRlb0NvZGVjICsgJywnICsgbWkuYXVkaW9Db2RlYyArICdcIic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaS5taW1lVHlwZSA9ICd2aWRlby94LWZsdjsgY29kZWNzPVwiJyArIG1pLnZpZGVvQ29kZWMgKyAnXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1pLmlzQ29tcGxldGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uTWVkaWFJbmZvKG1pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBwc0NvdW50ID0gdi5nZXRVaW50OChvZmZzZXQpOyAvLyBudW1PZlBpY3R1cmVQYXJhbWV0ZXJTZXRzXG4gICAgICAgIGlmIChwcHNDb3VudCA9PT0gMCB8fCBwcHNDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoRGVtdXhFcnJvcnMuRk9STUFUX0VSUk9SLCBgRmx2OiBJbnZhbGlkIEgyNjQgUFBTIGNvdW50OiAke3Bwc0NvdW50fWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0Kys7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcHNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSB2LmdldFVpbnQxNihvZmZzZXQsICFsZSk7IC8vIHBpY3R1cmVQYXJhbWV0ZXJTZXRMZW5ndGhcbiAgICAgICAgICAgIG9mZnNldCArPSAyO1xuXG4gICAgICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHBwcyBpcyB1c2VsZXNzIGZvciBleHRyYWN0aW5nIHZpZGVvIGluZm9ybWF0aW9uXG4gICAgICAgICAgICBvZmZzZXQgKz0gbGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgbWV0YS5hdmNjID0gbmV3IFVpbnQ4QXJyYXkoZGF0YVNpemUpO1xuICAgICAgICBtZXRhLmF2Y2Muc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0LCBkYXRhU2l6ZSksIDApO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLlRBRywgJ1BhcnNlZCBBVkNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZCcpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc0luaXRpYWxNZXRhZGF0YURpc3BhdGNoZWQoKSkge1xuICAgICAgICAgICAgLy8gZmx1c2ggcGFyc2VkIGZyYW1lc1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc3BhdGNoICYmICh0aGlzLl9hdWRpb1RyYWNrLmxlbmd0aCB8fCB0aGlzLl92aWRlb1RyYWNrLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRhdGFBdmFpbGFibGUodGhpcy5fYXVkaW9UcmFjaywgdGhpcy5fdmlkZW9UcmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92aWRlb0luaXRpYWxNZXRhZGF0YURpc3BhdGNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdGlmeSBuZXcgbWV0YWRhdGFcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2ggPSBmYWxzZTtcbiAgICAgICAgLy8gaWYgKHRoaXMuX29uVHJhY2tNZXRhZGF0YSkge1xuICAgICAgICAvLyAgICAgdGhpcy5fb25UcmFja01ldGFkYXRhLmNhbGwobnVsbCwgbWV0YSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICB0aGlzLl9vblRyYWNrTWV0YWRhdGEoJ3ZpZGVvJywgbWV0YSk7XG4gICAgfVxuICAgIFxuICAgIHRpbWVzdGFtcEJhc2UoaSkge1xuICAgICAgICB0aGlzLl90aW1lc3RhbXBCYXNlID0gaTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmma7pgJrnmoRBVkMg54mH5q61XG4gICAgICovXG4gICAgX3BhcnNlQVZDVmlkZW9EYXRhKGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0LCBkYXRhU2l6ZSwgdGFnVGltZXN0YW1wLCB0YWdQb3NpdGlvbiwgZnJhbWVUeXBlLCBjdHMpIHtcblxuICAgICAgICBjb25zdCBsZSA9IHRoaXMuX2xpdHRsZUVuZGlhbjtcbiAgICAgICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCwgZGF0YVNpemUpO1xuXG4gICAgICAgIGxldCB1bml0cyA9IFtdLFxuICAgICAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QgbGVuZ3RoU2l6ZSA9IHRoaXMuX25hbHVMZW5ndGhTaXplO1xuICAgICAgICBjb25zdCBkdHMgPSB0aGlzLl90aW1lc3RhbXBCYXNlICsgdGFnVGltZXN0YW1wO1xuICAgICAgICBsZXQga2V5ZnJhbWUgPSAoZnJhbWVUeXBlID09PSAxKTsgLy8gZnJvbSBGTFYgRnJhbWUgVHlwZSBjb25zdGFudHNcblxuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgZGF0YVNpemUpIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgKyA0ID49IGRhdGFTaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5UQUcsIGBNYWxmb3JtZWQgTmFsdSBuZWFyIHRpbWVzdGFtcCAke2R0c30sIG9mZnNldCA9ICR7b2Zmc2V0fSwgZGF0YVNpemUgPSAke2RhdGFTaXplfWApO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBkYXRhIG5vdCBlbm91Z2ggZm9yIG5leHQgTmFsdVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTmFsdSB3aXRoIGxlbmd0aC1oZWFkZXIgKEFWQzEpXG4gICAgICAgICAgICBsZXQgbmFsdVNpemUgPSB2LmdldFVpbnQzMihvZmZzZXQsICFsZSk7IC8vIEJpZy1FbmRpYW4gcmVhZFxuICAgICAgICAgICAgaWYgKGxlbmd0aFNpemUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBuYWx1U2l6ZSA+Pj49IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFsdVNpemUgPiBkYXRhU2l6ZSAtIGxlbmd0aFNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLlRBRywgYE1hbGZvcm1lZCBOYWx1cyBuZWFyIHRpbWVzdGFtcCAke2R0c30sIE5hbHVTaXplID4gRGF0YVNpemUhYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB1bml0VHlwZSA9IHYuZ2V0VWludDgob2Zmc2V0ICsgbGVuZ3RoU2l6ZSkgJiAweDFGO1xuXG4gICAgICAgICAgICBpZiAodW5pdFR5cGUgPT09IDUpIHsgLy8gSURSXG4gICAgICAgICAgICAgICAga2V5ZnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQgKyBvZmZzZXQsIGxlbmd0aFNpemUgKyBuYWx1U2l6ZSk7XG4gICAgICAgICAgICBjb25zdCB1bml0ID0geyB0eXBlOiB1bml0VHlwZSwgZGF0YSB9O1xuICAgICAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBkYXRhLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgICAgIG9mZnNldCArPSBsZW5ndGhTaXplICsgbmFsdVNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodW5pdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMuX3ZpZGVvVHJhY2s7XG4gICAgICAgICAgICBjb25zdCBhdmNTYW1wbGUgPSB7XG4gICAgICAgICAgICAgICAgdW5pdHMsXG4gICAgICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgICAgIGlzS2V5ZnJhbWU6IGtleWZyYW1lLFxuICAgICAgICAgICAgICAgIGR0cyxcbiAgICAgICAgICAgICAgICBjdHMsXG4gICAgICAgICAgICAgICAgcHRzOiAoZHRzICsgY3RzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChrZXlmcmFtZSkge1xuICAgICAgICAgICAgICAgIGF2Y1NhbXBsZS5maWxlcG9zaXRpb24gPSB0YWdQb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChhdmNTYW1wbGUpO1xuICAgICAgICAgICAgdHJhY2subGVuZ3RoICs9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcGFyc2VBdWRpb0RhdGEoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplLCB0YWdUaW1lc3RhbXApIHtcbiAgICAgICAgaWYgKHRhZ1RpbWVzdGFtcCA9PSB0aGlzLl90aW1lc3RhbXBCYXNlICYmIHRoaXMuX3RpbWVzdGFtcEJhc2UgIT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGFnVGltZXN0YW1wLCB0aGlzLl90aW1lc3RhbXBCYXNlLCAn5aSt5a+/5ZWm6L+Z5Liq6KeG6aKR5LiN5piv5LuOMOW8gOWniycpO1xuICAgICAgICAgICAgLy8gdGltZXN0YW1wQmFzZSgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhU2l6ZSA8PSAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLlRBRywgJ0ZsdjogSW52YWxpZCBhdWRpbyBwYWNrZXQsIG1pc3NpbmcgU291bmREYXRhIHBheWxvYWQhJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWV0YSA9IHRoaXMuX2F1ZGlvTWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy5fYXVkaW9UcmFjaztcblxuICAgICAgICBpZiAoIW1ldGEgfHwgIW1ldGEuY29kZWMpIHtcbiAgICAgICAgICAgIC8vIGluaXRpYWwgbWV0YWRhdGFcbiAgICAgICAgICAgIG1ldGEgPSB0aGlzLl9hdWRpb01ldGFkYXRhID0ge307XG4gICAgICAgICAgICBtZXRhLnR5cGUgPSAnYXVkaW8nO1xuICAgICAgICAgICAgbWV0YS5pZCA9IHRyYWNrLmlkO1xuICAgICAgICAgICAgbWV0YS50aW1lc2NhbGUgPSB0aGlzLl90aW1lc2NhbGU7XG4gICAgICAgICAgICBtZXRhLmR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG5cbiAgICAgICAgICAgIGNvbnN0IGxlID0gdGhpcy5fbGl0dGxlRW5kaWFuO1xuICAgICAgICAgICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCwgZGF0YVNpemUpO1xuXG4gICAgICAgICAgICBjb25zdCBzb3VuZFNwZWMgPSB2LmdldFVpbnQ4KDApO1xuXG4gICAgICAgICAgICBjb25zdCBzb3VuZEZvcm1hdCA9IHNvdW5kU3BlYyA+Pj4gNDtcbiAgICAgICAgICAgIGlmIChzb3VuZEZvcm1hdCAhPT0gMTApIHsgLy8gQUFDXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBNUDMgYXVkaW8gY29kZWNcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkVycm9yKERlbXV4RXJyb3JzLkNPREVDX1VOU1VQUE9SVEVELCAnRmx2OiBVbnN1cHBvcnRlZCBhdWRpbyBjb2RlYyBpZHg6ICcgKyBzb3VuZEZvcm1hdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc291bmRSYXRlID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNvdW5kUmF0ZUluZGV4ID0gKHNvdW5kU3BlYyAmIDEyKSA+Pj4gMjtcblxuICAgICAgICAgICAgY29uc3Qgc291bmRSYXRlVGFibGUgPSBbNTUwMCwgMTEwMjUsIDIyMDUwLCA0NDEwMCwgNDgwMDBdO1xuXG4gICAgICAgICAgICBpZiAoc291bmRSYXRlSW5kZXggPCBzb3VuZFJhdGVUYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzb3VuZFJhdGUgPSBzb3VuZFJhdGVUYWJsZVtzb3VuZFJhdGVJbmRleF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoRGVtdXhFcnJvcnMuRk9STUFUX0VSUk9SLCAnRmx2OiBJbnZhbGlkIGF1ZGlvIHNhbXBsZSByYXRlIGlkeDogJyArIHNvdW5kUmF0ZUluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNvdW5kU2l6ZSA9IChzb3VuZFNwZWMgJiAyKSA+Pj4gMTsgLy8gdW51c2VkXG4gICAgICAgICAgICBjb25zdCBzb3VuZFR5cGUgPSAoc291bmRTcGVjICYgMSk7XG5cbiAgICAgICAgICAgIG1ldGEuYXVkaW9TYW1wbGVSYXRlID0gc291bmRSYXRlO1xuICAgICAgICAgICAgbWV0YS5jaGFubmVsQ291bnQgPSAoc291bmRUeXBlID09PSAwID8gMSA6IDIpO1xuICAgICAgICAgICAgbWV0YS5yZWZTYW1wbGVEdXJhdGlvbiA9IE1hdGguZmxvb3IoMTAyNCAvIG1ldGEuYXVkaW9TYW1wbGVSYXRlICogbWV0YS50aW1lc2NhbGUpO1xuICAgICAgICAgICAgbWV0YS5jb2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWFjRGF0YSA9IHRoaXMuX3BhcnNlQUFDQXVkaW9EYXRhKGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0ICsgMSwgZGF0YVNpemUgLSAxKTtcbiAgICAgICAgaWYgKGFhY0RhdGEgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFjRGF0YS5wYWNrZXRUeXBlID09PSAwKSB7IC8vIEFBQyBzZXF1ZW5jZSBoZWFkZXIgKEF1ZGlvU3BlY2lmaWNDb25maWcpXG4gICAgICAgICAgICBpZiAobWV0YS5jb25maWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLlRBRywgJ0ZvdW5kIGFub3RoZXIgQXVkaW9TcGVjaWZpY0NvbmZpZyEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1pc2MgPSBhYWNEYXRhLmRhdGE7XG4gICAgICAgICAgICBtZXRhLmF1ZGlvU2FtcGxlUmF0ZSA9IG1pc2Muc2FtcGxpbmdSYXRlO1xuICAgICAgICAgICAgbWV0YS5jaGFubmVsQ291bnQgPSBtaXNjLmNoYW5uZWxDb3VudDtcbiAgICAgICAgICAgIG1ldGEuY29kZWMgPSBtaXNjLmNvZGVjO1xuICAgICAgICAgICAgbWV0YS5jb25maWcgPSBtaXNjLmNvbmZpZztcbiAgICAgICAgICAgIC8vIFRoZSBkZWNvZGUgcmVzdWx0IG9mIGFuIGFhYyBzYW1wbGUgaXMgMTAyNCBQQ00gc2FtcGxlc1xuICAgICAgICAgICAgbWV0YS5yZWZTYW1wbGVEdXJhdGlvbiA9IE1hdGguZmxvb3IoMTAyNCAvIG1ldGEuYXVkaW9TYW1wbGVSYXRlICogbWV0YS50aW1lc2NhbGUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5UQUcsICdQYXJzZWQgQXVkaW9TcGVjaWZpY0NvbmZpZycpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5faXNJbml0aWFsTWV0YWRhdGFEaXNwYXRjaGVkKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBOb24taW5pdGlhbCBtZXRhZGF0YSwgZm9yY2UgZGlzcGF0Y2ggKG9yIGZsdXNoKSBwYXJzZWQgZnJhbWVzIHRvIHJlbXV4ZXJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGlzcGF0Y2ggJiYgKHRoaXMuX2F1ZGlvVHJhY2subGVuZ3RoIHx8IHRoaXMuX3ZpZGVvVHJhY2subGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkRhdGFBdmFpbGFibGUodGhpcy5fYXVkaW9UcmFjaywgdGhpcy5fdmlkZW9UcmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb0luaXRpYWxNZXRhZGF0YURpc3BhdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlbiBub3RpZnkgbmV3IG1ldGFkYXRhXG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fb25UcmFja01ldGFkYXRhKCdhdWRpbycsIG1ldGEpO1xuXG4gICAgICAgICAgICBjb25zdCBtaSA9IHRoaXMuX21lZGlhSW5mbztcbiAgICAgICAgICAgIG1pLmF1ZGlvQ29kZWMgPSAnbXA0YS40MC4nICsgbWlzYy5vcmlnaW5hbEF1ZGlvT2JqZWN0VHlwZTtcbiAgICAgICAgICAgIG1pLmF1ZGlvU2FtcGxlUmF0ZSA9IG1ldGEuYXVkaW9TYW1wbGVSYXRlO1xuICAgICAgICAgICAgbWkuYXVkaW9DaGFubmVsQ291bnQgPSBtZXRhLmNoYW5uZWxDb3VudDtcbiAgICAgICAgICAgIGlmIChtaS5oYXNWaWRlbykge1xuICAgICAgICAgICAgICAgIGlmIChtaS52aWRlb0NvZGVjICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbWkubWltZVR5cGUgPSAndmlkZW8veC1mbHY7IGNvZGVjcz1cIicgKyBtaS52aWRlb0NvZGVjICsgJywnICsgbWkuYXVkaW9Db2RlYyArICdcIic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaS5taW1lVHlwZSA9ICd2aWRlby94LWZsdjsgY29kZWNzPVwiJyArIG1pLmF1ZGlvQ29kZWMgKyAnXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1pLmlzQ29tcGxldGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uTWVkaWFJbmZvKG1pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChhYWNEYXRhLnBhY2tldFR5cGUgPT09IDEpIHsgLy8gQUFDIHJhdyBmcmFtZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBkdHMgPSB0aGlzLl90aW1lc3RhbXBCYXNlICsgdGFnVGltZXN0YW1wO1xuICAgICAgICAgICAgY29uc3QgYWFjU2FtcGxlID0geyB1bml0OiBhYWNEYXRhLmRhdGEsIGR0cywgcHRzOiBkdHMgfTtcbiAgICAgICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNTYW1wbGUpO1xuICAgICAgICAgICAgdHJhY2subGVuZ3RoICs9IGFhY0RhdGEuZGF0YS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLlRBRywgYEZsdjogVW5zdXBwb3J0ZWQgQUFDIGRhdGEgdHlwZSAke2FhY0RhdGEucGFja2V0VHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9wYXJzZUFBQ0F1ZGlvRGF0YShhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCwgZGF0YVNpemUpIHtcbiAgICAgICAgaWYgKGRhdGFTaXplIDw9IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuVEFHLCAnRmx2OiBJbnZhbGlkIEFBQyBwYWNrZXQsIG1pc3NpbmcgQUFDUGFja2V0VHlwZSBvci9hbmQgRGF0YSEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0LCBkYXRhU2l6ZSk7XG5cbiAgICAgICAgcmVzdWx0LnBhY2tldFR5cGUgPSBhcnJheVswXTtcblxuICAgICAgICBpZiAoYXJyYXlbMF0gPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gdGhpcy5fcGFyc2VBQUNBdWRpb1NwZWNpZmljQ29uZmlnKGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0ICsgMSwgZGF0YVNpemUgLSAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gYXJyYXkuc3ViYXJyYXkoMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIF9wYXJzZUFBQ0F1ZGlvU3BlY2lmaWNDb25maWcoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKTtcbiAgICAgICAgbGV0IGNvbmZpZyA9IG51bGw7XG5cbiAgICAgICAgY29uc3QgbXBlZ1NhbXBsaW5nUmF0ZXMgPSBbXG4gICAgICAgICAgICA5NjAwMCwgODgyMDAsIDY0MDAwLCA0ODAwMCwgNDQxMDAsIDMyMDAwLFxuICAgICAgICAgICAgMjQwMDAsIDIyMDUwLCAxNjAwMCwgMTIwMDAsIDExMDI1LCA4MDAwLCA3MzUwXG4gICAgICAgIF07XG5cbiAgICAgICAgLyogQXVkaW8gT2JqZWN0IFR5cGU6XG4gICAgICAgICAgIDA6IE51bGxcbiAgICAgICAgICAgMTogQUFDIE1haW5cbiAgICAgICAgICAgMjogQUFDIExDXG4gICAgICAgICAgIDM6IEFBQyBTU1IgKFNjYWxhYmxlIFNhbXBsZSBSYXRlKVxuICAgICAgICAgICA0OiBBQUMgTFRQIChMb25nIFRlcm0gUHJlZGljdGlvbilcbiAgICAgICAgICAgNTogSEUtQUFDIC8gU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKVxuICAgICAgICAgICA2OiBBQUMgU2NhbGFibGVcbiAgICAgICAgKi9cblxuICAgICAgICBsZXQgYXVkaW9PYmplY3RUeXBlID0gMDtcbiAgICAgICAgbGV0IG9yaWdpbmFsQXVkaW9PYmplY3RUeXBlID0gMDtcbiAgICAgICAgbGV0IGF1ZGlvRXh0ZW5zaW9uT2JqZWN0VHlwZSA9IG51bGw7XG4gICAgICAgIGxldCBzYW1wbGluZ0luZGV4ID0gMDtcbiAgICAgICAgbGV0IGV4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBudWxsO1xuICAgICAgICAvLyBkZWJ1Z2dlcjtcbiAgICAgICAgLy8gNSBiaXRzXG4gICAgICAgIGF1ZGlvT2JqZWN0VHlwZSA9IG9yaWdpbmFsQXVkaW9PYmplY3RUeXBlID0gYXJyYXlbMF0gPj4+IDM7XG4gICAgICAgIC8vIDQgYml0c1xuICAgICAgICBzYW1wbGluZ0luZGV4ID0gKChhcnJheVswXSAmIDB4MDcpIDw8IDEpIHwgKGFycmF5WzFdID4+PiA3KTtcbiAgICAgICAgaWYgKHNhbXBsaW5nSW5kZXggPCAwIHx8IHNhbXBsaW5nSW5kZXggPj0gbXBlZ1NhbXBsaW5nUmF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKERlbXV4RXJyb3JzLkZPUk1BVF9FUlJPUiwgJ0ZsdjogQUFDIGludmFsaWQgc2FtcGxpbmcgZnJlcXVlbmN5IGluZGV4IScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2FtcGxpbmdGcmVxdWVuY2UgPSBtcGVnU2FtcGxpbmdSYXRlc1tzYW1wbGluZ0luZGV4XTtcblxuICAgICAgICAvLyA0IGJpdHNcbiAgICAgICAgY29uc3QgY2hhbm5lbENvbmZpZyA9IChhcnJheVsxXSAmIDB4NzgpID4+PiAzO1xuICAgICAgICBpZiAoY2hhbm5lbENvbmZpZyA8IDAgfHwgY2hhbm5lbENvbmZpZyA+PSA4KSB7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKERlbXV4RXJyb3JzLkZPUk1BVF9FUlJPUiwgJ0ZsdjogQUFDIGludmFsaWQgY2hhbm5lbCBjb25maWd1cmF0aW9uJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXVkaW9PYmplY3RUeXBlID09PSA1KSB7IC8vIEhFLUFBQz9cbiAgICAgICAgICAgIC8vIDQgYml0c1xuICAgICAgICAgICAgZXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9ICgoYXJyYXlbMV0gJiAweDA3KSA8PCAxKSB8IChhcnJheVsyXSA+Pj4gNyk7XG4gICAgICAgICAgICAvLyA1IGJpdHNcbiAgICAgICAgICAgIGF1ZGlvRXh0ZW5zaW9uT2JqZWN0VHlwZSA9IChhcnJheVsyXSAmIDB4N0MpID4+PiAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd29ya2Fyb3VuZHMgZm9yIHZhcmlvdXMgYnJvd3NlcnNcbiAgICAgICAgY29uc3QgdXNlckFnZW50ID0gc2VsZi5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBmaXJlZm94OiB1c2UgU0JSIChIRS1BQUMpIGlmIGZyZXEgbGVzcyB0aGFuIDI0a0h6XG4gICAgICAgICAgICBpZiAoc2FtcGxpbmdJbmRleCA+PSA2KSB7XG4gICAgICAgICAgICAgICAgYXVkaW9PYmplY3RUeXBlID0gNTtcbiAgICAgICAgICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IHNhbXBsaW5nSW5kZXggLSAzO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gdXNlIExDLUFBQ1xuICAgICAgICAgICAgICAgIGF1ZGlvT2JqZWN0VHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBzYW1wbGluZ0luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBhbmRyb2lkOiBhbHdheXMgdXNlIExDLUFBQ1xuICAgICAgICAgICAgYXVkaW9PYmplY3RUeXBlID0gMjtcbiAgICAgICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgICAgIGV4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBzYW1wbGluZ0luZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZm9yIG90aGVyIGJyb3dzZXJzLCBlLmcuIGNocm9tZS4uLlxuICAgICAgICAgICAgLy8gQWx3YXlzIHVzZSBIRS1BQUMgdG8gbWFrZSBpdCBlYXNpZXIgdG8gc3dpdGNoIGFhYyBjb2RlYyBwcm9maWxlXG4gICAgICAgICAgICBhdWRpb09iamVjdFR5cGUgPSA1O1xuICAgICAgICAgICAgZXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IHNhbXBsaW5nSW5kZXg7XG4gICAgICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG5cbiAgICAgICAgICAgIGlmIChzYW1wbGluZ0luZGV4ID49IDYpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25TYW1wbGluZ0luZGV4ID0gc2FtcGxpbmdJbmRleCAtIDM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb25maWcgPT09IDEpIHsgLy8gTW9ubyBjaGFubmVsXG4gICAgICAgICAgICAgICAgYXVkaW9PYmplY3RUeXBlID0gMjtcbiAgICAgICAgICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IHNhbXBsaW5nSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdbMF0gPSBhdWRpb09iamVjdFR5cGUgPDwgMztcbiAgICAgICAgY29uZmlnWzBdIHw9IChzYW1wbGluZ0luZGV4ICYgMHgwRikgPj4+IDE7XG4gICAgICAgIGNvbmZpZ1sxXSA9IChzYW1wbGluZ0luZGV4ICYgMHgwRikgPDwgNztcbiAgICAgICAgY29uZmlnWzFdIHw9IChjaGFubmVsQ29uZmlnICYgMHgwRikgPDwgMztcbiAgICAgICAgaWYgKGF1ZGlvT2JqZWN0VHlwZSA9PT0gNSkge1xuICAgICAgICAgICAgY29uZmlnWzFdIHw9ICgoZXh0ZW5zaW9uU2FtcGxpbmdJbmRleCAmIDB4MEYpID4+PiAxKTtcbiAgICAgICAgICAgIGNvbmZpZ1syXSA9IChleHRlbnNpb25TYW1wbGluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgICAgICAgICAgIC8vIGV4dGVuZGVkIGF1ZGlvIG9iamVjdCB0eXBlOiBmb3JjZSB0byAyIChMQy1BQUMpXG4gICAgICAgICAgICBjb25maWdbMl0gfD0gKDIgPDwgMik7XG4gICAgICAgICAgICBjb25maWdbM10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIHNhbXBsaW5nUmF0ZTogc2FtcGxpbmdGcmVxdWVuY2UsXG4gICAgICAgICAgICBjaGFubmVsQ291bnQ6IGNoYW5uZWxDb25maWcsXG4gICAgICAgICAgICBjb2RlYzogJ21wNGEuNDAuJyArIGF1ZGlvT2JqZWN0VHlwZSxcbiAgICAgICAgICAgIG9yaWdpbmFsQXVkaW9PYmplY3RUeXBlXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pc0luaXRpYWxNZXRhZGF0YURpc3BhdGNoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNBdWRpbyAmJiB0aGlzLl9oYXNWaWRlbykgeyAvLyBib3RoIGF1ZGlvICYgdmlkZW9cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdWRpb0luaXRpYWxNZXRhZGF0YURpc3BhdGNoZWQgJiYgdGhpcy5fdmlkZW9Jbml0aWFsTWV0YWRhdGFEaXNwYXRjaGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9oYXNBdWRpbyAmJiAhdGhpcy5faGFzVmlkZW8pIHsgLy8gYXVkaW8gb25seVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F1ZGlvSW5pdGlhbE1ldGFkYXRhRGlzcGF0Y2hlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2hhc0F1ZGlvICYmIHRoaXMuX2hhc1ZpZGVvKSB7IC8vIHZpZGVvIG9ubHlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWRlb0luaXRpYWxNZXRhZGF0YURpc3BhdGNoZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgdGFnZGVtdXggPSBuZXcgdGFnRGVtdXgoKTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmNsYXNzIEZsdlBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50ZW1wVWludDggPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICB0aGlzLmFyclRhZyA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy50ZW1wQXJyID0gW107XG4gICAgICAgIHRoaXMuc3RvcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZnJpc3QgPSB0cnVlO1xuICAgICAgICB0aGlzLl9oYXNBdWRpbyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9oYXNWaWRlbyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaOpeWPlyDlpJbpg6jnmoRmbHbkuozov5vliLbmlbDmja5cbiAgICAgKi9cbiAgICBzZXRGbHYodWludDgpIHtcbiAgICAgICAgdGhpcy5zdG9wID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXJyVGFnID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLnRlbXBVaW50OCA9IHVpbnQ4O1xuICAgICAgICBpZiAodGhpcy50ZW1wVWludDgubGVuZ3RoID4gMTMgJiYgdGhpcy50ZW1wVWludDhbMF0gPT0gNzAgJiYgdGhpcy50ZW1wVWludDhbMV0gPT0gNzYgJiYgdGhpcy50ZW1wVWludDhbMl0gPT0gODYpIHtcbiAgICAgICAgICAgIHRoaXMucHJvYmUodGhpcy50ZW1wVWludDguYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMucmVhZCg5KTsgLy8g55Wl5o6JOeS4quWtl+iKgueahGZsdiBoZWFkZXIgdGFnXG4gICAgICAgICAgICB0aGlzLnJlYWQoNCk7IC8vIOeVpeaOieesrOS4gOS4qjTlrZfoioLnmoQgdGFnIHNpemVcbiAgICAgICAgICAgIHRoaXMucGFyc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZnJpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZnNldDtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5mcmlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9iZShidWZmZXIpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IG1pc21hdGNoID0geyBtYXRjaDogZmFsc2UgfTtcblxuICAgICAgICBpZiAoZGF0YVswXSAhPT0gMHg0NiB8fCBkYXRhWzFdICE9PSAweDRDIHx8IGRhdGFbMl0gIT09IDB4NTYgfHwgZGF0YVszXSAhPT0gMHgwMSkge1xuICAgICAgICAgICAgcmV0dXJuIG1pc21hdGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaGFzQXVkaW8gPSAoKGRhdGFbNF0gJiA0KSA+Pj4gMikgIT09IDA7XG4gICAgICAgIGNvbnN0IGhhc1ZpZGVvID0gKGRhdGFbNF0gJiAxKSAhPT0gMDtcblxuICAgICAgICBpZiAoIWhhc0F1ZGlvICYmICFoYXNWaWRlbykge1xuICAgICAgICAgICAgcmV0dXJuIG1pc21hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hhc0F1ZGlvID0gdGFnZGVtdXguX2hhc0F1ZGlvID0gaGFzQXVkaW87XG4gICAgICAgIHRoaXMuX2hhc1ZpZGVvID0gdGFnZGVtdXguX2hhc1ZpZGVvID0gaGFzVmlkZW87XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXRjaDogdHJ1ZSxcbiAgICAgICAgICAgIGhhc0F1ZGlvVHJhY2s6IGhhc0F1ZGlvLFxuICAgICAgICAgICAgaGFzVmlkZW9UcmFjazogaGFzVmlkZW9cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlvIDlp4vop6PmnpBcbiAgICAgKi9cbiAgICBwYXJzZSgpIHtcblxuICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudGVtcFVpbnQ4Lmxlbmd0aCAmJiAhdGhpcy5zdG9wKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMuaW5kZXg7XG5cbiAgICAgICAgICAgIGNvbnN0IHQgPSBuZXcgRmx2VGFnKCk7XG4gICAgICAgICAgICBpZiAodGhpcy50ZW1wVWludDgubGVuZ3RoIC0gdGhpcy5pbmRleCA+PSAxMSkge1xuICAgICAgICAgICAgICAgIHQudGFnVHlwZSA9ICh0aGlzLnJlYWQoMSlbMF0pOyAvLyDlj5blh7p0YWfnsbvlnotcbiAgICAgICAgICAgICAgICB0LmRhdGFTaXplID0gdGhpcy5yZWFkKDMpOyAvLyDlj5blh7rljIXkvZPlpKflsI9cbiAgICAgICAgICAgICAgICB0LlRpbWVzdGFtcCA9IHRoaXMucmVhZCg0KTsgLy8g5Y+W5Ye66Kej56CB5pe26Ze0XG4gICAgICAgICAgICAgICAgdC5TdHJlYW1JRCA9IHRoaXMucmVhZCgzKTsgLy8g5Y+W5Ye6c3RyZWFtIGlkXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodC50YWdUeXBlID09IDE4IHx8IHQudGFnVHlwZSA9PSA4IHx8IHQudGFnVHlwZSA9PSA5KSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgdGFnVHlwZScgKyB0LnRhZ1R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudGVtcFVpbnQ4Lmxlbmd0aCAtIHRoaXMuaW5kZXggPj0gKHRoaXMuZ2V0Qm9keVN1bSh0LmRhdGFTaXplKSArIDQpKSB7XG4gICAgICAgICAgICAgICAgdC5ib2R5ID0gdGhpcy5yZWFkKHRoaXMuZ2V0Qm9keVN1bSh0LmRhdGFTaXplKSk7IC8vIOWPluWHumJvZHlcbiAgICAgICAgICAgICAgICBpZiAodC50YWdUeXBlID09IDkgJiYgdGhpcy5faGFzVmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnJUYWcucHVzaCh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQudGFnVHlwZSA9PSA4ICYmIHRoaXMuX2hhc0F1ZGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJyVGFnLnB1c2godCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0LnRhZ1R5cGUgPT0gMTggKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuYXJyVGFnLmxlbmd0aD09MClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnJUYWcucHVzaCh0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCfov5nmmK/miKrojrfnmoToh6rlrprkuYnmlbDmja4nLHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQuc2l6ZT10aGlzLnJlYWQoNCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XG4gICAgfVxuICAgIHJlYWQobGVuZ3RoKSB7XG4gICAgICAgIC8vIGxldCB1OGEgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgICAgICAvLyB1OGEuc2V0KHRoaXMudGVtcFVpbnQ4LnN1YmFycmF5KHRoaXMuaW5kZXgsIHRoaXMuaW5kZXggKyBsZW5ndGgpLCAwKTtcbiAgICAgICAgY29uc3QgdThhID0gdGhpcy50ZW1wVWludDguc2xpY2UodGhpcy5pbmRleCwgdGhpcy5pbmRleCArIGxlbmd0aCk7XG4gICAgICAgIHRoaXMuaW5kZXggKz0gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gdThhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul3RhZ+WMheS9k+Wkp+Wwj1xuICAgICAqL1xuICAgIGdldEJvZHlTdW0oYXJyKSB7XG4gICAgICAgIGxldCBfc3RyID0gJyc7XG4gICAgICAgIF9zdHIgKz0gKGFyclswXS50b1N0cmluZygxNikubGVuZ3RoID09IDEgPyAnMCcgKyBhcnJbMF0udG9TdHJpbmcoMTYpIDogYXJyWzBdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIF9zdHIgKz0gKGFyclsxXS50b1N0cmluZygxNikubGVuZ3RoID09IDEgPyAnMCcgKyBhcnJbMV0udG9TdHJpbmcoMTYpIDogYXJyWzFdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIF9zdHIgKz0gKGFyclsyXS50b1N0cmluZygxNikubGVuZ3RoID09IDEgPyAnMCcgKyBhcnJbMl0udG9TdHJpbmcoMTYpIDogYXJyWzJdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIHJldHVybiBwYXJzZUludChfc3RyLCAxNik7XG4gICAgfVxufVxudmFyIGZsdnBhcnNlID0gbmV3IEZsdlBhcnNlKCk7XG5cbi8qKlxuICog5Luj56CB5YCf6Ym05LqGZmx2LmpzXG4gKiDlop7liqDkuoboh6rlt7HnmoTms6jph4rlkozlhpnms5VcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNsYXNzIE1QNCB7XG5cbiAgICBzdGF0aWMgaW5pdCgpIHtcbiAgICAgICAgTVA0LnR5cGVzID0ge1xuICAgICAgICAgICAgYXZjMTogW10sXG4gICAgICAgICAgICBhdmNDOiBbXSxcbiAgICAgICAgICAgIGJ0cnQ6IFtdLFxuICAgICAgICAgICAgZGluZjogW10sXG4gICAgICAgICAgICBkcmVmOiBbXSxcbiAgICAgICAgICAgIGVzZHM6IFtdLFxuICAgICAgICAgICAgZnR5cDogW10sXG4gICAgICAgICAgICBoZGxyOiBbXSxcbiAgICAgICAgICAgIG1kYXQ6IFtdLFxuICAgICAgICAgICAgbWRoZDogW10sXG4gICAgICAgICAgICBtZGlhOiBbXSxcbiAgICAgICAgICAgIG1maGQ6IFtdLFxuICAgICAgICAgICAgbWluZjogW10sXG4gICAgICAgICAgICBtb29mOiBbXSxcbiAgICAgICAgICAgIG1vb3Y6IFtdLFxuICAgICAgICAgICAgbXA0YTogW10sXG4gICAgICAgICAgICBtdmV4OiBbXSxcbiAgICAgICAgICAgIG12aGQ6IFtdLFxuICAgICAgICAgICAgc2R0cDogW10sXG4gICAgICAgICAgICBzdGJsOiBbXSxcbiAgICAgICAgICAgIHN0Y286IFtdLFxuICAgICAgICAgICAgc3RzYzogW10sXG4gICAgICAgICAgICBzdHNkOiBbXSxcbiAgICAgICAgICAgIHN0c3o6IFtdLFxuICAgICAgICAgICAgc3R0czogW10sXG4gICAgICAgICAgICB0ZmR0OiBbXSxcbiAgICAgICAgICAgIHRmaGQ6IFtdLFxuICAgICAgICAgICAgdHJhZjogW10sXG4gICAgICAgICAgICB0cmFrOiBbXSxcbiAgICAgICAgICAgIHRydW46IFtdLFxuICAgICAgICAgICAgdHJleDogW10sXG4gICAgICAgICAgICB0a2hkOiBbXSxcbiAgICAgICAgICAgIHZtaGQ6IFtdLFxuICAgICAgICAgICAgc21oZDogW11cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gTVA0LnR5cGVzKSB7XG4gICAgICAgICAgICBpZiAoTVA0LnR5cGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgTVA0LnR5cGVzW25hbWVdID0gW1xuICAgICAgICAgICAgICAgICAgICBuYW1lLmNoYXJDb2RlQXQoMCksXG4gICAgICAgICAgICAgICAgICAgIG5hbWUuY2hhckNvZGVBdCgxKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZS5jaGFyQ29kZUF0KDIpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLmNoYXJDb2RlQXQoMylcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29uc3RhbnRzID0gTVA0LmNvbnN0YW50cyA9IHt9O1xuXG4gICAgICAgIGNvbnN0YW50cy5GVFlQID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHg2OSwgMHg3MywgMHg2RiwgMHg2RCwgLy8gbWFqb3JfYnJhbmQ6IGlzb21cdFx0aXNvbVx0TVA0ICBCYXNlIE1lZGlhIHYxIFtJUzAgMTQ0OTYtMTI6MjAwM11cdElTT1x0WUVTXHR2aWRlby9tcDRcbiAgICAgICAgICAgIDB4MCwgMHgwLCAweDAsIDB4MSwgLy8gbWlub3JfdmVyc2lvbjogMHgwMVxuICAgICAgICAgICAgMHg2OSwgMHg3MywgMHg2RiwgMHg2RCwgLy8gaXNvbVxuICAgICAgICAgICAgMHg2MSwgMHg3NiwgMHg2MywgMHgzMSAvLyBhdmMxXG4gICAgICAgIF0pO1xuXG4gICAgICAgIGNvbnN0YW50cy5TVFNEX1BSRUZJWCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHZlcnNpb24oMCkgKyBmbGFncyAgdmVyc2lvbuWtl+auteWQjuS8muacieS4gOS4qmVudHJ5IGNvdW505a2X5q61XG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2NvdW50XHTmoLnmja5lbnRyeeeahOS4quaVsO+8jOavj+S4qmVudHJ55Lya5pyJdHlwZeS/oeaBr++8jOWmguKAnHZpZGXigJ3jgIHigJxzdW5k4oCd562J77yM5qC55o2udHlwZeS4jeWQjHNhbXBsZSBkZXNjcmlwdGlvbuS8muaPkOS+m+S4jeWQjOeahOS/oeaBr++8jOS+i+WmguWvueS6jnZpZGVvIHRyYWNr77yM5Lya5pyJ4oCcVmlzdWFsU2FtcGxlRW50cnnigJ3nsbvlnovkv6Hmga/vvIzlr7nkuo5hdWRpbyB0cmFja+S8muacieKAnEF1ZGlvU2FtcGxlRW50cnnigJ3nsbvlnovkv6Hmga/jgIJcbiAgICAgICAgXSk7XG5cbiAgICAgICAgY29uc3RhbnRzLlNUVFMgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyB2ZXJzaW9uKDApICsgZmxhZ3NcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnQgICAgIDDkuKrntKLlvJVcbiAgICAgICAgXSk7XG5cbiAgICAgICAgY29uc3RhbnRzLlNUU0MgPSBjb25zdGFudHMuU1RDTyA9IGNvbnN0YW50cy5TVFRTO1xuXG4gICAgICAgIGNvbnN0YW50cy5TVFNaID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdmVyc2lvbigwKSArIGZsYWdzXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBzYW1wbGVfc2l6ZVxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBzYW1wbGVfY291bnRcbiAgICAgICAgXSk7XG5cbiAgICAgICAgY29uc3RhbnRzLkhETFJfVklERU8gPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyB2ZXJzaW9uKDApICsgZmxhZ3NcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAgICAgICAweDc2LCAweDY5LCAweDY0LCAweDY1LCAvLyBoYW5kbGVyX3R5cGU6ICd2aWRlJyDlnKhtZWRpYSBib3jkuK3vvIzor6XlgLzkuLo05Liq5a2X56ymXHRcdOKAnHZpZGXigJ3igJQgdmlkZW8gdHJhY2tcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkOiAzICogNCBieXRlc1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIOS/neeVmeS9jVxuICAgICAgICAgICAgMHg1NiwgMHg2OSwgMHg2NCwgMHg2NSxcbiAgICAgICAgICAgIDB4NkYsIDB4NDgsIDB4NjEsIDB4NkUsXG4gICAgICAgICAgICAweDY0LCAweDZDLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6IFZpZGVvSGFuZGxlciDplb/luqbkuI3lrppcdFx0dHJhY2sgdHlwZSBuYW1l77yM5Lul4oCYXFww4oCZ57uT5bC+55qE5a2X56ym5LiyXG4gICAgICAgIF0pO1xuXG4gICAgICAgIGNvbnN0YW50cy5IRExSX0FVRElPID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdmVyc2lvbigwKSArIGZsYWdzXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgICAgICAgMHg3MywgMHg2RiwgMHg3NSwgMHg2RSwgLy8gaGFuZGxlcl90eXBlOiAnc291biflnKhtZWRpYSBib3jkuK3vvIzor6XlgLzkuLo05Liq5a2X56ymXHRcdOKAnHNvdW7igJ3igJQgYXVkaW8gdHJhY2tcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkOiAzICogNCBieXRlc1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIOS/neeVmeS9jVxuICAgICAgICAgICAgMHg1MywgMHg2RiwgMHg3NSwgMHg2RSxcbiAgICAgICAgICAgIDB4NjQsIDB4NDgsIDB4NjEsIDB4NkUsXG4gICAgICAgICAgICAweDY0LCAweDZDLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6IFNvdW5kSGFuZGxlciDplb/luqbkuI3lrppcdFx0dHJhY2sgdHlwZSBuYW1l77yM5Lul4oCYXFww4oCZ57uT5bC+55qE5a2X56ym5LiyXG4gICAgICAgIF0pO1xuXG4gICAgICAgIGNvbnN0YW50cy5EUkVGID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdmVyc2lvbigwKSArIGZsYWdzXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBlbnRyeV9jb3VudCAx5LiqdXJsXG4gICAgICAgICAgICAvLyB1cmxcdGJveOW8gOWni1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwQywgLy8gZW50cnlfc2l6ZVxuICAgICAgICAgICAgMHg3NSwgMHg3MiwgMHg2QywgMHgyMCwgLy8gdHlwZSAndXJsICdcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEgLy8gdmVyc2lvbigwKSArIGZsYWdzIOW9k+KAnHVybOKAneaIluKAnHVybuKAneeahGJveCBmbGFn5Li6MeaXtu+8jOWtl+espuS4suWdh+S4uuepuuOAglxuICAgICAgICBdKTtcblxuICAgICAgICAvLyBTb3VuZCBtZWRpYSBoZWFkZXJcbiAgICAgICAgY29uc3RhbnRzLlNNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyB2ZXJzaW9uKDApICsgZmxhZ3NcdGJveOeJiOacrO+8jDDmiJYx77yM5LiA6Iis5Li6MOOAglxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBiYWxhbmNlKDIpICsgcmVzZXJ2ZWQoMikg56uL5L2T5aOw5bmz6KGh77yMWzguOF0g5qC85byP5YC877yM5LiA6Iis5Li6MO+8jC0xLjDooajnpLrlhajpg6jlt6blo7DpgZPvvIwxLjDooajnpLrlhajpg6jlj7Plo7DpgZMrMuS9jeS/neeVmeS9jVxuICAgICAgICBdKTtcblxuICAgICAgICAvLyB2aWRlbyBtZWRpYSBoZWFkZXJcbiAgICAgICAgY29uc3RhbnRzLlZNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyB2ZXJzaW9uKDApICsgZmxhZ3NcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIC8vIGdyYXBoaWNzbW9kZTogMiBieXRlcyDop4bpopHlkIjmiJDmqKHlvI/vvIzkuLow5pe25ou36LSd5Y6f5aeL5Zu+5YOP77yM5ZCm5YiZ5LiOb3Bjb2xvcui/m+ihjOWQiOaIkCAgIC8v55CG6K665LiK5pivNOS9jeWViiAg5pqC5pe25L+d55WZXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBvcGNvbG9yOiAzICogMiBieXRlcyDvvZtyZWTvvIxncmVlbu+8jGJsdWXvvZ1cbiAgICAgICAgICAgIDB4MDAsIDB4MDBcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5bCB6KOFYm94XG4gICAgICovXG4gICAgc3RhdGljIGJveCh0eXBlKSB7XG4gICAgICAgIGxldCBzaXplID0gODtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGRhdGFzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgY29uc3QgYXJyYXlDb3VudCA9IGRhdGFzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgc2l6ZSArPSBkYXRhc1tpXS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJveOWktOmDqOWkp+Wwj1xuICAgICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgICAgcmVzdWx0WzBdID0gKHNpemUgPj4+IDI0KSAmIDB4RkY7IC8vIHNpemVcbiAgICAgICAgcmVzdWx0WzFdID0gKHNpemUgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgIHJlc3VsdFsyXSA9IChzaXplID4+PiA4KSAmIDB4RkY7XG4gICAgICAgIHJlc3VsdFszXSA9IChzaXplKSAmIDB4RkY7XG4gICAgICAgIC8vIOWGmeWFpWJveOeahHR5cGVcbiAgICAgICAgcmVzdWx0LnNldCh0eXBlLCA0KTsgLy8gdHlwZVxuXG4gICAgICAgIGxldCBvZmZzZXQgPSA4O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Q291bnQ7IGkrKykgeyAvLyBkYXRhIGJvZHlcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoZGF0YXNbaV0sIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gZGF0YXNbaV0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8g5Yib5bu6ZnR5cCZtb292XG4gICAgc3RhdGljIGdlbmVyYXRlSW5pdFNlZ21lbnQobWV0YSkge1xuICAgICAgICBpZiAobWV0YS5jb25zdHJ1Y3RvciAhPSBBcnJheSkge1xuICAgICAgICAgICAgbWV0YSA9IFttZXRhXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdHlwID0gTVA0LmJveChNUDQudHlwZXMuZnR5cCwgTVA0LmNvbnN0YW50cy5GVFlQKTtcbiAgICAgICAgY29uc3QgbW9vdiA9IE1QNC5tb292KG1ldGEpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGZ0eXAuYnl0ZUxlbmd0aCArIG1vb3YuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJlc3VsdC5zZXQoZnR5cCwgMCk7XG4gICAgICAgIHJlc3VsdC5zZXQobW9vdiwgZnR5cC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBNb3ZpZSBtZXRhZGF0YSBib3hcbiAgICBzdGF0aWMgbW9vdihtZXRhKSB7XG4gICAgICAgIGNvbnN0IG12aGQgPSBNUDQubXZoZChtZXRhWzBdLnRpbWVzY2FsZSwgbWV0YVswXS5kdXJhdGlvbik7IC8vIC9tb2926YeM6Z2i55qE56ys5LiA5LiqYm94XG4gICAgICAgIGNvbnN0IHZ0cmFrID0gTVA0LnRyYWsobWV0YVswXSk7XG4gICAgICAgIGxldCBhdHJhaztcbiAgICAgICAgaWYgKG1ldGEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgYXRyYWsgPSBNUDQudHJhayhtZXRhWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG12ZXggPSBNUDQubXZleChtZXRhKTtcbiAgICAgICAgaWYgKG1ldGEubGVuZ3RoID4gMSkgeyByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubW9vdiwgbXZoZCwgdnRyYWssIGF0cmFrLCBtdmV4KTsgfSBlbHNlIHsgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1vb3YsIG12aGQsIHZ0cmFrLCBtdmV4KTsgfVxuICAgIH1cblxuICAgIC8vIE1vdmllIGhlYWRlciBib3hcbiAgICBzdGF0aWMgbXZoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tdmhkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyB2ZXJzaW9uKDApICsgZmxhZ3MgICAgIDHkvY3nmoRib3jniYjmnKwrM+S9jWZsYWdzICAgYm9454mI5pys77yMMOaIljHvvIzkuIDoiKzkuLow44CC77yI5Lul5LiL5a2X6IqC5pWw5Z2H5oyJdmVyc2lvbj0w77yJXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBjcmVhdGlvbl90aW1lICAgIOWIm+W7uuaXtumXtCAg77yI55u45a+55LqOVVRD5pe26Ze0MTkwNC0wMS0wMembtueCueeahOenkuaVsO+8iVxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gbW9kaWZpY2F0aW9uX3RpbWUgICDkv67mlLnml7bpl7RcbiAgICAgICAgICAgICh0aW1lc2NhbGUgPj4+IDI0KSAmIDB4RkYsIC8vIHRpbWVzY2FsZTogNCBieXRlc1x0XHTmlofku7blqpLkvZPlnKgx56eS5pe26Ze05YaF55qE5Yi75bqm5YC877yM5Y+v5Lul55CG6Kej5Li6MeenkumVv+W6plxuICAgICAgICAgICAgKHRpbWVzY2FsZSA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgICh0aW1lc2NhbGUgPj4+IDgpICYgMHhGRixcbiAgICAgICAgICAgICh0aW1lc2NhbGUpICYgMHhGRixcbiAgICAgICAgICAgIChkdXJhdGlvbiA+Pj4gMjQpICYgMHhGRiwgLy8gZHVyYXRpb246IDQgYnl0ZXNcdOivpXRyYWNr55qE5pe26Ze06ZW/5bqm77yM55SoZHVyYXRpb27lkox0aW1lIHNjYWxl5YC85Y+v5Lul6K6h566XdHJhY2vml7bplb/vvIzmr5TlpoJhdWRpbyB0cmFja+eahHRpbWUgc2NhbGUgPSA4MDAwLCBkdXJhdGlvbiA9IDU2MDEyOO+8jOaXtumVv+S4ujcwLjAxNu+8jHZpZGVvIHRyYWNr55qEdGltZSBzY2FsZSA9IDYwMCwgZHVyYXRpb24gPSA0MjAwMO+8jOaXtumVv+S4ujcwXG4gICAgICAgICAgICAoZHVyYXRpb24gPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAoZHVyYXRpb24gPj4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIChkdXJhdGlvbikgJiAweEZGLFxuICAgICAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgLy8gUHJlZmVycmVkIHJhdGU6IDEuMCAgIOaOqOiNkOaSreaUvumAn+eOh++8jOmrmDE25L2N5ZKM5L2OMTbkvY3liIbliKvkuLrlsI/mlbDngrnmlbTmlbDpg6jliIblkozlsI/mlbDpg6jliIbvvIzljbNbMTYuMTZdIOagvOW8j++8jOivpeWAvOS4ujEuMO+8iDB4MDAwMTAwMDDvvInooajnpLrmraPluLjliY3lkJHmkq3mlL5cbiAgICAgICAgICAgIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIFByZWZlcnJlZFZvbHVtZSgxLjAsIDJieXRlcykgKyByZXNlcnZlZCgyYnl0ZXMpXHTkuI5yYXRl57G75Ly877yMWzguOF0g5qC85byP77yMMS4w77yIMHgwMTAw77yJ6KGo56S65pyA5aSn6Z+z6YePXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDogNCArIDQgYnl0ZXNcdOS/neeVmeS9jVxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIC8vIC0tLS1iZWdpbiBjb21wb3NpdGlvbiBtYXRyaXgtLS0tXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8g6KeG6aKR5Y+Y5o2i55+p6Zi1ICAg57q/5oCn5Luj5pWwXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIC0tLS1lbmQgY29tcG9zaXRpb24gbWF0cml4LS0tLVxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gLS0tLWJlZ2luIHByZV9kZWZpbmVkIDYgKiA0IGJ5dGVzLS0tLVxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZS1kZWZpbmVkIOS/neeVmeS9jVxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyAtLS0tZW5kIHByZV9kZWZpbmVkIDYgKiA0IGJ5dGVzLS0tLVxuICAgICAgICAgICAgMHhGRiwgMHhGRiwgMHhGRiwgMHhGRiAvLyBuZXh0X3RyYWNrX0lEIOS4i+S4gOS4qnRyYWNr5L2/55So55qEaWTlj7dcbiAgICAgICAgXSkpO1xuICAgIH1cblxuICAgIC8vIFRyYWNrIGJveFxuICAgIHN0YXRpYyB0cmFrKG1ldGEpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWssIE1QNC50a2hkKG1ldGEpLCBNUDQubWRpYShtZXRhKSk7XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgaGVhZGVyIGJveFxuICAgIHN0YXRpYyB0a2hkKG1ldGEpIHtcbiAgICAgICAgbGV0IHRyYWNrSWQgPSBtZXRhLmlkLFxuICAgICAgICAgICAgZHVyYXRpb24gPSBtZXRhLmR1cmF0aW9uO1xuICAgICAgICBsZXQgd2lkdGggPSBtZXRhLnByZXNlbnRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IG1ldGEucHJlc2VudEhlaWdodDtcblxuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudGtoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwNywgLy8gdmVyc2lvbigwKSArIGZsYWdzIDHkvY3niYjmnKwgYm9454mI5pys77yMMOaIljHvvIzkuIDoiKzkuLow44CC77yI5Lul5LiL5a2X6IqC5pWw5Z2H5oyJdmVyc2lvbj0w77yJ5oyJ5L2N5oiW5pON5L2c57uT5p6c5YC877yM6aKE5a6a5LmJ5aaC5LiL77yaXG4gICAgICAgICAgICAvLyAweDAwMDAwMSB0cmFja19lbmFibGVk77yM5ZCm5YiZ6K+ldHJhY2vkuI3ooqvmkq3mlL7vvJtcbiAgICAgICAgICAgIC8vIDB4MDAwMDAyIHRyYWNrX2luX21vdmll77yM6KGo56S66K+ldHJhY2vlnKjmkq3mlL7kuK3ooqvlvJXnlKjvvJtcbiAgICAgICAgICAgIC8vIDB4MDAwMDA0IHRyYWNrX2luX3ByZXZpZXfvvIzooajnpLror6V0cmFja+WcqOmihOiniOaXtuiiq+W8leeUqOOAglxuICAgICAgICAgICAgLy8g5LiA6Iis6K+l5YC85Li6N++8jDErMis0IOWmguaenOS4gOS4quWqkuS9k+aJgOaciXRyYWNr5Z2H5pyq6K6+572udHJhY2tfaW5fbW92aWXlkox0cmFja19pbl9wcmV2aWV377yM5bCG6KKr55CG6Kej5Li65omA5pyJdHJhY2vlnYforr7nva7kuobov5nkuKTpobnvvJvlr7nkuo5oaW50IHRyYWNr77yM6K+l5YC85Li6MFxuICAgICAgICAgICAgLy8gaGludCB0cmFja8KgIOi/meS4queJueauiueahHRyYWNr5bm25LiN5YyF5ZCr5aqS5L2T5pWw5o2u77yM6ICM5piv5YyF5ZCr5LqG5LiA5Lqb5bCG5YW25LuW5pWw5o2udHJhY2vmiZPljIXmiJDmtYHlqpLkvZPnmoTmjIfnpLrkv6Hmga/jgIJcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNyZWF0aW9uX3RpbWVcdOWIm+W7uuaXtumXtO+8iOebuOWvueS6jlVUQ+aXtumXtDE5MDQtMDEtMDHpm7bngrnnmoTnp5LmlbDvvIlcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIG1vZGlmaWNhdGlvbl90aW1lXHTkv67mlLnml7bpl7RcbiAgICAgICAgICAgICh0cmFja0lkID4+PiAyNCkgJiAweEZGLCAvLyB0cmFja19JRDogNCBieXRlc1x0aWTlj7fvvIzkuI3og73ph43lpI3kuJTkuI3og73kuLowXG4gICAgICAgICAgICAodHJhY2tJZCA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgICh0cmFja0lkID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICAodHJhY2tJZCkgJiAweEZGLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWQ6IDQgYnl0ZXMgICAg5L+d55WZ5L2NXG4gICAgICAgICAgICAoZHVyYXRpb24gPj4+IDI0KSAmIDB4RkYsIC8vIGR1cmF0aW9uOiA0IGJ5dGVzICBcdHRyYWNr55qE5pe26Ze06ZW/5bqmXG4gICAgICAgICAgICAoZHVyYXRpb24gPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAoZHVyYXRpb24gPj4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIChkdXJhdGlvbikgJiAweEZGLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWQ6IDIgKiA0IGJ5dGVzICAgIOS/neeVmeS9jVxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGxheWVyKDJieXRlcykgKyBhbHRlcm5hdGVfZ3JvdXAoMmJ5dGVzKSAg6KeG6aKR5bGC77yM6buY6K6k5Li6MO+8jOWAvOWwj+eahOWcqOS4iuWxgi50cmFja+WIhue7hOS/oeaBr++8jOm7mOiupOS4ujDooajnpLror6V0cmFja+acquS4juWFtuS7lnRyYWNr5pyJ576k57uE5YWz57O7XG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyB2b2x1bWUoMmJ5dGVzKSArIHJlc2VydmVkKDJieXRlcykgICAgWzguOF0g5qC85byP77yM5aaC5p6c5Li66Z+z6aKRdHJhY2vvvIwxLjDvvIgweDAxMDDvvInooajnpLrmnIDlpKfpn7Pph4/vvJvlkKbliJnkuLowICAgK+S/neeVmeS9jVxuICAgICAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgLy8gLS0tLWJlZ2luIGNvbXBvc2l0aW9uIG1hdHJpeC0tLS1cbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIC8vIOinhumikeWPmOaNouefqemYtVxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gLS0tLWVuZCBjb21wb3NpdGlvbiBtYXRyaXgtLS0tXG4gICAgICAgICAgICAod2lkdGggPj4+IDgpICYgMHhGRiwgLy8gLy/lrr3luqZcbiAgICAgICAgICAgICh3aWR0aCkgJiAweEZGLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIChoZWlnaHQgPj4+IDgpICYgMHhGRiwgLy8g6auY5bqmXG4gICAgICAgICAgICAoaGVpZ2h0KSAmIDB4RkYsXG4gICAgICAgICAgICAweDAwLCAweDAwXG4gICAgICAgIF0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDigJxtZGlh4oCd5Lmf5piv5LiqY29udGFpbmVyIGJveO+8jOWFtuWtkGJveOeahOe7k+aehOWSjOenjeexu+i/mOaYr+avlOi+g+WkjeadgueahOOAguWFiOadpeeci+S4gOS4quKAnG1kaWHigJ3nmoTlrp7kvovnu5PmnoTmoJHlm77jgIJcbiAgICAgKiDmgLvkvZPmnaXor7TvvIzigJxtZGlh4oCd5a6a5LmJ5LqGdHJhY2vlqpLkvZPnsbvlnovku6Xlj4pzYW1wbGXmlbDmja7vvIzmj4/ov7BzYW1wbGXkv6Hmga/jgILkuIDoiKzigJxtZGlh4oCd5YyF5ZCr5LiA5Liq4oCcbWRoZOKAne+8jFxuICAgICAqIOS4gOS4quKAnGhkbHLigJ3lkozkuIDkuKrigJxtaW5m4oCd77yM5YW25Lit4oCcbWRoZOKAneS4um1lZGlhIGhlYWRlciBib3jvvIzigJxoZGxy4oCd5Li6aGFuZGxlciByZWZlcmVuY2UgYm9477yMXG4gICAgICog4oCcbWluZuKAneS4um1lZGlhIGluZm9ybWF0aW9uIGJveOOAglxuICAgICAqXG4gICAgICogbWRpYVxuICAgICAqIFx0XHRtZGhkXG4gICAgICogXHRcdGhkbHJcbiAgICAgKiBcdFx0bWluZlxuICAgICAqIFx0XHRcdHNtaGRcbiAgICAgKiBcdFx0XHRkaW5mXG4gICAgICogXHRcdFx0XHRkcmVmXG4gICAgICogXHRcdFx0XHRcdHVybFxuICAgICAqIFx0XHRcdHN0YmxcbiAgICAgKiBcdFx0XHRcdHN0c2RcbiAgICAgKiBcdFx0XHRcdFx0bXA0YVxuICAgICAqIFx0XHRcdFx0XHRcdGVzZHNcbiAgICAgKiBcdFx0XHRcdHN0dHNcbiAgICAgKiBcdFx0XHRcdHN0c2NcbiAgICAgKiBcdFx0XHRcdHN0c3pcbiAgICAgKiBcdFx0XHRcdHN0Y29cbiAgICAgKi9cbiAgICBzdGF0aWMgbWRpYShtZXRhKSB7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGlhLCBNUDQubWRoZChtZXRhKSwgTVA0LmhkbHIobWV0YSksIE1QNC5taW5mKG1ldGEpKTtcbiAgICB9XG5cbiAgICAvLyBNZWRpYSBoZWFkZXIgYm94XG4gICAgc3RhdGljIG1kaGQobWV0YSkge1xuICAgICAgICBjb25zdCB0aW1lc2NhbGUgPSBtZXRhLnRpbWVzY2FsZTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBtZXRhLmR1cmF0aW9uO1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdmVyc2lvbigwKSArIGZsYWdzIC8vIHZlcnNpb24oMCkgKyBmbGFnc1x0XHRib3jniYjmnKzvvIww5oiWMe+8jOS4gOiIrOS4ujDjgIJcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNyZWF0aW9uX3RpbWUgICAg5Yib5bu65pe26Ze0XG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtb2RpZmljYXRpb25fdGltZeS/ruaUueaXtumXtFxuICAgICAgICAgICAgKHRpbWVzY2FsZSA+Pj4gMjQpICYgMHhGRiwgLy8gdGltZXNjYWxlOiA0IGJ5dGVzICAgIOaWh+S7tuWqkuS9k+WcqDHnp5Lml7bpl7TlhoXnmoTliLvluqblgLzvvIzlj6/ku6XnkIbop6PkuLox56eS6ZW/5bqmXG4gICAgICAgICAgICAodGltZXNjYWxlID4+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKHRpbWVzY2FsZSA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgKHRpbWVzY2FsZSkgJiAweEZGLFxuICAgICAgICAgICAgKGR1cmF0aW9uID4+PiAyNCkgJiAweEZGLCAvLyBkdXJhdGlvbjogNCBieXRlcyAgdHJhY2vnmoTml7bpl7Tplb/luqZcbiAgICAgICAgICAgIChkdXJhdGlvbiA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgIChkdXJhdGlvbiA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgKGR1cmF0aW9uKSAmIDB4RkYsXG4gICAgICAgICAgICAweDU1LCAweEM0LCAvLyBsYW5ndWFnZTogdW5kICh1bmRldGVybWluZWQpIOWqkuS9k+ivreiogOeggeOAguacgOmrmOS9jeS4ujDvvIzlkI7pnaIxNeS9jeS4ujPkuKrlrZfnrKbvvIjop4FJU08gNjM5LTIvVOagh+WHhuS4reWumuS5ie+8iVxuICAgICAgICAgICAgMHgwMCwgMHgwMCAvLyBwcmVfZGVmaW5lZCA9IDBcbiAgICAgICAgXSkpO1xuICAgIH1cblxuICAgIC8vIE1lZGlhIGhhbmRsZXIgcmVmZXJlbmNlIGJveFxuICAgIHN0YXRpYyBoZGxyKG1ldGEpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBudWxsO1xuICAgICAgICBpZiAobWV0YS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICBkYXRhID0gTVA0LmNvbnN0YW50cy5IRExSX0FVRElPO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IE1QNC5jb25zdGFudHMuSERMUl9WSURFTztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaGRsciwgZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG5cdFx0ICog4oCcbWluZuKAneWtmOWCqOS6huino+mHinRyYWNr5aqS5L2T5pWw5o2u55qEaGFuZGxlci1zcGVjaWZpY+S/oeaBr++8jG1lZGlhIGhhbmRsZXLnlKjov5nkupvkv6Hmga/lsIblqpLkvZPml7bpl7TmmKDlsITliLDlqpLkvZPmlbDmja7lubbov5vooYzlpITnkIbjgILigJxtaW5m4oCd5Lit55qE5L+h5oGv5qC85byP5ZKM5YaF5a655LiO5aqS5L2T57G75Z6L5Lul5Y+K6Kej6YeK5aqS5L2T5pWw5o2u55qEbWVkaWEgaGFuZGxlcuWvhuWIh+ebuOWFs++8jOWFtuS7lm1lZGlhIGhhbmRsZXLkuI3nn6XpgZPlpoLkvZXop6Pph4rov5nkupvkv6Hmga/jgILigJxtaW5m4oCd5piv5LiA5LiqY29udGFpbmVyIGJveO+8jOWFtuWunumZheWGheWuueeUseWtkGJveOivtOaYjuOAglxuwqDCoMKgIOS4gOiIrOaDheWGteS4i++8jOKAnG1pbmbigJ3ljIXlkKvkuIDkuKpoZWFkZXIgYm9477yM5LiA5Liq4oCcZGluZuKAneWSjOS4gOS4quKAnHN0YmzigJ3vvIzlhbbkuK3vvIxoZWFkZXIgYm945qC55o2udHJhY2sgdHlwZe+8iOWNs21lZGlhIGhhbmRsZXIgdHlwZe+8ieWIhuS4uuKAnHZtaGTigJ3jgIHigJxzbWhk4oCd44CB4oCcaG1oZOKAneWSjOKAnG5taGTigJ3vvIzigJxkaW5m4oCd5Li6ZGF0YSBpbmZvcm1hdGlvbiBib3jvvIzigJxzdGJs4oCd5Li6c2FtcGxlIHRhYmxlIGJveOOAguS4i+mdouWIhuWIq+S7i+e7jeOAglxuXG5cdFx0ICpcblx0XHQgKi9cbiAgICAvLyBNZWRpYSBpbmZvbWF0aW9uIGJveFxuICAgIHN0YXRpYyBtaW5mKG1ldGEpIHtcbiAgICAgICAgLy8gaGVhZGVyIGJveOagueaNrnRyYWNrIHR5cGXvvIjljbNtZWRpYSBoYW5kbGVyIHR5cGXvvInliIbkuLrigJx2bWhk4oCd44CB4oCcc21oZOKAneOAgeKAnGhtaGTigJ3lkozigJxubWhk4oCdXG4gICAgICAgIGxldCB4bWhkID0gbnVsbDtcbiAgICAgICAgaWYgKG1ldGEudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgeG1oZCA9IE1QNC5ib3goTVA0LnR5cGVzLnNtaGQsIE1QNC5jb25zdGFudHMuU01IRCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4bWhkID0gTVA0LmJveChNUDQudHlwZXMudm1oZCwgTVA0LmNvbnN0YW50cy5WTUhEKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgeG1oZCwgTVA0LmRpbmYoKSwgTVA0LnN0YmwobWV0YSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERhdGEgSW5mb3JtYXRpb24gQm94XG4gICAgICog4oCcZGluZuKAneino+mHiuWmguS9leWumuS9jeWqkuS9k+S/oeaBr++8jOaYr+S4gOS4qmNvbnRhaW5lciBib3jjgILigJxkaW5m4oCd5LiA6Iis5YyF5ZCr5LiA5Liq4oCcZHJlZuKAne+8jOWNs2RhdGEgcmVmZXJlbmNlIGJveO+8m1xuICAgICAqIOKAnGRyZWbigJ3kuIvkvJrljIXlkKvoi6XlubLkuKrigJx1cmzigJ3miJbigJx1cm7igJ3vvIzov5nkuptib3jnu4TmiJDkuIDkuKrooajvvIznlKjmnaXlrprkvY10cmFja+aVsOaNruOAglxuICAgICAqIOeugOWNleeahOivtO+8jHRyYWNr5Y+v5Lul6KKr5YiG5oiQ6Iul5bmy5q6177yM5q+P5LiA5q616YO95Y+v5Lul5qC55o2u4oCcdXJs4oCd5oiW4oCcdXJu4oCd5oyH5ZCR55qE5Zyw5Z2A5p2l6I635Y+W5pWw5o2u77yMXG4gICAgICogc2FtcGxl5o+P6L+w5Lit5Lya55So6L+Z5Lqb54mH5q6155qE5bqP5Y+35bCG6L+Z5Lqb54mH5q6157uE5oiQ5LiA5Liq5a6M5pW055qEdHJhY2vjgIJcbiAgICAgKiDkuIDoiKzmg4XlhrXkuIvvvIzlvZPmlbDmja7ooqvlrozlhajljIXlkKvlnKjmlofku7bkuK3ml7bvvIzigJx1cmzigJ3miJbigJx1cm7igJ3kuK3nmoTlrprkvY3lrZfnrKbkuLLmmK/nqbrnmoTjgIJcbiAgICAgKi9cbiAgICBzdGF0aWMgZGluZigpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gTVA0LmJveChNUDQudHlwZXMuZGluZixcbiAgICAgICAgICAgIE1QNC5ib3goTVA0LnR5cGVzLmRyZWYsIE1QNC5jb25zdGFudHMuRFJFRilcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcblx0XHQgKiBTYW1wbGUgVGFibGUgQm9477yIc3RibO+8iVxuwqDCoMKgIFx0Klx04oCcc3RibOKAneWHoOS5juaYr+aZrumAmueahE1QNOaWh+S7tuS4reacgOWkjeadgueahOS4gOS4qmJveOS6hu+8jOmmluWFiOmcgOimgeWbnuW/huS4gOS4i3NhbXBsZeeahOamguW/teOAglxuIFx0XHQqIFx0c2FtcGxl5piv5aqS5L2T5pWw5o2u5a2Y5YKo55qE5Y2V5L2N77yM5a2Y5YKo5ZyobWVkaWHnmoRjaHVua+S4re+8jGNodW5r5ZKMc2FtcGxl55qE6ZW/5bqm5Z2H5Y+v5LqS5LiN55u45ZCM77yM5aaC5LiL5Zu+5omA56S644CCXG5cdFx0XHTigJxzdGJs4oCd5piv5LiA5LiqY29udGFpbmVyIGJveO+8jOWFtuWtkGJveOWMheaLrO+8mnNhbXBsZSBkZXNjcmlwdGlvbiBib3jvvIhzdHNk77yJ44CBXG5cdFx0XHQgKiB0aW1lIHRvIHNhbXBsZSBib3jvvIhzdHRz77yJ44CBc2FtcGxlIHNpemUgYm9477yIc3RzeuaIlnN0ejLvvInjgIFcblx0XHRcdCAqIHNhbXBsZSB0byBjaHVuayBib3jvvIhzdHNj77yJ44CBY2h1bmsgb2Zmc2V0IGJveO+8iHN0Y2/miJZjbzY077yJ44CBXG5cdFx0XHQgKiBjb21wb3NpdGlvbiB0aW1lIHRvIHNhbXBsZSBib3jvvIhjdHRz77yJ44CBc3luYyBzYW1wbGUgYm9477yIc3Rzc++8iVxuXHRcdFx0ICogc3RzZOKAneW/heS4jeWPr+Wwke+8jOS4lOiHs+WwkeWMheWQq+S4gOS4quadoeebru+8jOivpWJveOWMheWQq+S6hmRhdGEgcmVmZXJlbmNlIGJveOi/m+ihjHNhbXBsZeaVsOaNruajgOe0oueahOS/oeaBr+OAglxuXHRcdFx0ICog5rKh5pyJ4oCcc3RzZOKAneWwseaXoOazleiuoeeul21lZGlhIHNhbXBsZeeahOWtmOWCqOS9jee9ruOAguKAnHN0c2TigJ3ljIXlkKvkuobnvJbnoIHnmoTkv6Hmga/vvIzlhbblrZjlgqjnmoTkv6Hmga/pmo/lqpLkvZPnsbvlnovkuI3lkIzogIzkuI3lkIzjgIJcblx0XHRcdCAqIFx0XHRcdHN0Ymxcblx0XHRcdCAqIFx0XHRcdFx0c3RzZFxuXHRcdFx0ICogXHRcdFx0XHRcdGF2YzFcblx0XHRcdCAqIFx0XHRcdFx0XHRcdGF2Y0Ncblx0XHRcdCAqIFx0XHRcdFx0c3R0c1xuXHRcdFx0ICogXHRcdFx0XHRzdHNjXG5cdFx0XHQgKiBcdFx0XHRcdHN0c3pcblx0XHRcdCAqIFx0XHRcdFx0c3Rjb1xuXHRcdCAqL1xuICAgIHN0YXRpYyBzdGJsKG1ldGEpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gTVA0LmJveChNUDQudHlwZXMuc3RibCwgLy8gdHlwZTogc3RibFxuICAgICAgICAgICAgTVA0LnN0c2QobWV0YSksIC8vIFNhbXBsZSBEZXNjcmlwdGlvbiBUYWJsZVxuICAgICAgICAgICAgTVA0LmJveChNUDQudHlwZXMuc3R0cywgTVA0LmNvbnN0YW50cy5TVFRTKSwgLy8gVGltZS1Uby1TYW1wbGUgICAg5Zug5Li6c3R0c+eahGVudHJ5IGNvdW50IOS4ujBcbiAgICAgICAgICAgIC8vIOaJgOS7peayoeacieWFs+mUruW4p2luZGV4IOeahHN0c3NcbiAgICAgICAgICAgIC8vIOS5n+ayoeaciUNUVFMgYm94IENUVFPmmK/orrDlvZXlgY/np7vph49cbiAgICAgICAgICAgIE1QNC5ib3goTVA0LnR5cGVzLnN0c2MsIE1QNC5jb25zdGFudHMuU1RTQyksIC8vIFNhbXBsZS1Uby1DaHVua1xuICAgICAgICAgICAgTVA0LmJveChNUDQudHlwZXMuc3RzeiwgTVA0LmNvbnN0YW50cy5TVFNaKSwgLy8gU2FtcGxlIHNpemVcbiAgICAgICAgICAgIE1QNC5ib3goTVA0LnR5cGVzLnN0Y28sIE1QNC5jb25zdGFudHMuU1RDTykgLy8gQ2h1bmsgb2Zmc2V0XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG5cdFx0ICogU2FtcGxlIERlc2NyaXB0aW9uIEJveO+8iHN0c2TvvIlcbsKgwqDCoMKgXHRcdGJveCBoZWFkZXLlkox2ZXJzaW9u5a2X5q615ZCO5Lya5pyJ5LiA5LiqZW50cnkgY291bnTlrZfmrrXvvIxcbiAqIFx0XHRcdOagueaNrmVudHJ555qE5Liq5pWw77yM5q+P5LiqZW50cnnkvJrmnIl0eXBl5L+h5oGv77yM5aaC4oCcdmlkZeKAneOAgeKAnHN1bmTigJ3nrYnvvIxcbiAqIFx0XHTmoLnmja50eXBl5LiN5ZCMc2FtcGxlIGRlc2NyaXB0aW9u5Lya5o+Q5L6b5LiN5ZCM55qE5L+h5oGv77yM5L6L5aaC5a+55LqOdmlkZW8gdHJhY2vvvIxcbiAqIOS8muacieKAnFZpc3VhbFNhbXBsZUVudHJ54oCd57G75Z6L5L+h5oGv77yM5a+55LqOYXVkaW8gdHJhY2vkvJrmnInigJxBdWRpb1NhbXBsZUVudHJ54oCd57G75Z6L5L+h5oGv44CCXG5cblx0XHQgKiAqIFx0XHRcdFx0c3RzZFxuXHRcdFx0KiBcdFx0XHRcdFx0bXA0YVxuXHRcdFx0KiBcdFx0XHRcdFx0XHRlc2RzXG5cdFx0XHQgKlxuXHRcdFx0ICpcblx0XHRcdCAqXG5cdFx0XHQgKlxuXHRcdFx0ICogXHRcdCA0IGJ5dGVzIC0gbGVuZ3RoIGluIHRvdGFsXG5cdFx0XHRcdFx0IDQgYnl0ZXMgLSA0IGNoYXIgY29kZSBvZiBzYW1wbGUgZGVzY3JpcHRpb24gdGFibGUgKHN0c2QpXG5cdFx0XHRcdFx0IDQgYnl0ZXMgLSB2ZXJzaW9uICYgZmxhZ3Ncblx0XHRcdFx0XHQgNCBieXRlcyAtIG51bWJlciBvZiBzYW1wbGUgZW50cmllcyAobnVtX3NhbXBsZV9lbnRyaWVzKVxuXHRcdFx0XHRcdFx0IFtcblx0XHRcdFx0XHRcdCAgICA0IGJ5dGVzIC0gbGVuZ3RoIG9mIHNhbXBsZSBlbnRyeSAobGVuX3NhbXBsZV9lbnRyeSlcblx0XHRcdFx0XHRcdCAgICA0IGJ5dGVzIC0gNCBjaGFyIGNvZGUgb2Ygc2FtcGxlIGVudHJ5XG5cdFx0XHRcdFx0XHQgICAgKCdsZW5fc2FtcGxlX2VudHJ5JyAtIDgpIGJ5dGVzIG9mIGRhdGFcblx0XHRcdFx0XHRcdCBdIChyZXBlYXRlZCAnbnVtX3NhbXBsZV9lbnRyaWVzJyB0aW1lcylcblx0XHRcdFx0XHQoNCBieXRlcyAtIG9wdGlvbmFsIDB4MDAwMDAwMDAgYXMgZW5kIG9mIGJveCBtYXJrZXIgKVxuXHRcdCAqL1xuICAgIHN0YXRpYyBzdHNkKG1ldGEpIHtcbiAgICAgICAgaWYgKG1ldGEudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5jb25zdGFudHMuU1RTRF9QUkVGSVgsIE1QNC5tcDRhKG1ldGEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuY29uc3RhbnRzLlNUU0RfUFJFRklYLCBNUDQuYXZjMShtZXRhKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgbXA0YShtZXRhKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxDb3VudCA9IG1ldGEuY2hhbm5lbENvdW50O1xuICAgICAgICBjb25zdCBzYW1wbGVSYXRlID0gbWV0YS5hdWRpb1NhbXBsZVJhdGU7XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkKDQpIDbkuKrlrZfoioLvvIzorr7nva7kuLow77ybXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyByZXNlcnZlZCgyKSArIGRhdGFfcmVmZXJlbmNlX2luZGV4KDIpXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDogMiAqIDQgYnl0ZXMg5L+d55WZ5L2NXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgY2hhbm5lbENvdW50LCAvLyBjaGFubmVsQ291bnQoMikg5Y2V5aOw6YGT6L+Y5piv5Y+M5aOw6YGTXG4gICAgICAgICAgICAweDAwLCAweDEwLCAvLyBzYW1wbGVTaXplKDIpXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZCg0KSA05a2X6IqC5L+d55WZ5L2NXG4gICAgICAgICAgICAoc2FtcGxlUmF0ZSA+Pj4gOCkgJiAweEZGLCAvLyBBdWRpbyBzYW1wbGUgcmF0ZSDmmL7nhLbopoHlj7Pnp7sxNuS9jeaJjeacieaEj+S5iVx0dGVtcGxhdGUgdW5zaWduZWQgaW50KDMyKSBzYW1wbGVyYXRlID0ge3RpbWVzY2FsZSBvZiBtZWRpYX08PDE2O1xuICAgICAgICAgICAgKHNhbXBsZVJhdGUpICYgMHhGRixcbiAgICAgICAgICAgIDB4MDAsIDB4MDBcbiAgICAgICAgXSk7XG5cbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1wNGEsIGRhdGEsIE1QNC5lc2RzKG1ldGEpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZXNkcyhtZXRhKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IG1ldGEuY29uZmlnO1xuICAgICAgICBjb25zdCBjb25maWdTaXplID0gY29uZmlnLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHZlcnNpb24gMCArIGZsYWdzXG5cbiAgICAgICAgICAgIDB4MDMsIC8vIGRlc2NyaXB0b3JfdHlwZSAgICBNUDRFU0Rlc2NyVGFnXG4gICAgICAgICAgICAweDE3ICsgY29uZmlnU2l6ZSwgLy8gbGVuZ3RoM1xuICAgICAgICAgICAgMHgwMCwgMHgwMSwgLy8gZXNfaWRcbiAgICAgICAgICAgIDB4MDAsIC8vIHN0cmVhbV9wcmlvcml0eVxuXG4gICAgICAgICAgICAweDA0LCAvLyBkZXNjcmlwdG9yX3R5cGUgICAgTVA0RGVjQ29uZmlnRGVzY3JUYWdcbiAgICAgICAgICAgIDB4MEYgKyBjb25maWdTaXplLCAvLyBsZW5ndGhcbiAgICAgICAgICAgIDB4NDAsIC8vIGNvZGVjOiBtcGVnNF9hdWRpb1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKuW9k29iamVjdFR5cGVJbmRpY2F0aW9u5Li6MHg0MOaXtu+8jOS4uk1QRUctNCBBdWRpb++8iE1QRUctNCBBdWRpbyBnZW5lcmFsbHkgaXMgdGhvdWdodCBvZiBhcyBBQUNcbiAgICAgICAgICAgICAqIGJ1dCB0aGVyZSBpcyBhIHdob2xlIGZyYW1ld29yayBvZiBhdWRpbyBjb2RlY3MgdGhhdCBjYW4gR28gaW4gTVBFRy00IEF1ZGlvIGluY2x1ZGluZyBBQUMsIEJTQUMsIEFMUywgQ0VMUCxcbiAgICAgICAgICAgICAqIGFuZCBzb21ldGhpbmcgY2FsbGVkIE1QM09uNO+8ie+8jOWmguaenOaDs+abtOe7huWIhmZvcm1hdOS4umFhY+i/mOaYr21wM++8jFxuICAgICAgICAgICAgICog5Y+v5Lul6K+75Y+WTVA0RGVjU3BlY2lmaWNEZXNjcuWxgmRhdGFbMF3nmoTliY3kupTkvY1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgMHgxNSwgLy8gc3RyZWFtX3R5cGU6IEF1ZGlvXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBidWZmZXJfc2l6ZVxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gbWF4Qml0cmF0ZVxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gYXZnQml0cmF0ZVxuXG4gICAgICAgICAgICAweDA1IC8vIGRlc2NyaXB0b3JfdHlwZSBNUDREZWNTcGVjaWZpY0Rlc2NyVGFnXG4gICAgICAgIF0uY29uY2F0KFtcbiAgICAgICAgICAgIGNvbmZpZ1NpemVcbiAgICAgICAgXSkuY29uY2F0KFxuICAgICAgICAgICAgY29uZmlnXG4gICAgICAgICkuY29uY2F0KFtcbiAgICAgICAgICAgIDB4MDYsIDB4MDEsIDB4MDIgLy8gR0FTcGVjaWZpY0NvbmZpZ1xuICAgICAgICBdKSk7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5lc2RzLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlLnniYhcbiAgICAgKnN0c2TkuIvnmoRhdmMx6KeG6aKR6Kej5p6QXG4gICAgICovXG4gICAgc3RhdGljIGF2YzEobWV0YSkge1xuICAgICAgICBjb25zdCBhdmNjID0gbWV0YS5hdmNjO1xuICAgICAgICBsZXQgd2lkdGggPSBtZXRhLmNvZGVjV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBtZXRhLmNvZGVjSGVpZ2h0O1xuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyAvLyByZXNlcnZlZCg0KSAgICA25LiqwqDkv53nlZnkvY1cdFJlc2VydmVk77yaNuS4quWtl+iKgu+8jOiuvue9ruS4ujDvvJtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIHJlc2VydmVkKDIpICsge3t7e2RhdGFfcmVmZXJlbmNlX2luZGV4KDIpICDmlbDmja7lvJXnlKjntKLlvJV9fX19XG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZCgyKSArIHJlc2VydmVkKDIpXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZDogMyAqIDQgYnl0ZXMgIDMqNOS4quWtl+iKgueahOS/neeVmeS9jVxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAod2lkdGggPj4+IDgpICYgMHhGRiwgLy8gd2lkdGg6IDIgYnl0ZXNcbiAgICAgICAgICAgICh3aWR0aCkgJiAweEZGLFxuICAgICAgICAgICAgKGhlaWdodCA+Pj4gOCkgJiAweEZGLCAvLyBoZWlnaHQ6IDIgYnl0ZXNcbiAgICAgICAgICAgIChoZWlnaHQpICYgMHhGRixcbiAgICAgICAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIGhvcml6cmVzb2x1dGlvbjogNCBieXRlcyDluLjmlbBcbiAgICAgICAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIHZlcnRyZXNvbHV0aW9uOiA0IGJ5dGVzIOW4uOaVsFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWQ6IDQgYnl0ZXMg5L+d55WZ5L2NXG4gICAgICAgICAgICAweDAwLCAweDAxLCAvLyBmcmFtZV9jb3VudFxuICAgICAgICAgICAgLy8gZnJhbWVfY291bnTooajmmI7lpJrlsJHluKfljovnvKnop4bpopHlrZjlgqjlnKjmr4/kuKrmoLfmnKzjgILpu5jorqTmmK8xLOavj+agt+S4gOW4pzvlroPlj6/og73otoXov4cx5q+P5Liq5qC35pys55qE5aSa5Liq5bin5pWwXG4gICAgICAgICAgICAweDA0LCAvL1x0c3RybGVuIGNvbXByZXNzb3JuYW1lOiAzMiBieXRlc1x0XHRcdFN0cmluZ1szMl1cbiAgICAgICAgICAgIC8vIDMy5LiqOCBiaXQgICAg56ys5LiA5LiqOGJpdOihqOekuumVv+W6pizliankuIszMeS4qjhiaXTooajnpLrlhoXlrrlcbiAgICAgICAgICAgIDB4NjcsIDB4MzEsIDB4MzEsIDB4MzEsIC8vIGNvbXByZXNzb3JuYW1lOiAzMiBieXRlcyAgICDnv7vor5Hov4fmnaXmmK9nMTExXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvL1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy9cbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgxOCwgLy8gZGVwdGgg6aKc6Imy5rex5bqmXG4gICAgICAgICAgICAweEZGLCAweEZGIC8vIHByZV9kZWZpbmVkID0gLTFcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5hdmMxLCBkYXRhLCBNUDQuYm94KE1QNC50eXBlcy5hdmNDLCBhdmNjKSk7XG4gICAgfVxuXG4gICAgLy8gTW92aWUgRXh0ZW5kcyBib3hcbiAgICBzdGF0aWMgbXZleChtZXRhKSB7XG4gICAgICAgIGlmIChtZXRhLmxlbmd0aCA+IDEpIHsgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm12ZXgsIE1QNC50cmV4KG1ldGFbMF0pLCBNUDQudHJleChtZXRhWzFdKSk7IH0gZWxzZSB7IHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tdmV4LCBNUDQudHJleChtZXRhWzBdKSk7IH1cbiAgICB9XG5cbiAgICAvLyBUcmFjayBFeHRlbmRzIGJveFxuICAgIHN0YXRpYyB0cmV4KG1ldGEpIHtcbiAgICAgICAgY29uc3QgdHJhY2tJZCA9IG1ldGEuaWQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyB2ZXJzaW9uKDApICsgZmxhZ3NcbiAgICAgICAgICAgICh0cmFja0lkID4+PiAyNCkgJiAweEZGLCAvLyB0cmFja19JRFxuICAgICAgICAgICAgKHRyYWNrSWQgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAodHJhY2tJZCA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgKHRyYWNrSWQpICYgMHhGRixcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4XG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxuICAgICAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMSAvLyBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICAgICAgICBdKTtcbiAgICAgICAgLy8gaWYgKG1ldGEudHlwZSAhPT0gJ3ZpZGVvJykge1xuICAgICAgICAvLyAgICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID0gMHgwMDtcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJleCwgZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gTW92aWUgZnJhZ21lbnQgYm94XG4gICAgc3RhdGljIG1vb2YodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1vb2YsIE1QNC5tZmhkKHRyYWNrLnNlcXVlbmNlTnVtYmVyKSwgTVA0LnRyYWYodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbWZoZChzZXF1ZW5jZU51bWJlcikge1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIChzZXF1ZW5jZU51bWJlciA+Pj4gMjQpICYgMHhGRiwgLy8gc2VxdWVuY2VfbnVtYmVyOiBpbnQzMlxuICAgICAgICAgICAgKHNlcXVlbmNlTnVtYmVyID4+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKHNlcXVlbmNlTnVtYmVyID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICAoc2VxdWVuY2VOdW1iZXIpICYgMHhGRlxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1maGQsIGRhdGEpO1xuICAgIH1cblxuICAgIC8vIFRyYWNrIGZyYWdtZW50IGJveFxuICAgIHN0YXRpYyB0cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrSWQgPSB0cmFjay5pZDtcblxuICAgICAgICAvLyBUcmFjayBmcmFnbWVudCBoZWFkZXIgYm94XG4gICAgICAgIGNvbnN0IHRmaGQgPSBNUDQuYm94KE1QNC50eXBlcy50ZmhkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyB2ZXJzaW9uKDApICYgZmxhZ3NcbiAgICAgICAgICAgICh0cmFja0lkID4+PiAyNCkgJiAweEZGLCAvLyB0cmFja19JRFxuICAgICAgICAgICAgKHRyYWNrSWQgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAodHJhY2tJZCA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgKHRyYWNrSWQpICYgMHhGRlxuICAgICAgICBdKSk7XG4gICAgICAgIC8vIFRyYWNrIEZyYWdtZW50IERlY29kZSBUaW1lXG4gICAgICAgIGNvbnN0IHRmZHQgPSBNUDQuYm94KE1QNC50eXBlcy50ZmR0LCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyB2ZXJzaW9uKDApICYgZmxhZ3NcbiAgICAgICAgICAgIChiYXNlTWVkaWFEZWNvZGVUaW1lID4+PiAyNCkgJiAweEZGLCAvLyBiYXNlTWVkaWFEZWNvZGVUaW1lOiBpbnQzMlxuICAgICAgICAgICAgKGJhc2VNZWRpYURlY29kZVRpbWUgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAoYmFzZU1lZGlhRGVjb2RlVGltZSA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgKGJhc2VNZWRpYURlY29kZVRpbWUpICYgMHhGRlxuICAgICAgICBdKSk7XG4gICAgICAgIGNvbnN0IHNkdHAgPSBNUDQuc2R0cCh0cmFjayk7XG4gICAgICAgIGNvbnN0IHRydW4gPSBNUDQudHJ1bih0cmFjaywgc2R0cC5ieXRlTGVuZ3RoICsgMTYgKyAxNiArIDggKyAxNiArIDggKyA4KTtcblxuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhZiwgdGZoZCwgdGZkdCwgdHJ1biwgc2R0cCk7XG4gICAgfVxuXG4gICAgLy8gU2FtcGxlIERlcGVuZGVuY3kgVHlwZSBib3hcbiAgICBzdGF0aWMgc2R0cCh0cmFjaykge1xuICAgICAgICBjb25zdCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXTtcbiAgICAgICAgY29uc3Qgc2FtcGxlQ291bnQgPSBzYW1wbGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KDQgKyBzYW1wbGVDb3VudCk7XG4gICAgICAgIC8vIDB+NCBieXRlczogdmVyc2lvbigwKSAmIGZsYWdzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBzYW1wbGVzW2ldLmZsYWdzO1xuICAgICAgICAgICAgZGF0YVtpICsgNF0gPSAoZmxhZ3MuaXNMZWFkaW5nIDw8IDYpIC8vIGlzX2xlYWRpbmc6IDIgKGJpdClcbiAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgKGZsYWdzLmRlcGVuZHNPbiA8PCA0KSAvLyBzYW1wbGVfZGVwZW5kc19vblxuICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAoZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDIpIC8vIHNhbXBsZV9pc19kZXBlbmRlZF9vblxuICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAoZmxhZ3MuaGFzUmVkdW5kYW5jeSk7IC8vIHNhbXBsZV9oYXNfcmVkdW5kYW5jeVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zZHRwLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBUcmFjayBmcmFnbWVudCBydW4gYm94XG4gICAgc3RhdGljIHRydW4odHJhY2ssIG9mZnNldCkge1xuICAgICAgICBjb25zdCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXTtcbiAgICAgICAgY29uc3Qgc2FtcGxlQ291bnQgPSBzYW1wbGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGF0YVNpemUgPSAxMiArIDE2ICogc2FtcGxlQ291bnQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhU2l6ZSk7XG4gICAgICAgIG9mZnNldCArPSA4ICsgZGF0YVNpemU7XG5cbiAgICAgICAgZGF0YS5zZXQoW1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwRiwgMHgwMSwgLy8gdmVyc2lvbigwKSAmIGZsYWdzXG4gICAgICAgICAgICAoc2FtcGxlQ291bnQgPj4+IDI0KSAmIDB4RkYsIC8vIHNhbXBsZV9jb3VudFxuICAgICAgICAgICAgKHNhbXBsZUNvdW50ID4+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKHNhbXBsZUNvdW50ID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICAoc2FtcGxlQ291bnQpICYgMHhGRixcbiAgICAgICAgICAgIChvZmZzZXQgPj4+IDI0KSAmIDB4RkYsIC8vIGRhdGFfb2Zmc2V0XG4gICAgICAgICAgICAob2Zmc2V0ID4+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKG9mZnNldCA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgKG9mZnNldCkgJiAweEZGXG4gICAgICAgIF0sIDApO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlQ291bnQ7IGkrKykge1xuXG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IHNhbXBsZXNbaV0uZHVyYXRpb247XG5cbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBzYW1wbGVzW2ldLnNpemU7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IHNhbXBsZXNbaV0uZmxhZ3M7XG4gICAgICAgICAgICBjb25zdCBjdHMgPSBzYW1wbGVzW2ldLmN0cztcbiAgICAgICAgICAgIGRhdGEuc2V0KFtcbiAgICAgICAgICAgICAgICAoZHVyYXRpb24gPj4+IDI0KSAmIDB4RkYsIC8vIHNhbXBsZV9kdXJhdGlvblxuICAgICAgICAgICAgICAgIChkdXJhdGlvbiA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgICAgICAoZHVyYXRpb24gPj4+IDgpICYgMHhGRixcbiAgICAgICAgICAgICAgICAoZHVyYXRpb24pICYgMHhGRixcbiAgICAgICAgICAgICAgICAoc2l6ZSA+Pj4gMjQpICYgMHhGRiwgLy8gc2FtcGxlX3NpemVcbiAgICAgICAgICAgICAgICAoc2l6ZSA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgICAgICAoc2l6ZSA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgICAgIChzaXplKSAmIDB4RkYsXG4gICAgICAgICAgICAgICAgKGZsYWdzLmlzTGVhZGluZyA8PCAyKSB8IGZsYWdzLmRlcGVuZHNPbiwgLy8gc2FtcGxlX2ZsYWdzXG4gICAgICAgICAgICAgICAgKGZsYWdzLmlzRGVwZW5kZWRPbiA8PCA2KSB8IChmbGFncy5oYXNSZWR1bmRhbmN5IDw8IDQpIHwgZmxhZ3MuaXNOb25TeW5jLFxuICAgICAgICAgICAgICAgIDB4MDAsIDB4MDAsIC8vIHNhbXBsZV9kZWdyYWRhdGlvbl9wcmlvcml0eVxuICAgICAgICAgICAgICAgIChjdHMgPj4+IDI0KSAmIDB4RkYsIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgICAgICAgICAgICAgIChjdHMgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAgICAgKGN0cyA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgICAgIChjdHMpICYgMHhGRlxuICAgICAgICAgICAgXSwgMTIgKyAxNiAqIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cnVuLCBkYXRhKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbWRhdChkYXRhKSB7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGF0LCBkYXRhKTtcbiAgICB9XG5cbn1cblxuTVA0LmluaXQoKTtcblxuLypcbiAqIENvcHlyaWdodCAoQykgMjAxNiBCaWxpYmlsaS4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBUaGlzIGZpbGUgaXMgbW9kaWZpZWQgZnJvbSBkYWlseW1vdGlvbidzIGhscy5qcyBsaWJyYXJ5IChobHMuanMvc3JjL2hlbHBlci9hYWMuanMpXG4gKiBAYXV0aG9yIHpoZW5nIHFpYW4gPHhxcUB4cXEuaW0+XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY2xhc3MgQUFDIHtcblxuICAgIHN0YXRpYyBnZXRTaWxlbnRGcmFtZShjaGFubmVsQ291bnQpIHtcbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIzLCAweDgwXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MjEsIDB4MDAsIDB4NDksIDB4OTAsIDB4MDIsIDB4MTksIDB4MDAsIDB4MjMsIDB4ODBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4ZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgwLCAweDJjLCAweDgwLCAweDA4LCAweDAyLCAweDM4XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MzhdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgwMCwgMHhiMiwgMHgwMCwgMHgyMCwgMHgwOCwgMHhlMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxufVxuXG4vKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IEJpbGliaWxpLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIEBhdXRob3IgemhlbmcgcWlhbiA8eHFxQHhxcS5pbT5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBCcm93c2VyID0ge307XG5cbmZ1bmN0aW9uIGRldGVjdCgpIHtcbiAgICAvLyBtb2RpZmllZCBmcm9tIGpxdWVyeS1icm93c2VyLXBsdWdpblxuXG4gICAgY29uc3QgdWEgPSBzZWxmLm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcblxuICAgIGNvbnN0IG1hdGNoID0gLyhlZGdlKVxcLyhbXFx3Ll0rKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgLyhvcHIpW1xcL10oW1xcdy5dKykvLmV4ZWModWEpIHx8XG4gICAgICAgIC8oY2hyb21lKVsgXFwvXShbXFx3Ll0rKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgLyhpZW1vYmlsZSlbXFwvXShbXFx3Ll0rKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgLyh2ZXJzaW9uKShhcHBsZXdlYmtpdClbIFxcL10oW1xcdy5dKykuKihzYWZhcmkpWyBcXC9dKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICAvKHdlYmtpdClbIFxcL10oW1xcdy5dKykuKih2ZXJzaW9uKVsgXFwvXShbXFx3Ll0rKS4qKHNhZmFyaSlbIFxcL10oW1xcdy5dKykvLmV4ZWModWEpIHx8XG4gICAgICAgIC8od2Via2l0KVsgXFwvXShbXFx3Ll0rKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgLyhvcGVyYSkoPzouKnZlcnNpb258KVsgXFwvXShbXFx3Ll0rKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgLyhtc2llKSAoW1xcdy5dKykvLmV4ZWModWEpIHx8XG4gICAgICAgIHVhLmluZGV4T2YoJ3RyaWRlbnQnKSA+PSAwICYmIC8ocnYpKD86OnwgKShbXFx3Ll0rKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgdWEuaW5kZXhPZignY29tcGF0aWJsZScpIDwgMCAmJiAvKG1vemlsbGEpKD86Lio/IHJ2OihbXFx3Ll0rKXwpLy5leGVjKHVhKSB8fCBbXTtcblxuICAgIGNvbnN0IHBsYXRmb3JtX21hdGNoID0gLyhpcGFkKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgLyhpcG9kKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgLyh3aW5kb3dzIHBob25lKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgLyhpcGhvbmUpLy5leGVjKHVhKSB8fFxuICAgICAgICAvKGtpbmRsZSkvLmV4ZWModWEpIHx8XG4gICAgICAgIC8oYW5kcm9pZCkvLmV4ZWModWEpIHx8XG4gICAgICAgIC8od2luZG93cykvLmV4ZWModWEpIHx8XG4gICAgICAgIC8obWFjKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgLyhsaW51eCkvLmV4ZWModWEpIHx8XG4gICAgICAgIC8oY3JvcykvLmV4ZWModWEpIHx8IFtdO1xuXG4gICAgY29uc3QgbWF0Y2hlZCA9IHtcbiAgICAgICAgYnJvd3NlcjogbWF0Y2hbNV0gfHwgbWF0Y2hbM10gfHwgbWF0Y2hbMV0gfHwgJycsXG4gICAgICAgIHZlcnNpb246IG1hdGNoWzJdIHx8IG1hdGNoWzRdIHx8ICcwJyxcbiAgICAgICAgbWFqb3JWZXJzaW9uOiBtYXRjaFs0XSB8fCBtYXRjaFsyXSB8fCAnMCcsXG4gICAgICAgIHBsYXRmb3JtOiBwbGF0Zm9ybV9tYXRjaFswXSB8fCAnJ1xuICAgIH07XG5cbiAgICBjb25zdCBicm93c2VyID0ge307XG4gICAgaWYgKG1hdGNoZWQuYnJvd3Nlcikge1xuICAgICAgICBicm93c2VyW21hdGNoZWQuYnJvd3Nlcl0gPSB0cnVlO1xuXG4gICAgICAgIGNvbnN0IHZlcnNpb25BcnJheSA9IG1hdGNoZWQubWFqb3JWZXJzaW9uLnNwbGl0KCcuJyk7XG4gICAgICAgIGJyb3dzZXIudmVyc2lvbiA9IHtcbiAgICAgICAgICAgIG1ham9yOiBwYXJzZUludChtYXRjaGVkLm1ham9yVmVyc2lvbiwgMTApLFxuICAgICAgICAgICAgc3RyaW5nOiBtYXRjaGVkLnZlcnNpb25cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHZlcnNpb25BcnJheS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBicm93c2VyLnZlcnNpb24ubWlub3IgPSBwYXJzZUludCh2ZXJzaW9uQXJyYXlbMV0sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVyc2lvbkFycmF5Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGJyb3dzZXIudmVyc2lvbi5idWlsZCA9IHBhcnNlSW50KHZlcnNpb25BcnJheVsyXSwgMTApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoZWQucGxhdGZvcm0pIHtcbiAgICAgICAgYnJvd3NlclttYXRjaGVkLnBsYXRmb3JtXSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIub3ByIHx8IGJyb3dzZXIuc2FmYXJpKSB7XG4gICAgICAgIGJyb3dzZXIud2Via2l0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBNU0lFLiBJRTExIGhhcyAncnYnIGlkZW50aWZlclxuICAgIGlmIChicm93c2VyLnJ2IHx8IGJyb3dzZXIuaWVtb2JpbGUpIHtcbiAgICAgICAgaWYgKGJyb3dzZXIucnYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBicm93c2VyLnJ2O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1zaWUgPSAnbXNpZSc7XG4gICAgICAgIG1hdGNoZWQuYnJvd3NlciA9IG1zaWU7XG4gICAgICAgIGJyb3dzZXJbbXNpZV0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIE1pY3Jvc29mdCBFZGdlXG4gICAgaWYgKGJyb3dzZXIuZWRnZSkge1xuICAgICAgICBkZWxldGUgYnJvd3Nlci5lZGdlO1xuICAgICAgICBjb25zdCBtc2VkZ2UgPSAnbXNlZGdlJztcbiAgICAgICAgbWF0Y2hlZC5icm93c2VyID0gbXNlZGdlO1xuICAgICAgICBicm93c2VyW21zZWRnZV0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIE9wZXJhIDE1K1xuICAgIGlmIChicm93c2VyLm9wcikge1xuICAgICAgICBjb25zdCBvcGVyYSA9ICdvcGVyYSc7XG4gICAgICAgIG1hdGNoZWQuYnJvd3NlciA9IG9wZXJhO1xuICAgICAgICBicm93c2VyW29wZXJhXSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gU3RvY2sgYW5kcm9pZCBicm93c2VycyBhcmUgbWFya2VkIGFzIFNhZmFyaVxuICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiBicm93c2VyLmFuZHJvaWQpIHtcbiAgICAgICAgY29uc3QgYW5kcm9pZCA9ICdhbmRyb2lkJztcbiAgICAgICAgbWF0Y2hlZC5icm93c2VyID0gYW5kcm9pZDtcbiAgICAgICAgYnJvd3NlclthbmRyb2lkXSA9IHRydWU7XG4gICAgfVxuXG4gICAgYnJvd3Nlci5uYW1lID0gbWF0Y2hlZC5icm93c2VyO1xuICAgIGJyb3dzZXIucGxhdGZvcm0gPSBtYXRjaGVkLnBsYXRmb3JtO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gQnJvd3Nlcikge1xuICAgICAgICBpZiAoQnJvd3Nlci5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBkZWxldGUgQnJvd3NlcltrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oQnJvd3NlciwgYnJvd3Nlcik7XG59XG5cbmRldGVjdCgpO1xuXG4vKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IEJpbGliaWxpLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIEBhdXRob3IgemhlbmcgcWlhbiA8eHFxQHhxcS5pbT5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBSZXByZXNlbnRzIGFuIG1lZGlhIHNhbXBsZSAoYXVkaW8gLyB2aWRlbylcbmNsYXNzIFNhbXBsZUluZm8ge1xuXG4gICAgY29uc3RydWN0b3IoZHRzLCBwdHMsIGR1cmF0aW9uLCBvcmlnaW5hbER0cywgaXNTeW5jKSB7XG4gICAgICAgIHRoaXMuZHRzID0gZHRzO1xuICAgICAgICB0aGlzLnB0cyA9IHB0cztcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRHRzID0gb3JpZ2luYWxEdHM7XG4gICAgICAgIHRoaXMuaXNTeW5jUG9pbnQgPSBpc1N5bmM7XG4gICAgICAgIHRoaXMuZmlsZXBvc2l0aW9uID0gbnVsbDtcbiAgICB9XG5cbn1cblxuLy8gTWVkaWEgU2VnbWVudCBjb25jZXB0IGlzIGRlZmluZWQgaW4gTWVkaWEgU291cmNlIEV4dGVuc2lvbnMgc3BlYy5cbi8vIFBhcnRpY3VsYXJseSBpbiBJU08gQk1GRiBmb3JtYXQsIGFuIE1lZGlhIFNlZ21lbnQgY29udGFpbnMgYSBtb29mIGJveCBmb2xsb3dlZCBieSBhIG1kYXQgYm94LlxuY2xhc3MgTWVkaWFTZWdtZW50SW5mbyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5iZWdpbkR0cyA9IDA7XG4gICAgICAgIHRoaXMuZW5kRHRzID0gMDtcbiAgICAgICAgdGhpcy5iZWdpblB0cyA9IDA7XG4gICAgICAgIHRoaXMuZW5kUHRzID0gMDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEJlZ2luRHRzID0gMDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVuZER0cyA9IDA7XG4gICAgICAgIHRoaXMuc3luY1BvaW50cyA9IFtdOyAvLyBTYW1wbGVJbmZvW25dLCBmb3IgdmlkZW8gSURSIGZyYW1lcyBvbmx5XG4gICAgICAgIHRoaXMuZmlyc3RTYW1wbGUgPSBudWxsOyAvLyBTYW1wbGVJbmZvXG4gICAgICAgIHRoaXMubGFzdFNhbXBsZSA9IG51bGw7IC8vIFNhbXBsZUluZm9cbiAgICB9XG5cbiAgICBhcHBlbmRTeW5jUG9pbnQoc2FtcGxlSW5mbykgeyAvLyBhbHNvIGNhbGxlZCBSYW5kb20gQWNjZXNzIFBvaW50XG4gICAgICAgIHNhbXBsZUluZm8uaXNTeW5jUG9pbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN5bmNQb2ludHMucHVzaChzYW1wbGVJbmZvKTtcbiAgICB9XG5cbn1cblxuLy8gT3JkZXJlZCBsaXN0IGZvciByZWNvcmRpbmcgdmlkZW8gSURSIGZyYW1lcywgc29ydGVkIGJ5IG9yaWdpbmFsRHRzXG5cblxuLy8gRGF0YSBzdHJ1Y3R1cmUgZm9yIHJlY29yZGluZyBpbmZvcm1hdGlvbiBvZiBtZWRpYSBzZWdtZW50cyBpbiBzaW5nbGUgdHJhY2suXG5jbGFzcyBNZWRpYVNlZ21lbnRJbmZvTGlzdCB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9saXN0ID0gW107XG4gICAgICAgIHRoaXMuX2xhc3RBcHBlbmRMb2NhdGlvbiA9IC0xOyAvLyBjYWNoZWQgbGFzdCBpbnNlcnQgbG9jYXRpb25cbiAgICB9XG5cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3QubGVuZ3RoO1xuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saXN0Lmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9sYXN0QXBwZW5kTG9jYXRpb24gPSAtMTtcbiAgICB9XG5cbiAgICBfc2VhcmNoTmVhcmVzdFNlZ21lbnRCZWZvcmUob3JpZ2luYWxCZWdpbkR0cykge1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgbGV0IG1pZCA9IDA7XG4gICAgICAgIGxldCBsYm91bmQgPSAwO1xuICAgICAgICBsZXQgdWJvdW5kID0gbGFzdDtcblxuICAgICAgICBsZXQgaWR4ID0gMDtcblxuICAgICAgICBpZiAob3JpZ2luYWxCZWdpbkR0cyA8IGxpc3RbMF0ub3JpZ2luYWxCZWdpbkR0cykge1xuICAgICAgICAgICAgaWR4ID0gLTE7XG4gICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGxib3VuZCA8PSB1Ym91bmQpIHtcbiAgICAgICAgICAgIG1pZCA9IGxib3VuZCArIE1hdGguZmxvb3IoKHVib3VuZCAtIGxib3VuZCkgLyAyKTtcbiAgICAgICAgICAgIGlmIChtaWQgPT09IGxhc3QgfHwgKG9yaWdpbmFsQmVnaW5EdHMgPiBsaXN0W21pZF0ubGFzdFNhbXBsZS5vcmlnaW5hbER0cyAmJlxuICAgICAgICAgICAgICAgICAgICAob3JpZ2luYWxCZWdpbkR0cyA8IGxpc3RbbWlkICsgMV0ub3JpZ2luYWxCZWdpbkR0cykpKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gbWlkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaXN0W21pZF0ub3JpZ2luYWxCZWdpbkR0cyA8IG9yaWdpbmFsQmVnaW5EdHMpIHtcbiAgICAgICAgICAgICAgICBsYm91bmQgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1Ym91bmQgPSBtaWQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuXG4gICAgX3NlYXJjaE5lYXJlc3RTZWdtZW50QWZ0ZXIob3JpZ2luYWxCZWdpbkR0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VhcmNoTmVhcmVzdFNlZ21lbnRCZWZvcmUob3JpZ2luYWxCZWdpbkR0cykgKyAxO1xuICAgIH1cblxuICAgIGFwcGVuZChtZWRpYVNlZ21lbnRJbmZvKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLl9saXN0O1xuICAgICAgICBjb25zdCBtc2kgPSBtZWRpYVNlZ21lbnRJbmZvO1xuICAgICAgICBjb25zdCBsYXN0QXBwZW5kSWR4ID0gdGhpcy5fbGFzdEFwcGVuZExvY2F0aW9uO1xuICAgICAgICBsZXQgaW5zZXJ0SWR4ID0gMDtcblxuICAgICAgICBpZiAobGFzdEFwcGVuZElkeCAhPT0gLTEgJiYgbGFzdEFwcGVuZElkeCA8IGxpc3QubGVuZ3RoICYmXG4gICAgICAgICAgICBtc2kub3JpZ2luYWxCZWdpbkR0cyA+PSBsaXN0W2xhc3RBcHBlbmRJZHhdLmxhc3RTYW1wbGUub3JpZ2luYWxEdHMgJiZcbiAgICAgICAgICAgICgobGFzdEFwcGVuZElkeCA9PT0gbGlzdC5sZW5ndGggLSAxKSB8fFxuICAgICAgICAgICAgICAgIChsYXN0QXBwZW5kSWR4IDwgbGlzdC5sZW5ndGggLSAxICYmXG4gICAgICAgICAgICAgICAgICAgIG1zaS5vcmlnaW5hbEJlZ2luRHRzIDwgbGlzdFtsYXN0QXBwZW5kSWR4ICsgMV0ub3JpZ2luYWxCZWdpbkR0cykpKSB7XG4gICAgICAgICAgICBpbnNlcnRJZHggPSBsYXN0QXBwZW5kSWR4ICsgMTsgLy8gdXNlIGNhY2hlZCBsb2NhdGlvbiBpZHhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRJZHggPSB0aGlzLl9zZWFyY2hOZWFyZXN0U2VnbWVudEJlZm9yZShtc2kub3JpZ2luYWxCZWdpbkR0cykgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGFzdEFwcGVuZExvY2F0aW9uID0gaW5zZXJ0SWR4O1xuICAgICAgICB0aGlzLl9saXN0LnNwbGljZShpbnNlcnRJZHgsIDAsIG1zaSk7XG4gICAgfVxuXG4gICAgZ2V0TGFzdFNlZ21lbnRCZWZvcmUob3JpZ2luYWxCZWdpbkR0cykge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9zZWFyY2hOZWFyZXN0U2VnbWVudEJlZm9yZShvcmlnaW5hbEJlZ2luRHRzKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlzdFtpZHhdO1xuICAgICAgICB9IGVsc2UgeyAvLyAtMVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRMYXN0U2FtcGxlQmVmb3JlKG9yaWdpbmFsQmVnaW5EdHMpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHRoaXMuZ2V0TGFzdFNlZ21lbnRCZWZvcmUob3JpZ2luYWxCZWdpbkR0cyk7XG4gICAgICAgIGlmIChzZWdtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50Lmxhc3RTYW1wbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldExhc3RTeW5jUG9pbnRCZWZvcmUob3JpZ2luYWxCZWdpbkR0cykge1xuICAgICAgICBsZXQgc2VnbWVudElkeCA9IHRoaXMuX3NlYXJjaE5lYXJlc3RTZWdtZW50QmVmb3JlKG9yaWdpbmFsQmVnaW5EdHMpO1xuICAgICAgICBsZXQgc3luY1BvaW50cyA9IHRoaXMuX2xpc3Rbc2VnbWVudElkeF0uc3luY1BvaW50cztcbiAgICAgICAgd2hpbGUgKHN5bmNQb2ludHMubGVuZ3RoID09PSAwICYmIHNlZ21lbnRJZHggPiAwKSB7XG4gICAgICAgICAgICBzZWdtZW50SWR4LS07XG4gICAgICAgICAgICBzeW5jUG9pbnRzID0gdGhpcy5fbGlzdFtzZWdtZW50SWR4XS5zeW5jUG9pbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzeW5jUG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzeW5jUG9pbnRzW3N5bmNQb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG4vKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IEJpbGliaWxpLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIEBhdXRob3IgemhlbmcgcWlhbiA8eHFxQHhxcS5pbT5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gaW1wb3J0IExvZyBmcm9tICcuLi91dGlscy9sb2dnZXIuanMnO1xuLy8gRnJhZ21lbnRlZCBtcDQgcmVtdXhlclxuY2xhc3MgTVA0UmVtdXhlciB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5UQUcgPSAnTVA0UmVtdXhlcic7XG5cbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLl9pc0xpdmUgPSAoY29uZmlnLmlzTGl2ZSA9PT0gdHJ1ZSkgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fZHRzQmFzZSA9IC0xO1xuICAgICAgICB0aGlzLl9kdHNCYXNlSW5pdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2F1ZGlvRHRzQmFzZSA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLl92aWRlb0R0c0Jhc2UgPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5fYXVkaW9OZXh0RHRzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl92aWRlb05leHREdHMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGhpcy5fYXVkaW9NZXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdmlkZW9NZXRhID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9hdWRpb1NlZ21lbnRJbmZvTGlzdCA9IG5ldyBNZWRpYVNlZ21lbnRJbmZvTGlzdCgnYXVkaW8nKTtcbiAgICAgICAgdGhpcy5fdmlkZW9TZWdtZW50SW5mb0xpc3QgPSBuZXcgTWVkaWFTZWdtZW50SW5mb0xpc3QoJ3ZpZGVvJyk7XG5cbiAgICAgICAgdGhpcy5fb25Jbml0U2VnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uTWVkaWFTZWdtZW50ID0gbnVsbDtcblxuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBjaHJvbWUgPCA1MDogQWx3YXlzIGZvcmNlIGZpcnN0IHNhbXBsZSBhcyBhIFJhbmRvbSBBY2Nlc3MgUG9pbnQgaW4gbWVkaWEgc2VnbWVudFxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5NDEyXG4gICAgICAgIHRoaXMuX2ZvcmNlRmlyc3RJRFIgPSAoQnJvd3Nlci5jaHJvbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChCcm93c2VyLnZlcnNpb24ubWFqb3IgPCA1MCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKEJyb3dzZXIudmVyc2lvbi5tYWpvciA9PT0gNTAgJiYgQnJvd3Nlci52ZXJzaW9uLmJ1aWxkIDwgMjY2MSkpKSA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBJRTExL0VkZ2U6IEZpbGwgc2lsZW50IGFhYyBmcmFtZSBhZnRlciBrZXlmcmFtZS1zZWVraW5nXG4gICAgICAgIC8vIE1ha2UgYXVkaW8gYmVnaW5EdHMgZXF1YWxzIHdpdGggdmlkZW8gYmVnaW5EdHMsIGluIG9yZGVyIHRvIGZpeCBzZWVrIGZyZWV6ZVxuICAgICAgICB0aGlzLl9maWxsU2lsZW50QWZ0ZXJTZWVrID0gKEJyb3dzZXIubXNlZGdlIHx8IEJyb3dzZXIubXNpZSk7XG5cbiAgICAgICAgLy8gV2hpbGUgb25seSBGaXJlRm94IHN1cHBvcnRzICdhdWRpby9tcDQsIGNvZGVjcz1cIm1wM1wiJywgdXNlICdhdWRpby9tcGVnJyBmb3IgY2hyb21lLCBzYWZhcmksIC4uLlxuICAgICAgICB0aGlzLl9tcDNVc2VNcGVnQXVkaW8gPSAhQnJvd3Nlci5maXJlZm94O1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2R0c0Jhc2UgPSAtMTtcbiAgICAgICAgdGhpcy5fZHRzQmFzZUluaXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hdWRpb01ldGEgPSBudWxsO1xuICAgICAgICB0aGlzLl92aWRlb01ldGEgPSBudWxsO1xuICAgICAgICB0aGlzLl9hdWRpb1NlZ21lbnRJbmZvTGlzdC5jbGVhcigpO1xuICAgICAgICB0aGlzLl9hdWRpb1NlZ21lbnRJbmZvTGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZpZGVvU2VnbWVudEluZm9MaXN0LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3ZpZGVvU2VnbWVudEluZm9MaXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb25Jbml0U2VnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uTWVkaWFTZWdtZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBiaW5kRGF0YVNvdXJjZShwcm9kdWNlcikge1xuICAgICAgICBwcm9kdWNlci5vbkRhdGFBdmFpbGFibGUgPSB0aGlzLnJlbXV4LmJpbmQodGhpcyk7XG4gICAgICAgIHByb2R1Y2VyLm9uVHJhY2tNZXRhZGF0YSA9IHRoaXMuX29uVHJhY2tNZXRhZGF0YVJlY2VpdmVkLmJpbmQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qIHByb3RvdHlwZTogZnVuY3Rpb24gb25Jbml0U2VnbWVudCh0eXBlOiBzdHJpbmcsIGluaXRTZWdtZW50OiBBcnJheUJ1ZmZlcik6IHZvaWRcbiAgICAgICBJbml0U2VnbWVudDoge1xuICAgICAgICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICAgICAgIGRhdGE6IEFycmF5QnVmZmVyLFxuICAgICAgICAgICBjb2RlYzogc3RyaW5nLFxuICAgICAgICAgICBjb250YWluZXI6IHN0cmluZ1xuICAgICAgIH1cbiAgICAqL1xuICAgIGdldCBvbkluaXRTZWdtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25Jbml0U2VnbWVudDtcbiAgICB9XG5cbiAgICBzZXQgb25Jbml0U2VnbWVudChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vbkluaXRTZWdtZW50ID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgLyogcHJvdG90eXBlOiBmdW5jdGlvbiBvbk1lZGlhU2VnbWVudCh0eXBlOiBzdHJpbmcsIG1lZGlhU2VnbWVudDogTWVkaWFTZWdtZW50KTogdm9pZFxuICAgICAgIE1lZGlhU2VnbWVudDoge1xuICAgICAgICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICAgICAgIGRhdGE6IEFycmF5QnVmZmVyLFxuICAgICAgICAgICBzYW1wbGVDb3VudDogaW50MzJcbiAgICAgICAgICAgaW5mbzogTWVkaWFTZWdtZW50SW5mb1xuICAgICAgIH1cbiAgICAqL1xuICAgIGdldCBvbk1lZGlhU2VnbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uTWVkaWFTZWdtZW50O1xuICAgIH1cblxuICAgIHNldCBvbk1lZGlhU2VnbWVudChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vbk1lZGlhU2VnbWVudCA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGluc2VydERpc2NvbnRpbnVpdHkoKSB7XG4gICAgICAgIHRoaXMuX2F1ZGlvTmV4dER0cyA9IHRoaXMuX3ZpZGVvTmV4dER0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBzZWVrKG9yaWdpbmFsRHRzKSB7XG4gICAgICAgIHRoaXMuX3ZpZGVvU2VnbWVudEluZm9MaXN0LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2F1ZGlvU2VnbWVudEluZm9MaXN0LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgcmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuX29uTWVkaWFTZWdtZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCdNUDRSZW11eGVyOiBvbk1lZGlhU2VnbWVudCBjYWxsYmFjayBtdXN0IGJlIHNwZWNpZmljZWQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9kdHNCYXNlSW5pdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVEdHNCYXNlKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbXV4VmlkZW8odmlkZW9UcmFjayk7XG4gICAgICAgIHRoaXMuX3JlbXV4QXVkaW8oYXVkaW9UcmFjayk7XG4gICAgfVxuXG4gICAgX29uVHJhY2tNZXRhZGF0YVJlY2VpdmVkKHR5cGUsIG1ldGFkYXRhKSB7XG4gICAgICAgIGxldCBtZXRhYm94ID0gbnVsbDtcblxuICAgICAgICBsZXQgY29udGFpbmVyID0gJ21wNCc7XG4gICAgICAgIGxldCBjb2RlYyA9IG1ldGFkYXRhLmNvZGVjO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB0aGlzLl9hdWRpb01ldGEgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YS5jb2RlYyA9PT0gJ21wMycgJiYgdGhpcy5fbXAzVXNlTXBlZ0F1ZGlvKSB7XG4gICAgICAgICAgICAgICAgLy8gJ2F1ZGlvL21wZWcnIGZvciBNUDMgYXVkaW8gdHJhY2tcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSAnbXBlZyc7XG4gICAgICAgICAgICAgICAgY29kZWMgPSAnJztcbiAgICAgICAgICAgICAgICBtZXRhYm94ID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gJ2F1ZGlvL21wNCwgY29kZWNzPVwiY29kZWNcIidcbiAgICAgICAgICAgICAgICBtZXRhYm94ID0gTVA0LmdlbmVyYXRlSW5pdFNlZ21lbnQobWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvTWV0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgbWV0YWJveCA9IE1QNC5nZW5lcmF0ZUluaXRTZWdtZW50KG1ldGFkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRpc3BhdGNoIG1ldGFib3ggKEluaXRpYWxpemF0aW9uIFNlZ21lbnQpXG4gICAgICAgIGlmICghdGhpcy5fb25Jbml0U2VnbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbignTVA0UmVtdXhlcjogb25Jbml0U2VnbWVudCBjYWxsYmFjayBtdXN0IGJlIHNwZWNpZmllZCEnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vbkluaXRTZWdtZW50KHR5cGUsIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBkYXRhOiBtZXRhYm94LmJ1ZmZlcixcbiAgICAgICAgICAgIGNvZGVjOiBjb2RlYyxcbiAgICAgICAgICAgIGNvbnRhaW5lcjogYCR7dHlwZX0vJHtjb250YWluZXJ9YCxcbiAgICAgICAgICAgIG1lZGlhRHVyYXRpb246IG1ldGFkYXRhLmR1cmF0aW9uICAvLyBpbiB0aW1lc2NhbGUgMTAwMCAobWlsbGlzZWNvbmRzKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlRHRzQmFzZShhdWRpb1RyYWNrLCB2aWRlb1RyYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLl9kdHNCYXNlSW5pdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXVkaW9UcmFjay5zYW1wbGVzICYmIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRHRzQmFzZSA9IGF1ZGlvVHJhY2suc2FtcGxlc1swXS5kdHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcyAmJiB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl92aWRlb0R0c0Jhc2UgPSB2aWRlb1RyYWNrLnNhbXBsZXNbMF0uZHRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZHRzQmFzZSA9IE1hdGgubWluKHRoaXMuX2F1ZGlvRHRzQmFzZSwgdGhpcy5fdmlkZW9EdHNCYXNlKTtcbiAgICAgICAgdGhpcy5fZHRzQmFzZUluaXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgX3JlbXV4QXVkaW8oYXVkaW9UcmFjaykge1xuICAgICAgICBpZiAodGhpcy5fYXVkaW9NZXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0cmFjayA9IGF1ZGlvVHJhY2s7XG4gICAgICAgIGxldCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICAgICAgbGV0IGR0c0NvcnJlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBmaXJzdER0cyA9IC0xLCBsYXN0RHRzID0gLTEsIGxhc3RQdHMgPSAtMTtcbiAgICAgICAgbGV0IHJlZlNhbXBsZUR1cmF0aW9uID0gdGhpcy5fYXVkaW9NZXRhLnJlZlNhbXBsZUR1cmF0aW9uO1xuXG4gICAgICAgIGxldCBtcGVnUmF3VHJhY2sgPSB0aGlzLl9hdWRpb01ldGEuY29kZWMgPT09ICdtcDMnICYmIHRoaXMuX21wM1VzZU1wZWdBdWRpbztcbiAgICAgICAgbGV0IGZpcnN0U2VnbWVudEFmdGVyU2VlayA9IHRoaXMuX2R0c0Jhc2VJbml0ZWQgJiYgdGhpcy5fYXVkaW9OZXh0RHRzID09PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgbGV0IGluc2VydFByZWZpeFNpbGVudEZyYW1lID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFzYW1wbGVzIHx8IHNhbXBsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IG1kYXRib3ggPSBudWxsO1xuICAgICAgICBsZXQgbWRhdEJ5dGVzID0gMDtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgaW5pdGlhbCBtZGF0IHNpemVcbiAgICAgICAgaWYgKG1wZWdSYXdUcmFjaykge1xuICAgICAgICAgICAgLy8gZm9yIHJhdyBtcGVnIGJ1ZmZlclxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIG1kYXRCeXRlcyA9IHRyYWNrLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZvciBmbXA0IG1kYXQgYm94XG4gICAgICAgICAgICBvZmZzZXQgPSA4OyAgLy8gc2l6ZSArIHR5cGVcbiAgICAgICAgICAgIG1kYXRCeXRlcyA9IDggKyB0cmFjay5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmlyc3RTYW1wbGVPcmlnaW5hbER0cyA9IHNhbXBsZXNbMF0uZHRzIC0gdGhpcy5fZHRzQmFzZTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZHRzQ29ycmVjdGlvblxuICAgICAgICBpZiAodGhpcy5fYXVkaW9OZXh0RHRzKSB7XG4gICAgICAgICAgICBkdHNDb3JyZWN0aW9uID0gZmlyc3RTYW1wbGVPcmlnaW5hbER0cyAtIHRoaXMuX2F1ZGlvTmV4dER0cztcbiAgICAgICAgfSBlbHNlIHsgIC8vIHRoaXMuX2F1ZGlvTmV4dER0cyA9PSB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICh0aGlzLl9hdWRpb1NlZ21lbnRJbmZvTGlzdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBkdHNDb3JyZWN0aW9uID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmlsbFNpbGVudEFmdGVyU2VlayAmJiAhdGhpcy5fdmlkZW9TZWdtZW50SW5mb0xpc3QuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdWRpb01ldGEub3JpZ2luYWxDb2RlYyAhPT0gJ21wMycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydFByZWZpeFNpbGVudEZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RTYW1wbGUgPSB0aGlzLl9hdWRpb1NlZ21lbnRJbmZvTGlzdC5nZXRMYXN0U2FtcGxlQmVmb3JlKGZpcnN0U2FtcGxlT3JpZ2luYWxEdHMpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0U2FtcGxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gKGZpcnN0U2FtcGxlT3JpZ2luYWxEdHMgLSAobGFzdFNhbXBsZS5vcmlnaW5hbER0cyArIGxhc3RTYW1wbGUuZHVyYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDw9IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgZXhwZWN0ZWREdHMgPSBsYXN0U2FtcGxlLmR0cyArIGxhc3RTYW1wbGUuZHVyYXRpb24gKyBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgZHRzQ29ycmVjdGlvbiA9IGZpcnN0U2FtcGxlT3JpZ2luYWxEdHMgLSBleHBlY3RlZER0cztcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBsYXN0U2FtcGxlID09IG51bGwsIGNhbm5vdCBmb3VuZFxuICAgICAgICAgICAgICAgICAgICBkdHNDb3JyZWN0aW9uID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChpbnNlcnRQcmVmaXhTaWxlbnRGcmFtZSkge1xuICAgICAgICAgICAgLy8gYWxpZ24gYXVkaW8gc2VnbWVudCBiZWdpbkR0cyB0byBtYXRjaCB3aXRoIGN1cnJlbnQgdmlkZW8gc2VnbWVudCdzIGJlZ2luRHRzXG4gICAgICAgICAgICBsZXQgZmlyc3RTYW1wbGVEdHMgPSBmaXJzdFNhbXBsZU9yaWdpbmFsRHRzIC0gZHRzQ29ycmVjdGlvbjtcbiAgICAgICAgICAgIGxldCB2aWRlb1NlZ21lbnQgPSB0aGlzLl92aWRlb1NlZ21lbnRJbmZvTGlzdC5nZXRMYXN0U2VnbWVudEJlZm9yZShmaXJzdFNhbXBsZU9yaWdpbmFsRHRzKTtcbiAgICAgICAgICAgIGlmICh2aWRlb1NlZ21lbnQgIT0gbnVsbCAmJiB2aWRlb1NlZ21lbnQuYmVnaW5EdHMgPCBmaXJzdFNhbXBsZUR0cykge1xuICAgICAgICAgICAgICAgIGxldCBzaWxlbnRVbml0ID0gQUFDLmdldFNpbGVudEZyYW1lKHRoaXMuX2F1ZGlvTWV0YS5vcmlnaW5hbENvZGVjLCB0aGlzLl9hdWRpb01ldGEuY2hhbm5lbENvdW50KTtcbiAgICAgICAgICAgICAgICBpZiAoc2lsZW50VW5pdCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZHRzID0gdmlkZW9TZWdtZW50LmJlZ2luRHRzO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2lsZW50RnJhbWVEdXJhdGlvbiA9IGZpcnN0U2FtcGxlRHRzIC0gdmlkZW9TZWdtZW50LmJlZ2luRHRzO1xuICAgICAgICAgICAgICAgICAgICBMb2cudih0aGlzLlRBRywgYEluc2VydFByZWZpeFNpbGVudEF1ZGlvOiBkdHM6ICR7ZHRzfSwgZHVyYXRpb246ICR7c2lsZW50RnJhbWVEdXJhdGlvbn1gKTtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlcy51bnNoaWZ0KHt1bml0OiBzaWxlbnRVbml0LCBkdHM6IGR0cywgcHRzOiBkdHN9KTtcbiAgICAgICAgICAgICAgICAgICAgbWRhdEJ5dGVzICs9IHNpbGVudFVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9ICAvLyBzaWxlbnRVbml0ID09IG51bGw6IENhbm5vdCBnZW5lcmF0ZSwgc2tpcFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRQcmVmaXhTaWxlbnRGcmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1wNFNhbXBsZXMgPSBbXTtcblxuICAgICAgICAvLyBDb3JyZWN0IGR0cyBmb3IgZWFjaCBzYW1wbGUsIGFuZCBjYWxjdWxhdGUgc2FtcGxlIGR1cmF0aW9uLiBUaGVuIG91dHB1dCB0byBtcDRTYW1wbGVzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNhbXBsZSA9IHNhbXBsZXNbaV07XG4gICAgICAgICAgICBsZXQgdW5pdCA9IHNhbXBsZS51bml0O1xuICAgICAgICAgICAgbGV0IG9yaWdpbmFsRHRzID0gc2FtcGxlLmR0cyAtIHRoaXMuX2R0c0Jhc2U7XG4gICAgICAgICAgICBsZXQgZHRzID0gb3JpZ2luYWxEdHMgLSBkdHNDb3JyZWN0aW9uO1xuXG4gICAgICAgICAgICBpZiAoZmlyc3REdHMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZmlyc3REdHMgPSBkdHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBzYW1wbGVEdXJhdGlvbiA9IDA7XG5cbiAgICAgICAgICAgIGlmIChpICE9PSBzYW1wbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dER0cyA9IHNhbXBsZXNbaSArIDFdLmR0cyAtIHRoaXMuX2R0c0Jhc2UgLSBkdHNDb3JyZWN0aW9uO1xuICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gbmV4dER0cyAtIGR0cztcbiAgICAgICAgICAgIH0gZWxzZSB7ICAvLyB0aGUgbGFzdCBzYW1wbGVcbiAgICAgICAgICAgICAgICBpZiAobXA0U2FtcGxlcy5sZW5ndGggPj0gMSkgeyAgLy8gdXNlIHNlY29uZCBsYXN0IHNhbXBsZSBkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IG1wNFNhbXBsZXNbbXA0U2FtcGxlcy5sZW5ndGggLSAxXS5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAgLy8gdGhlIG9ubHkgb25lIHNhbXBsZSwgdXNlIHJlZmVyZW5jZSBzYW1wbGUgZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSBNYXRoLmZsb29yKHJlZlNhbXBsZUR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBuZWVkRmlsbFNpbGVudEZyYW1lcyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHNpbGVudEZyYW1lcyA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIFNpbGVudCBmcmFtZSBnZW5lcmF0aW9uLCBpZiBsYXJnZSB0aW1lc3RhbXAgZ2FwIGRldGVjdGVkXG4gICAgICAgICAgICBpZiAoc2FtcGxlRHVyYXRpb24gPiByZWZTYW1wbGVEdXJhdGlvbiAqIDEuNSAmJiB0aGlzLl9hdWRpb01ldGEuY29kZWMgIT09ICdtcDMnKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBpbnNlcnQgc2lsZW50IGZyYW1lcyB0byBmaWxsIHRpbWVzdGFtcCBnYXBcbiAgICAgICAgICAgICAgICBuZWVkRmlsbFNpbGVudEZyYW1lcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IGRlbHRhID0gTWF0aC5hYnMoc2FtcGxlRHVyYXRpb24gLSByZWZTYW1wbGVEdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgbGV0IGZyYW1lQ291bnQgPSBNYXRoLmNlaWwoZGVsdGEgLyByZWZTYW1wbGVEdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnREdHMgPSBkdHMgKyByZWZTYW1wbGVEdXJhdGlvbjsgIC8vIE5vdGljZTogaW4gZmxvYXRcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuVEFHLCAnTGFyZ2UgYXVkaW8gdGltZXN0YW1wIGdhcCBkZXRlY3RlZCwgbWF5IGNhdXNlIEFWIHN5bmMgdG8gZHJpZnQuICcgK1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAnU2lsZW50IGZyYW1lcyB3aWxsIGJlIGdlbmVyYXRlZCB0byBhdm9pZCB1bnN5bmMuXFxuJyArXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgIGBkdHM6ICR7ZHRzICsgc2FtcGxlRHVyYXRpb259IG1zLCBleHBlY3RlZDogJHtkdHMgKyBNYXRoLnJvdW5kKHJlZlNhbXBsZUR1cmF0aW9uKX0gbXMsIGAgK1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICBgZGVsdGE6ICR7TWF0aC5yb3VuZChkZWx0YSl9IG1zLCBnZW5lcmF0ZTogJHtmcmFtZUNvdW50fSBmcmFtZXNgKTtcblxuICAgICAgICAgICAgICAgIGxldCBzaWxlbnRVbml0ID0gQUFDLmdldFNpbGVudEZyYW1lKHRoaXMuX2F1ZGlvTWV0YS5vcmlnaW5hbENvZGVjLCB0aGlzLl9hdWRpb01ldGEuY2hhbm5lbENvdW50KTtcbiAgICAgICAgICAgICAgICBpZiAoc2lsZW50VW5pdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuVEFHLCAnVW5hYmxlIHRvIGdlbmVyYXRlIHNpbGVudCBmcmFtZSBmb3IgJyArXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICBgJHt0aGlzLl9hdWRpb01ldGEub3JpZ2luYWxDb2RlY30gd2l0aCAke3RoaXMuX2F1ZGlvTWV0YS5jaGFubmVsQ291bnR9IGNoYW5uZWxzLCByZXBlYXQgbGFzdCBmcmFtZWApO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBlYXQgbGFzdCBmcmFtZVxuICAgICAgICAgICAgICAgICAgICBzaWxlbnRVbml0ID0gdW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2lsZW50RnJhbWVzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZyYW1lQ291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW50RHRzID0gTWF0aC5yb3VuZChjdXJyZW50RHRzKTsgIC8vIHJvdW5kIHRvIGludGVnZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbGVudEZyYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgcHJldmlvdXMgZnJhbWUgc2FtcGxlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXNGcmFtZSA9IHNpbGVudEZyYW1lc1tzaWxlbnRGcmFtZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0ZyYW1lLmR1cmF0aW9uID0gaW50RHRzIC0gcHJldmlvdXNGcmFtZS5kdHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyYW1lID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHRzOiBpbnREdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHM6IGludER0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0czogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXQ6IHNpbGVudFVuaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzaWxlbnRVbml0LmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogMCwgIC8vIHdhaXQgZm9yIG5leHQgc2FtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbER0czogb3JpZ2luYWxEdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRzT246IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2lsZW50RnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICBtZGF0Qnl0ZXMgKz0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHRzICs9IHJlZlNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGxhc3QgZnJhbWU6IGFsaWduIGVuZCB0aW1lIHRvIG5leHQgZnJhbWUgZHRzXG4gICAgICAgICAgICAgICAgbGV0IGxhc3RGcmFtZSA9IHNpbGVudEZyYW1lc1tzaWxlbnRGcmFtZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgbGFzdEZyYW1lLmR1cmF0aW9uID0gZHRzICsgc2FtcGxlRHVyYXRpb24gLSBsYXN0RnJhbWUuZHRzO1xuXG4gICAgICAgICAgICAgICAgLy8gc2lsZW50RnJhbWVzLmZvckVhY2goKGZyYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gICAgIExvZy53KHRoaXMuVEFHLCBgU2lsZW50QXVkaW86IGR0czogJHtmcmFtZS5kdHN9LCBkdXJhdGlvbjogJHtmcmFtZS5kdXJhdGlvbn1gKTtcbiAgICAgICAgICAgICAgICAvLyB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFNldCBjb3JyZWN0IHNhbXBsZSBkdXJhdGlvbiBmb3IgY3VycmVudCBmcmFtZVxuICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gTWF0aC5yb3VuZChyZWZTYW1wbGVEdXJhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1wNFNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZHRzOiBkdHMsXG4gICAgICAgICAgICAgICAgcHRzOiBkdHMsXG4gICAgICAgICAgICAgICAgY3RzOiAwLFxuICAgICAgICAgICAgICAgIHVuaXQ6IHNhbXBsZS51bml0LFxuICAgICAgICAgICAgICAgIHNpemU6IHNhbXBsZS51bml0LmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHNhbXBsZUR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRHRzOiBvcmlnaW5hbER0cyxcbiAgICAgICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZHNPbjogMSxcbiAgICAgICAgICAgICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgICAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChuZWVkRmlsbFNpbGVudEZyYW1lcykge1xuICAgICAgICAgICAgICAgIC8vIFNpbGVudCBmcmFtZXMgc2hvdWxkIGJlIGluc2VydGVkIGFmdGVyIHdyb25nLWR1cmF0aW9uIGZyYW1lXG4gICAgICAgICAgICAgICAgbXA0U2FtcGxlcy5wdXNoLmFwcGx5KG1wNFNhbXBsZXMsIHNpbGVudEZyYW1lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbGxvY2F0ZSBtZGF0Ym94XG4gICAgICAgIGlmIChtcGVnUmF3VHJhY2spIHtcbiAgICAgICAgICAgIC8vIGFsbG9jYXRlIGZvciByYXcgbXBlZyBidWZmZXJcbiAgICAgICAgICAgIG1kYXRib3ggPSBuZXcgVWludDhBcnJheShtZGF0Qnl0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYWxsb2NhdGUgZm9yIGZtcDQgbWRhdCBib3hcbiAgICAgICAgICAgIG1kYXRib3ggPSBuZXcgVWludDhBcnJheShtZGF0Qnl0ZXMpO1xuICAgICAgICAgICAgLy8gc2l6ZSBmaWVsZFxuICAgICAgICAgICAgbWRhdGJveFswXSA9IChtZGF0Qnl0ZXMgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICBtZGF0Ym94WzFdID0gKG1kYXRCeXRlcyA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIG1kYXRib3hbMl0gPSAobWRhdEJ5dGVzID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgbWRhdGJveFszXSA9IChtZGF0Qnl0ZXMpICYgMHhGRjtcbiAgICAgICAgICAgIC8vIHR5cGUgZmllbGQgKGZvdXJDQylcbiAgICAgICAgICAgIG1kYXRib3guc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyaXRlIHNhbXBsZXMgaW50byBtZGF0Ym94XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXA0U2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHVuaXQgPSBtcDRTYW1wbGVzW2ldLnVuaXQ7XG4gICAgICAgICAgICBtZGF0Ym94LnNldCh1bml0LCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsYXRlc3QgPSBtcDRTYW1wbGVzW21wNFNhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGxhc3REdHMgPSBsYXRlc3QuZHRzICsgbGF0ZXN0LmR1cmF0aW9uO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhsYXRlc3QuZHRzLGxhdGVzdC5vcmlnaW5hbER0cyk7XG4gICAgICAgIC8vIGxhc3REdHMgPSBsYXRlc3Qub3JpZ2luYWxEdHMgKyBsYXRlc3QuZHVyYXRpb247XG4gICAgICAgIHRoaXMuX2F1ZGlvTmV4dER0cyA9IGxhc3REdHM7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdkdHNDb3JyZWN0aW9uJyxkdHNDb3JyZWN0aW9uLCdmaXJzdFNhbXBsZU9yaWdpbmFsRHRzJyxmaXJzdFNhbXBsZU9yaWdpbmFsRHRzLCdfZHRzQmFzZScsdGhpcy5fZHRzQmFzZSwndGhpcy5fYXVkaW9OZXh0RHRzJyx0aGlzLl9hdWRpb05leHREdHMsJ2xhdGVzdC5kdHMnLGxhdGVzdC5kdHMsbGF0ZXN0Lm9yaWdpbmFsRHRzKVxuXG4gICAgICAgIC8vIGZpbGwgbWVkaWEgc2VnbWVudCBpbmZvICYgYWRkIHRvIGluZm8gbGlzdFxuICAgICAgICBsZXQgaW5mbyA9IG5ldyBNZWRpYVNlZ21lbnRJbmZvKCk7XG4gICAgICAgIGluZm8uYmVnaW5EdHMgPSBmaXJzdER0cztcbiAgICAgICAgaW5mby5lbmREdHMgPSBsYXN0RHRzO1xuICAgICAgICBpbmZvLmJlZ2luUHRzID0gZmlyc3REdHM7XG4gICAgICAgIGluZm8uZW5kUHRzID0gbGFzdER0cztcbiAgICAgICAgaW5mby5vcmlnaW5hbEJlZ2luRHRzID0gbXA0U2FtcGxlc1swXS5vcmlnaW5hbER0cztcbiAgICAgICAgaW5mby5vcmlnaW5hbEVuZER0cyA9IGxhdGVzdC5vcmlnaW5hbER0cyArIGxhdGVzdC5kdXJhdGlvbjtcbiAgICAgICAgaW5mby5maXJzdFNhbXBsZSA9IG5ldyBTYW1wbGVJbmZvKG1wNFNhbXBsZXNbMF0uZHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXA0U2FtcGxlc1swXS5wdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcDRTYW1wbGVzWzBdLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXA0U2FtcGxlc1swXS5vcmlnaW5hbER0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgaW5mby5sYXN0U2FtcGxlID0gbmV3IFNhbXBsZUluZm8obGF0ZXN0LmR0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZXN0LnB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZXN0LmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXRlc3Qub3JpZ2luYWxEdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0xpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvU2VnbWVudEluZm9MaXN0LmFwcGVuZChpbmZvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNrLnNhbXBsZXMgPSBtcDRTYW1wbGVzO1xuICAgICAgICB0cmFjay5zZXF1ZW5jZU51bWJlcisrO1xuICAgICAgICAvLyB0cmFjay5zZXF1ZW5jZU51bWJlciArPSB0cmFjay5hZGRjb2VmZmljaWVudDtcbiAgICAgICAgbGV0IG1vb2Zib3ggPSBudWxsO1xuXG4gICAgICAgIGlmIChtcGVnUmF3VHJhY2spIHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGVtcHR5IGJ1ZmZlciwgYmVjYXVzZSB1c2VsZXNzIGZvciByYXcgbXBlZ1xuICAgICAgICAgICAgbW9vZmJveCA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBtb29mIGZvciBmbXA0IHNlZ21lbnRcbiAgICAgICAgICAgIG1vb2Zib3ggPSBNUDQubW9vZih0cmFjaywgZmlyc3REdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgICAgICB0cmFjay5sZW5ndGggPSAwO1xuXG4gICAgICAgIGxldCBzZWdtZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuX21lcmdlQm94ZXMobW9vZmJveCwgbWRhdGJveCkuYnVmZmVyLFxuICAgICAgICAgICAgc2FtcGxlQ291bnQ6IG1wNFNhbXBsZXMubGVuZ3RoLFxuICAgICAgICAgICAgaW5mbzogaW5mb1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtcGVnUmF3VHJhY2sgJiYgZmlyc3RTZWdtZW50QWZ0ZXJTZWVrKSB7XG4gICAgICAgICAgICAvLyBGb3IgTVBFRyBhdWRpbyBzdHJlYW0gaW4gTVNFLCBpZiBzZWVraW5nIG9jY3VycmVkLCBiZWZvcmUgYXBwZW5kaW5nIG5ldyBidWZmZXJcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgZXhwbGljaXRseSBzZXQgdGltZXN0YW1wT2Zmc2V0IHRvIHRoZSBkZXNpcmVkIHBvaW50IGluIHRpbWVsaW5lIGZvciBtcGVnIFNvdXJjZUJ1ZmZlci5cbiAgICAgICAgICAgIHNlZ21lbnQudGltZXN0YW1wT2Zmc2V0ID0gZmlyc3REdHM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vbk1lZGlhU2VnbWVudCgnYXVkaW8nLCBzZWdtZW50KTtcbiAgICB9XG5cbiAgICBfcmVtdXhWaWRlbyh2aWRlb1RyYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLl92aWRlb01ldGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRyYWNrID0gdmlkZW9UcmFjaztcbiAgICAgICAgbGV0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgICAgICBsZXQgZHRzQ29ycmVjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGZpcnN0RHRzID0gLTEsIGxhc3REdHMgPSAtMTtcbiAgICAgICAgbGV0IGZpcnN0UHRzID0gLTEsIGxhc3RQdHMgPSAtMTtcblxuICAgICAgICBpZiAoIXNhbXBsZXMgfHwgc2FtcGxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvZmZzZXQgPSA4O1xuICAgICAgICBsZXQgbWRhdEJ5dGVzID0gOCArIHZpZGVvVHJhY2subGVuZ3RoO1xuICAgICAgICBsZXQgbWRhdGJveCA9IG5ldyBVaW50OEFycmF5KG1kYXRCeXRlcyk7XG4gICAgICAgIG1kYXRib3hbMF0gPSAobWRhdEJ5dGVzID4+PiAyNCkgJiAweEZGO1xuICAgICAgICBtZGF0Ym94WzFdID0gKG1kYXRCeXRlcyA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgbWRhdGJveFsyXSA9IChtZGF0Qnl0ZXMgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgIG1kYXRib3hbM10gPSAobWRhdEJ5dGVzKSAmIDB4RkY7XG4gICAgICAgIG1kYXRib3guc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcblxuICAgICAgICBsZXQgZmlyc3RTYW1wbGVPcmlnaW5hbER0cyA9IHNhbXBsZXNbMF0uZHRzIC0gdGhpcy5fZHRzQmFzZTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZHRzQ29ycmVjdGlvblxuICAgICAgICBpZiAodGhpcy5fdmlkZW9OZXh0RHRzKSB7XG4gICAgICAgICAgICBkdHNDb3JyZWN0aW9uID0gZmlyc3RTYW1wbGVPcmlnaW5hbER0cyAtIHRoaXMuX3ZpZGVvTmV4dER0cztcbiAgICAgICAgfSBlbHNlIHsgIC8vIHRoaXMuX3ZpZGVvTmV4dER0cyA9PSB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICh0aGlzLl92aWRlb1NlZ21lbnRJbmZvTGlzdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBkdHNDb3JyZWN0aW9uID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RTYW1wbGUgPSB0aGlzLl92aWRlb1NlZ21lbnRJbmZvTGlzdC5nZXRMYXN0U2FtcGxlQmVmb3JlKGZpcnN0U2FtcGxlT3JpZ2luYWxEdHMpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0U2FtcGxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gKGZpcnN0U2FtcGxlT3JpZ2luYWxEdHMgLSAobGFzdFNhbXBsZS5vcmlnaW5hbER0cyArIGxhc3RTYW1wbGUuZHVyYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDw9IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgZXhwZWN0ZWREdHMgPSBsYXN0U2FtcGxlLmR0cyArIGxhc3RTYW1wbGUuZHVyYXRpb24gKyBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgZHRzQ29ycmVjdGlvbiA9IGZpcnN0U2FtcGxlT3JpZ2luYWxEdHMgLSBleHBlY3RlZER0cztcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBsYXN0U2FtcGxlID09IG51bGwsIGNhbm5vdCBmb3VuZFxuICAgICAgICAgICAgICAgICAgICBkdHNDb3JyZWN0aW9uID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW5mbyA9IG5ldyBNZWRpYVNlZ21lbnRJbmZvKCk7XG4gICAgICAgIGxldCBtcDRTYW1wbGVzID0gW107XG5cbiAgICAgICAgLy8gQ29ycmVjdCBkdHMgZm9yIGVhY2ggc2FtcGxlLCBhbmQgY2FsY3VsYXRlIHNhbXBsZSBkdXJhdGlvbi4gVGhlbiBvdXRwdXQgdG8gbXA0U2FtcGxlc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgICAgICAgbGV0IG9yaWdpbmFsRHRzID0gc2FtcGxlLmR0cyAtIHRoaXMuX2R0c0Jhc2U7XG4gICAgICAgICAgICBsZXQgaXNLZXlmcmFtZSA9IHNhbXBsZS5pc0tleWZyYW1lO1xuICAgICAgICAgICAgbGV0IGR0cyA9IG9yaWdpbmFsRHRzIC0gZHRzQ29ycmVjdGlvbjtcbiAgICAgICAgICAgIGxldCBjdHMgPSBzYW1wbGUuY3RzO1xuICAgICAgICAgICAgbGV0IHB0cyA9IGR0cyArIGN0cztcblxuICAgICAgICAgICAgaWYgKGZpcnN0RHRzID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGZpcnN0RHRzID0gZHRzO1xuICAgICAgICAgICAgICAgIGZpcnN0UHRzID0gcHRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc2FtcGxlRHVyYXRpb24gPSAwO1xuXG4gICAgICAgICAgICBpZiAoaSAhPT0gc2FtcGxlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHREdHMgPSBzYW1wbGVzW2kgKyAxXS5kdHMgLSB0aGlzLl9kdHNCYXNlIC0gZHRzQ29ycmVjdGlvbjtcbiAgICAgICAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IG5leHREdHMgLSBkdHM7XG4gICAgICAgICAgICB9IGVsc2UgeyAgLy8gdGhlIGxhc3Qgc2FtcGxlXG4gICAgICAgICAgICAgICAgaWYgKG1wNFNhbXBsZXMubGVuZ3RoID49IDEpIHsgIC8vIHVzZSBzZWNvbmQgbGFzdCBzYW1wbGUgZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSBtcDRTYW1wbGVzW21wNFNhbXBsZXMubGVuZ3RoIC0gMV0uZHVyYXRpb247XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgIC8vIHRoZSBvbmx5IG9uZSBzYW1wbGUsIHVzZSByZWZlcmVuY2Ugc2FtcGxlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gTWF0aC5mbG9vcih0aGlzLl92aWRlb01ldGEucmVmU2FtcGxlRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzS2V5ZnJhbWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3luY1BvaW50ID0gbmV3IFNhbXBsZUluZm8oZHRzLCBwdHMsIHNhbXBsZUR1cmF0aW9uLCBzYW1wbGUuZHRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzeW5jUG9pbnQuZmlsZXBvc2l0aW9uID0gc2FtcGxlLmZpbGVwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBpbmZvLmFwcGVuZFN5bmNQb2ludChzeW5jUG9pbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtcDRTYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGR0czogZHRzLFxuICAgICAgICAgICAgICAgIHB0czogcHRzLFxuICAgICAgICAgICAgICAgIGN0czogY3RzLFxuICAgICAgICAgICAgICAgIHVuaXRzOiBzYW1wbGUudW5pdHMsXG4gICAgICAgICAgICAgICAgc2l6ZTogc2FtcGxlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpc0tleWZyYW1lOiBpc0tleWZyYW1lLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBzYW1wbGVEdXJhdGlvbixcbiAgICAgICAgICAgICAgICBvcmlnaW5hbER0czogb3JpZ2luYWxEdHMsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICBkZXBlbmRzT246IGlzS2V5ZnJhbWUgPyAyIDogMSxcbiAgICAgICAgICAgICAgICAgICAgaXNEZXBlbmRlZE9uOiBpc0tleWZyYW1lID8gMSA6IDAsXG4gICAgICAgICAgICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICAgICAgICAgICAgICAgIGlzTm9uU3luYzogaXNLZXlmcmFtZSA/IDAgOiAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXcml0ZSBzYW1wbGVzIGludG8gbWRhdGJveFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1wNFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB1bml0cyA9IG1wNFNhbXBsZXNbaV0udW5pdHM7XG4gICAgICAgICAgICB3aGlsZSAodW5pdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHVuaXQgPSB1bml0cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gdW5pdC5kYXRhO1xuICAgICAgICAgICAgICAgIG1kYXRib3guc2V0KGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsYXRlc3QgPSBtcDRTYW1wbGVzW21wNFNhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGxhc3REdHMgPSBsYXRlc3QuZHRzICsgbGF0ZXN0LmR1cmF0aW9uO1xuICAgICAgICAvLyBsYXN0RHRzID0gbGF0ZXN0Lm9yaWdpbmFsRHRzICsgbGF0ZXN0LmR1cmF0aW9uO1xuICAgICAgICBsYXN0UHRzID0gbGF0ZXN0LnB0cyArIGxhdGVzdC5kdXJhdGlvbjtcbiAgICAgICAgdGhpcy5fdmlkZW9OZXh0RHRzID0gbGFzdER0cztcblxuICAgICAgICAvLyBmaWxsIG1lZGlhIHNlZ21lbnQgaW5mbyAmIGFkZCB0byBpbmZvIGxpc3RcbiAgICAgICAgaW5mby5iZWdpbkR0cyA9IGZpcnN0RHRzO1xuICAgICAgICBpbmZvLmVuZER0cyA9IGxhc3REdHM7XG4gICAgICAgIGluZm8uYmVnaW5QdHMgPSBmaXJzdFB0cztcbiAgICAgICAgaW5mby5lbmRQdHMgPSBsYXN0UHRzO1xuICAgICAgICBpbmZvLm9yaWdpbmFsQmVnaW5EdHMgPSBtcDRTYW1wbGVzWzBdLm9yaWdpbmFsRHRzO1xuICAgICAgICBpbmZvLm9yaWdpbmFsRW5kRHRzID0gbGF0ZXN0Lm9yaWdpbmFsRHRzICsgbGF0ZXN0LmR1cmF0aW9uO1xuICAgICAgICBpbmZvLmZpcnN0U2FtcGxlID0gbmV3IFNhbXBsZUluZm8obXA0U2FtcGxlc1swXS5kdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcDRTYW1wbGVzWzBdLnB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wNFNhbXBsZXNbMF0uZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcDRTYW1wbGVzWzBdLm9yaWdpbmFsRHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXA0U2FtcGxlc1swXS5pc0tleWZyYW1lKTtcbiAgICAgICAgaW5mby5sYXN0U2FtcGxlID0gbmV3IFNhbXBsZUluZm8obGF0ZXN0LmR0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZXN0LnB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZXN0LmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXRlc3Qub3JpZ2luYWxEdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhdGVzdC5pc0tleWZyYW1lKTtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0xpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvU2VnbWVudEluZm9MaXN0LmFwcGVuZChpbmZvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNrLnNhbXBsZXMgPSBtcDRTYW1wbGVzO1xuICAgICAgICB0cmFjay5zZXF1ZW5jZU51bWJlcisrO1xuICAgICAgICAvLyB0cmFjay5zZXF1ZW5jZU51bWJlciArPSB0cmFjay5hZGRjb2VmZmljaWVudDtcblxuICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciBjaHJvbWUgPCA1MDogZm9yY2UgZmlyc3Qgc2FtcGxlIGFzIGEgcmFuZG9tIGFjY2VzcyBwb2ludFxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5NDEyXG4gICAgICAgIGlmICh0aGlzLl9mb3JjZUZpcnN0SURSKSB7XG4gICAgICAgICAgICBsZXQgZmxhZ3MgPSBtcDRTYW1wbGVzWzBdLmZsYWdzO1xuICAgICAgICAgICAgZmxhZ3MuZGVwZW5kc09uID0gMjtcbiAgICAgICAgICAgIGZsYWdzLmlzTm9uU3luYyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbW9vZmJveCA9IE1QNC5tb29mKHRyYWNrLCBmaXJzdER0cyk7XG4gICAgICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICAgICAgdHJhY2subGVuZ3RoID0gMDtcblxuICAgICAgICB0aGlzLl9vbk1lZGlhU2VnbWVudCgndmlkZW8nLCB7XG4gICAgICAgICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5fbWVyZ2VCb3hlcyhtb29mYm94LCBtZGF0Ym94KS5idWZmZXIsXG4gICAgICAgICAgICBzYW1wbGVDb3VudDogbXA0U2FtcGxlcy5sZW5ndGgsXG4gICAgICAgICAgICBpbmZvOiBpbmZvXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9tZXJnZUJveGVzKG1vb2YsIG1kYXQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KG1vb2YuYnl0ZUxlbmd0aCArIG1kYXQuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJlc3VsdC5zZXQobW9vZiwgMCk7XG4gICAgICAgIHJlc3VsdC5zZXQobWRhdCwgbW9vZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbn1cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmNsYXNzIGZsdjJmbXA0IHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZmx2MmZtcDQuXG4gICAgICogY29uZmlnIOmHjOmdouaciV9pc0xpdmXlsZ7mgKcs5piv5ZCm5piv55u05pKtXG4gICAgICogQHBhcmFtIHthbnl9IGNvbmZpZ1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIGZsdjJmbXA0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IHsgX2lzTGl2ZTogZmFsc2UgfTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gT2JqZWN0LmFzc2lnbih0aGlzLl9jb25maWcsIGNvbmZpZyk7XG5cbiAgICAgICAgLy8g5aSW6YOo5pa55rOV6LWL5YC8XG4gICAgICAgIHRoaXMub25Jbml0U2VnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMub25NZWRpYVNlZ21lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm9uTWVkaWFJbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZWVrQ2FsbEJhY2sgPSBudWxsO1xuXG4gICAgICAgIC8vIOWGhemDqOS9v+eUqFxuICAgICAgICB0aGlzLmxvYWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZ0eXBfbW9vdiA9IG51bGw7Ly/ljZXot69cblxuICAgICAgICB0aGlzLmZ0eXBfbW9vdl92PW51bGw7Ly/lj4zot6/op4bpopFcbiAgICAgICAgdGhpcy5mdHlwX21vb3ZfYT1udWxsOy8v5Y+M6Lev6Z+z6aKRXG4gICAgICAgIHRoaXMubWV0YVN1Y2NSdW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXRhcyA9IFtdO1xuICAgICAgICB0aGlzLnBhcnNlQ2h1bmsgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc1ZpZGVvID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzQXVkaW8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZXJyb3I9bnVsbDtcbiAgICAgICAgLy8g5Li05pe26K6w5b2Vc2Vla+aXtumXtFxuICAgICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZVNlZWtQb2ludCA9IC0xO1xuXG4gICAgICAgIC8vIOS4tOaXtuiusOW9lWZsduaVsOaNrui1t+Wni+aXtumXtFxuICAgICAgICB0aGlzLl90ZW1wQmFzZVRpbWUgPSAwO1xuXG4gICAgICAgIC8vIOWkhOeQhmZsduaVsOaNruWFpeWPo1xuICAgICAgICB0aGlzLnNldGZsdkJhc2UgPSB0aGlzLnNldGZsdkJhc2VmcmlzdDtcblxuICAgICAgICB0YWdkZW11eC5fb25UcmFja01ldGFkYXRhID0gdGhpcy5NZXRhZGF0YS5iaW5kKHRoaXMpO1xuICAgICAgICB0YWdkZW11eC5fb25NZWRpYUluZm8gPSB0aGlzLm1ldGFTdWNjLmJpbmQodGhpcyk7XG4gICAgICAgIHRhZ2RlbXV4Ll9vbkRhdGFBdmFpbGFibGUgPSB0aGlzLm9uRGF0YUF2YWlsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0YWdkZW11eC5fb25FcnJvcj10aGlzLmVycm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubTRtb2YgPSBuZXcgTVA0UmVtdXhlcih0aGlzLl9jb25maWcpO1xuICAgICAgICB0aGlzLm00bW9mLm9uTWVkaWFTZWdtZW50ID0gdGhpcy5vbk1kaWFTZWdtZW50LmJpbmQodGhpcyk7XG4gICAgfVxuICAgIHNlZWsoYmFzZVRpbWUpIHtcbiAgICAgICAgdGhpcy5zZXRmbHZCYXNlID0gdGhpcy5zZXRmbHZCYXNlZnJpc3Q7XG4gICAgICAgIGlmIChiYXNlVGltZSA9PSB1bmRlZmluZWQgfHwgYmFzZVRpbWUgPT0gMCkge1xuICAgICAgICAgICAgYmFzZVRpbWUgPSAwO1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmVTZWVrUG9pbnQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdGVtcEJhc2VUaW1lICE9IGJhc2VUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLl90ZW1wQmFzZVRpbWUgPSBiYXNlVGltZTtcbiAgICAgICAgICAgIHRhZ2RlbXV4Ll90aW1lc3RhbXBCYXNlID0gYmFzZVRpbWU7XG4gICAgICAgICAgICB0aGlzLm00bW9mLnNlZWsoYmFzZVRpbWUpO1xuICAgICAgICAgICAgdGhpcy5tNG1vZi5pbnNlcnREaXNjb250aW51aXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZVNlZWtQb2ludCA9IGJhc2VUaW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5LiN6KaB5Li75Yqo6LCD55So6L+Z5Liq5o6l5Y+jISEhISEhISEhISEhISEhISEhISEhISEhISEhIVxuICAgICAqIOesrOS4gOasoeaOpeWPl+aVsOaNrizlkoxzZWVr5pe25YCZ5o6l5Y+X5pWw5o2u5YWl5Y+jLFxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGFycmF5YnVmZlxuICAgICAqIEBwYXJhbSB7YW55fSBiYXNlVGltZVxuICAgICAqIEByZXR1cm5zXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZmx2MmZtcDRcbiAgICAgKi9cbiAgICBzZXRmbHZCYXNlZnJpc3QoYXJyYXlidWZmLCBiYXNlVGltZSkge1xuXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZmx2cGFyc2Uuc2V0Rmx2KG5ldyBVaW50OEFycmF5KGFycmF5YnVmZikpO1xuICAgICAgICB9IGNhdGNoIChlcnJvciQkMSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvciQkMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZmx2cGFyc2UuYXJyVGFnLmxlbmd0aD09MClyZXR1cm4gb2Zmc2V0O1xuICAgICAgICBpZihmbHZwYXJzZS5hcnJUYWdbMF0udHlwZSE9MTgpe1xuICAgICAgICAgICAgaWYodGhpcy5lcnJvcil0aGlzLmVycm9yKG5ldyBFcnJvcignd2l0aG91dCBtZXRhZGF0YSB0YWcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsdnBhcnNlLmFyclRhZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0YWdkZW11eC5oYXNBdWRpbz10aGlzLmhhc0F1ZGlvID0gZmx2cGFyc2UuX2hhc0F1ZGlvO1xuICAgICAgICAgICAgdGFnZGVtdXguaGFzVmlkZW89dGhpcy5oYXNWaWRlbyA9IGZsdnBhcnNlLl9oYXNWaWRlbztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMuX3RlbXBCYXNlVGltZSAhPSAwICYmIHRoaXMuX3RlbXBCYXNlVGltZSA9PSBmbHZwYXJzZS5hcnJUYWdbMF0uZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgICAgdGFnZGVtdXguX3RpbWVzdGFtcEJhc2UgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0YWdkZW11eC5tb29mVGFnKGZsdnBhcnNlLmFyclRhZyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvciQkMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3IkJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRmbHZCYXNlID0gdGhpcy5zZXRmbHZCYXNlVXN1YWxseTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5LiN6KaB5Li75Yqo6LCD55So6L+Z5Liq5o6l5Y+jISEhISEhISEhISEhISEhISEhISEhISEhISEhIVxuICAgICAqIOWQjue7reaOpeWPl+aVsOaNruaOpeWPo1xuICAgICAqIEBwYXJhbSB7YW55fSBhcnJheWJ1ZmZcbiAgICAgKiBAcGFyYW0ge2FueX0gYmFzZVRpbWVcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIGZsdjJmbXA0XG4gICAgICovXG4gICAgc2V0Zmx2QmFzZVVzdWFsbHkoYXJyYXlidWZmLCBiYXNlVGltZSkge1xuICAgICAgICBsZXQgb2Zmc2V0ID0wO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZmx2cGFyc2Uuc2V0Rmx2KG5ldyBVaW50OEFycmF5KGFycmF5YnVmZikpO1xuICAgICAgICB9IGNhdGNoIChlcnJvciQkMSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvciQkMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsdnBhcnNlLmFyclRhZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRhZ2RlbXV4Lm1vb2ZUYWcoZmx2cGFyc2UuYXJyVGFnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yJCQxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvciQkMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOS4jeimgeS4u+WKqOiwg+eUqOi/meS4quaOpeWPoyEhISEhISEhISEhISEhISEhISEhISEhISEhISFcbiAgICAgKiBtb29m5Zue6LCDXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gdHJhY2tcbiAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBmbHYyZm1wNFxuICAgICAqL1xuICAgIG9uTWRpYVNlZ21lbnQodHJhY2ssIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub25NZWRpYVNlZ21lbnQpIHtcbiAgICAgICAgICAgIHRoaXMub25NZWRpYVNlZ21lbnQodHJhY2ssbmV3IFVpbnQ4QXJyYXkodmFsdWUuZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nUmVzb2x2ZVNlZWtQb2ludCAhPSAtMSAmJiB0cmFjayA9PSAndmlkZW8nKSB7XG4gICAgICAgICAgICBsZXQgc2Vla3BvaW50ID0gdGhpcy5fcGVuZGluZ1Jlc29sdmVTZWVrUG9pbnQ7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZVNlZWtQb2ludCA9IC0xO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Vla0NhbGxCYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWVrQ2FsbEJhY2soc2Vla3BvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICog6Z+z6aKR5ZKM6KeG6aKR55qE5Yid5aeL5YyWdGFnXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gdHlwZVxuICAgICAqIEBwYXJhbSB7YW55fSBtZXRhXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZmx2MmZtcDRcbiAgICAgKi9cbiAgICBNZXRhZGF0YSh0eXBlLCBtZXRhKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0YXMucHVzaChbJ3ZpZGVvJyxtZXRhXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tNG1vZi5fdmlkZW9NZXRhID0gbWV0YTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNWaWRlbyAmJiAhdGhpcy5oYXNBdWRpbykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFTdWNjKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhcy5wdXNoKFsnYXVkaW8nLG1ldGFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLm00bW9mLl9hdWRpb01ldGEgPSBtZXRhO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNWaWRlbyAmJiB0aGlzLmhhc0F1ZGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YVN1Y2MoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNWaWRlbyAmJiB0aGlzLmhhc0F1ZGlvICAmJiB0aGlzLm1ldGFzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMubWV0YVN1Y2MoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1ldGFkYXRh6Kej6K+75oiQ5Yqf5ZCO6Kem5Y+R5Y+K56ys5LiA5Liq6KeG6aKRdGFn5ZKM56ys5LiA5Liq6Z+z6aKRdGFnXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gbWlcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIGZsdjJmbXA0XG4gICAgICovXG4gICAgbWV0YVN1Y2MobWkpIHtcbiAgICAgICAgaWYgKHRoaXMub25NZWRpYUluZm8pIHtcbiAgICAgICAgICAgIHRoaXMub25NZWRpYUluZm8obWl8fHRhZ2RlbXV4Ll9tZWRpYUluZm8sIHsgaGFzQXVkaW86IHRoaXMuaGFzQXVkaW8sIGhhc1ZpZGVvOiB0aGlzLmhhc1ZpZGVvIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIOiOt+WPlmZ0eXDlkoxtb292XG4gICAgICAgIGlmICh0aGlzLm1ldGFzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGFTdWNjUnVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZihtaSlyZXR1cm47XG4gICAgICAgIGlmKHRoaXMubWV0YXMubGVuZ3RoPjEpe1xuICAgICAgICAgICAgLy8gdGhpcy5mdHlwX21vb3Zfdj1cbiAgICAgICAgICAgIHRoaXMubWV0YXMubWFwKGl0ZW09PntcbiAgICAgICAgICAgICAgICBpZihpdGVtWzBdPT0ndmlkZW8nKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mdHlwX21vb3Zfdj1NUDQuZ2VuZXJhdGVJbml0U2VnbWVudChbaXRlbVsxXV0pO1xuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZ0eXBfbW9vdl9hPU1QNC5nZW5lcmF0ZUluaXRTZWdtZW50KFtpdGVtWzFdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5mdHlwX21vb3YgPSBNUDQuZ2VuZXJhdGVJbml0U2VnbWVudChbdGhpcy5tZXRhc1swXVsxXV0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5vbkluaXRTZWdtZW50ICYmIHRoaXMubG9hZG1ldGFkYXRhID09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZnR5cF9tb292KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMub25Jbml0U2VnbWVudCh0aGlzLmZ0eXBfbW9vdik7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSW5pdFNlZ21lbnQodGhpcy5mdHlwX21vb3Zfdix0aGlzLmZ0eXBfbW9vdl9hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9hZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uRGF0YUF2YWlsYWJsZShhdWRpb3RyYWNrLCB2aWRlb3RyYWNrKSB7XG4gICAgICAgIC8vIHRoaXMubTRtb2YucmVtdXgoYXVkaW90cmFjaywgdmlkZW90cmFjayk7XG5cbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgdGhpcy5tNG1vZi5yZW11eChhdWRpb3RyYWNrLCB2aWRlb3RyYWNrKTtcbiAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOS8oOWFpWZsdueahOS6jOi/m+WItuaVsOaNrlxuICAgICAqIOe7n+S4gOWFpeWPo1xuICAgICAqIEBwYXJhbSB7YW55fSBhcnJheWJ1ZmZcbiAgICAgKiBAcGFyYW0ge2FueX0gYmFzZVRpbWUgZmx25pWw5o2u5byA5aeL5pe26Ze0XG4gICAgICogQHJldHVybnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBmbHYyZm1wNFxuICAgICAqL1xuICAgIHNldGZsdihhcnJheWJ1ZmYsIGJhc2VUaW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldGZsdkJhc2UoYXJyYXlidWZmLCBiYXNlVGltZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiDmnKzlnLDosIPor5Xku6PnoIEs5LiN55So55CG5LyaXG4gICAgICogQHBhcmFtIHthbnl9IGFycmF5YnVmZlxuICAgICAqIEByZXR1cm5zXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZmx2MmZtcDRcbiAgICAgKi9cbiAgICBzZXRmbHZsb2MoYXJyYXlidWZmKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGZsdnBhcnNlLnNldEZsdihuZXcgVWludDhBcnJheShhcnJheWJ1ZmYpKTtcblxuICAgICAgICBpZiAoZmx2cGFyc2UuYXJyVGFnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmbHZwYXJzZS5hcnJUYWc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogXG4gICAgICogIOW8guW4uOaKm+WHuuWkhOeQhlxuICAgICAqIEBwYXJhbSB7YW55fSBlIFxuICAgICAqIEBtZW1iZXJvZiBmbHYyZm1wNFxuICAgICAqL1xuICAgIGVycm9yKGUpIHtcbiAgICAgICAgaWYodGhpcy5fZXJyb3Ipe1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICog5bCB6KOF55qE5a+55aSW57G7LOacieS6m+aWueazleS4jeaDs+WvueWkluaatOmcsizmiYDku6XlsIHoo4Xov5nkuYjkuIDkuKrnsbtcbiAqXG4gKiBAY2xhc3MgZm9yZWlnblxuICovXG5jbGFzcyBmb3JlaWduIGV4dGVuZHMgQ3VzdEV2ZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mMm0gPSBuZXcgZmx2MmZtcDQoY29uZmlnKTtcbiAgICAgICAgdGhpcy5mMm0uX2Vycm9yPXRoaXMuZXJyb3I7XG4gICAgICAgIC8vIOWklumDqOaWueazlei1i+WAvFxuICAgICAgICB0aGlzLl9vbkluaXRTZWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb25NZWRpYVNlZ21lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9vbk1lZGlhSW5mbyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NlZWtDYWxsQmFjayA9IG51bGw7XG4gICAgfVxuICAgIGVycm9yKGUpe1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJyxlLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIOi3s+i9rFxuICAgICAqIEBwYXJhbSB7YW55fSBiYXNldGltZSAg6Lez6L2s5pe26Ze0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZm9yZWlnblxuICAgICAqL1xuICAgIHNlZWsoYmFzZXRpbWUpIHtcbiAgICAgICAgdGhpcy5mMm0uc2VlayhiYXNldGltZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Lyg5YWlZmx255qE5LqM6L+b5Yi25pWw5o2uXG4gICAgICog57uf5LiA5YWl5Y+jXG4gICAgICogQHBhcmFtIHthbnl9IGFycmF5YnVmZlxuICAgICAqIEByZXR1cm5zXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZmx2MmZtcDRcbiAgICAgKi9cbiAgICBzZXRmbHYoYXJyYXlidWZmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmYybS5zZXRmbHYoYXJyYXlidWZmLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIOacrOWcsOiwg+ivleS7o+eggSzkuI3nlKjnkIbkvJpcbiAgICAgKiBAcGFyYW0ge2FueX0gYXJyYXlidWZmXG4gICAgICogQHJldHVybnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBmbHYyZm1wNFxuICAgICAqL1xuICAgIHNldGZsdmxvYyhhcnJheWJ1ZmYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZjJtLnNldGZsdmxvYyhhcnJheWJ1ZmYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOi1i+WAvOWIneWni+WMlnNlZ+aOpeWPl+aWueazlVxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZm9yZWlnblxuICAgICAqL1xuICAgIHNldCBvbkluaXRTZWdtZW50KGZ1bikge1xuICAgICAgICB0aGlzLl9vbkluaXRTZWdtZW50ID0gZnVuO1xuICAgICAgICB0aGlzLmYybS5vbkluaXRTZWdtZW50ID0gZnVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOi1i+WAvG1vb2bmjqXlj5fmlrnms5VcbiAgICAgKlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIGZvcmVpZ25cbiAgICAgKi9cbiAgICBzZXQgb25NZWRpYVNlZ21lbnQoZnVuKSB7XG4gICAgICAgIHRoaXMuX29uTWVkaWFTZWdtZW50ID0gZnVuO1xuICAgICAgICB0aGlzLmYybS5vbk1lZGlhU2VnbWVudCA9IGZ1bjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDotYvlgLxtZXRhZGF0YeaOpeWPl+aWueazlVxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZm9yZWlnblxuICAgICAqL1xuICAgIHNldCBvbk1lZGlhSW5mbyhmdW4pIHtcbiAgICAgICAgdGhpcy5fb25NZWRpYUluZm8gPSBmdW47XG4gICAgICAgIHRoaXMuZjJtLm9uTWVkaWFJbmZvID0gZnVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOi1i+WAvOaYr+WQpui3s+i9rOWbnuiwg+aOpeWPl+aWueazlVxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZm9yZWlnblxuICAgICAqL1xuICAgIHNldCBzZWVrQ2FsbEJhY2soZnVuKSB7XG4gICAgICAgIHRoaXMuX3NlZWtDYWxsQmFjayA9IGZ1bjtcbiAgICAgICAgdGhpcy5mMm0uc2Vla0NhbGxCYWNrID0gZnVuO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9yZWlnbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jaGltZWUtZmx2MmZtcDQvbGliL2luZGV4X3JvbGx1cC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * chimee-helper v0.1.8\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n(function (global, factory) {\n\t true ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.chimeeHelper = global.chimeeHelper || {})));\n}(this, (function (exports) { 'use strict';\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\n// 7.1.4 ToInteger\nvar ceil  = Math.ceil;\nvar floor = Math.floor;\nvar _toInteger = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n// 7.2.1 RequireObjectCoercible(argument)\nvar _defined = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n// true  -> String#at\n// false -> String#codePointAt\nvar _stringAt = function(TO_STRING){\n  return function(that, pos){\n    var s = String(_defined(that))\n      , i = _toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\nvar _library = true;\n\nvar _global = createCommonjsModule(function (module) {\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n});\n\nvar _core = createCommonjsModule(function (module) {\nvar core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n});\n\nvar _aFunction = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n// optional / simple context binding\n\nvar _ctx = function(fn, that, length){\n  _aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\nvar _isObject = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\nvar _anObject = function(it){\n  if(!_isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\nvar _fails = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n// Thank's IE8 for his funny defineProperty\nvar _descriptors = !_fails(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\nvar document$1 = _global.document;\nvar is = _isObject(document$1) && _isObject(document$1.createElement);\nvar _domCreate = function(it){\n  return is ? document$1.createElement(it) : {};\n};\n\nvar _ie8DomDefine = !_descriptors && !_fails(function(){\n  return Object.defineProperty(_domCreate('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\n\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nvar _toPrimitive = function(it, S){\n  if(!_isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\nvar dP             = Object.defineProperty;\n\nvar f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  _anObject(O);\n  P = _toPrimitive(P, true);\n  _anObject(Attributes);\n  if(_ie8DomDefine)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\nvar _objectDp = {\n\tf: f\n};\n\nvar _propertyDesc = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\nvar _hide = _descriptors ? function(object, key, value){\n  return _objectDp.f(object, key, _propertyDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\nvar PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? _core : _core[name] || (_core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? _ctx(out, _global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])_hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nvar _export = $export;\n\nvar _redefine = _hide;\n\nvar hasOwnProperty = {}.hasOwnProperty;\nvar _has = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\nvar _iterators = {};\n\nvar toString = {}.toString;\n\nvar _cof = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\nvar _iobject = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return _cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n// to indexed object, toObject with fallback for non-array-like ES3 strings\n\nvar _toIobject = function(it){\n  return _iobject(_defined(it));\n};\n\n// 7.1.15 ToLength\nvar min       = Math.min;\nvar _toLength = function(it){\n  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\nvar max       = Math.max;\nvar min$1       = Math.min;\nvar _toIndex = function(index, length){\n  index = _toInteger(index);\n  return index < 0 ? max(index + length, 0) : min$1(index, length);\n};\n\n// false -> Array#indexOf\n// true  -> Array#includes\n\nvar _arrayIncludes = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = _toIobject($this)\n      , length = _toLength(O.length)\n      , index  = _toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar SHARED = '__core-js_shared__';\nvar store  = _global[SHARED] || (_global[SHARED] = {});\nvar _shared = function(key){\n  return store[key] || (store[key] = {});\n};\n\nvar id = 0;\nvar px = Math.random();\nvar _uid = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\nvar shared = _shared('keys');\nvar _sharedKey = function(key){\n  return shared[key] || (shared[key] = _uid(key));\n};\n\nvar arrayIndexOf = _arrayIncludes(false);\nvar IE_PROTO$1     = _sharedKey('IE_PROTO');\n\nvar _objectKeysInternal = function(object, names){\n  var O      = _toIobject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO$1)_has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(_has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n// IE 8- don't enum bug keys\nvar _enumBugKeys = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\n\nvar _objectKeys = Object.keys || function keys(O){\n  return _objectKeysInternal(O, _enumBugKeys);\n};\n\nvar _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties){\n  _anObject(O);\n  var keys   = _objectKeys(Properties)\n    , length = keys.length\n    , i = 0\n    , P;\n  while(length > i)_objectDp.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\nvar _html = _global.document && document.documentElement;\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar IE_PROTO    = _sharedKey('IE_PROTO');\nvar Empty       = function(){ /* empty */ };\nvar PROTOTYPE$1   = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = _domCreate('iframe')\n    , i      = _enumBugKeys.length\n    , lt     = '<'\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  _html.appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict[PROTOTYPE$1][_enumBugKeys[i]];\n  return createDict();\n};\n\nvar _objectCreate = Object.create || function create(O, Properties){\n  var result;\n  if(O !== null){\n    Empty[PROTOTYPE$1] = _anObject(O);\n    result = new Empty;\n    Empty[PROTOTYPE$1] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : _objectDps(result, Properties);\n};\n\nvar _wks = createCommonjsModule(function (module) {\nvar store      = _shared('wks')\n  , Symbol     = _global.Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n});\n\nvar def = _objectDp.f;\nvar TAG = _wks('toStringTag');\n\nvar _setToStringTag = function(it, tag, stat){\n  if(it && !_has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n_hide(IteratorPrototype, _wks('iterator'), function(){ return this; });\n\nvar _iterCreate = function(Constructor, NAME, next){\n  Constructor.prototype = _objectCreate(IteratorPrototype, {next: _propertyDesc(1, next)});\n  _setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n// 7.1.13 ToObject(argument)\n\nvar _toObject = function(it){\n  return Object(_defined(it));\n};\n\n// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar IE_PROTO$2    = _sharedKey('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nvar _objectGpo = Object.getPrototypeOf || function(O){\n  O = _toObject(O);\n  if(_has(O, IE_PROTO$2))return O[IE_PROTO$2];\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\nvar ITERATOR       = _wks('iterator');\nvar BUGGY          = !([].keys && 'next' in [].keys());\nvar FF_ITERATOR    = '@@iterator';\nvar KEYS           = 'keys';\nvar VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nvar _iterDefine = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  _iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = _objectGpo($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      _setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!_library && !_has(IteratorPrototype, ITERATOR))_hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    _hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  _iterators[NAME] = $default;\n  _iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))_redefine(proto, key, methods[key]);\n    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\nvar $at  = _stringAt(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n_iterDefine(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n// call something on iterator step with safe closing on error\n\nvar _iterCall = function(iterator, fn, value, entries){\n  try {\n    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch(e){\n    var ret = iterator['return'];\n    if(ret !== undefined)_anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n// check on default Array iterator\nvar ITERATOR$1   = _wks('iterator');\nvar ArrayProto = Array.prototype;\n\nvar _isArrayIter = function(it){\n  return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);\n};\n\nvar _createProperty = function(object, index, value){\n  if(index in object)_objectDp.f(object, index, _propertyDesc(0, value));\n  else object[index] = value;\n};\n\n// getting tag from 19.1.3.6 Object.prototype.toString()\nvar TAG$1 = _wks('toStringTag');\nvar ARG = _cof(function(){ return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key){\n  try {\n    return it[key];\n  } catch(e){ /* empty */ }\n};\n\nvar _classof = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T\n    // builtinTag case\n    : ARG ? _cof(O)\n    // ES3 arguments fallback\n    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\nvar ITERATOR$2  = _wks('iterator');\nvar core_getIteratorMethod = _core.getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR$2]\n    || it['@@iterator']\n    || _iterators[_classof(it)];\n};\n\nvar ITERATOR$3     = _wks('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR$3]();\n  riter['return'] = function(){ SAFE_CLOSING = true; };\n  Array.from(riter, function(){ throw 2; });\n} catch(e){ /* empty */ }\n\nvar _iterDetect = function(exec, skipClosing){\n  if(!skipClosing && !SAFE_CLOSING)return false;\n  var safe = false;\n  try {\n    var arr  = [7]\n      , iter = arr[ITERATOR$3]();\n    iter.next = function(){ return {done: safe = true}; };\n    arr[ITERATOR$3] = function(){ return iter; };\n    exec(arr);\n  } catch(e){ /* empty */ }\n  return safe;\n};\n\n_export(_export.S + _export.F * !_iterDetect(function(iter){ Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\n    var O       = _toObject(arrayLike)\n      , C       = typeof this == 'function' ? this : Array\n      , aLen    = arguments.length\n      , mapfn   = aLen > 1 ? arguments[1] : undefined\n      , mapping = mapfn !== undefined\n      , index   = 0\n      , iterFn  = core_getIteratorMethod(O)\n      , length, result, step, iterator;\n    if(mapping)mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if(iterFn != undefined && !(C == Array && _isArrayIter(iterFn))){\n      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){\n        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = _toLength(O.length);\n      for(result = new C(length); length > index; index++){\n        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n\nvar from$1 = _core.Array.from;\n\nvar from = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": from$1, __esModule: true };\n});\n\nvar _Array$from = unwrapExports(from);\n\nvar toConsumableArray = createCommonjsModule(function (module, exports) {\n\"use strict\";\n\nexports.__esModule = true;\n\n\n\nvar _from2 = _interopRequireDefault(from);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return (0, _from2.default)(arr);\n  }\n};\n});\n\nvar _toConsumableArray = unwrapExports(toConsumableArray);\n\nvar _addToUnscopables = function(){ /* empty */ };\n\nvar _iterStep = function(done, value){\n  return {value: value, done: !!done};\n};\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nvar es6_array_iterator = _iterDefine(Array, 'Array', function(iterated, kind){\n  this._t = _toIobject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return _iterStep(1);\n  }\n  if(kind == 'keys'  )return _iterStep(0, index);\n  if(kind == 'values')return _iterStep(0, O[index]);\n  return _iterStep(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n_iterators.Arguments = _iterators.Array;\n\n_addToUnscopables('keys');\n_addToUnscopables('values');\n_addToUnscopables('entries');\n\nvar TO_STRING_TAG = _wks('toStringTag');\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = _global[NAME]\n    , proto      = Collection && Collection.prototype;\n  if(proto && !proto[TO_STRING_TAG])_hide(proto, TO_STRING_TAG, NAME);\n  _iterators[NAME] = _iterators.Array;\n}\n\nvar f$1 = _wks;\n\nvar _wksExt = {\n\tf: f$1\n};\n\nvar iterator$2 = _wksExt.f('iterator');\n\nvar iterator = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": iterator$2, __esModule: true };\n});\n\nvar _meta = createCommonjsModule(function (module) {\nvar META     = _uid('meta')\n  , setDesc  = _objectDp.f\n  , id       = 0;\nvar isExtensible = Object.isExtensible || function(){\n  return true;\n};\nvar FREEZE = !_fails(function(){\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function(it){\n  setDesc(it, META, {value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  }});\n};\nvar fastKey = function(it, create){\n  // return primitive with prefix\n  if(!_isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if(!_has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return 'F';\n    // not necessary to add metadata\n    if(!create)return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function(it, create){\n  if(!_has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return true;\n    // not necessary to add metadata\n    if(!create)return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function(it){\n  if(FREEZE && meta.NEED && isExtensible(it) && !_has(it, META))setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY:      META,\n  NEED:     false,\n  fastKey:  fastKey,\n  getWeak:  getWeak,\n  onFreeze: onFreeze\n};\n});\n\nvar defineProperty = _objectDp.f;\nvar _wksDefine = function(name){\n  var $Symbol = _core.Symbol || (_core.Symbol = _library ? {} : _global.Symbol || {});\n  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: _wksExt.f(name)});\n};\n\nvar _keyof = function(object, el){\n  var O      = _toIobject(object)\n    , keys   = _objectKeys(O)\n    , length = keys.length\n    , index  = 0\n    , key;\n  while(length > index)if(O[key = keys[index++]] === el)return key;\n};\n\nvar f$2 = Object.getOwnPropertySymbols;\n\nvar _objectGops = {\n\tf: f$2\n};\n\nvar f$3 = {}.propertyIsEnumerable;\n\nvar _objectPie = {\n\tf: f$3\n};\n\n// all enumerable object keys, includes symbols\n\nvar _enumKeys = function(it){\n  var result     = _objectKeys(it)\n    , getSymbols = _objectGops.f;\n  if(getSymbols){\n    var symbols = getSymbols(it)\n      , isEnum  = _objectPie.f\n      , i       = 0\n      , key;\n    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n  } return result;\n};\n\n// 7.2.2 IsArray(argument)\n\nvar _isArray = Array.isArray || function isArray(arg){\n  return _cof(arg) == 'Array';\n};\n\n// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar hiddenKeys = _enumBugKeys.concat('length', 'prototype');\n\nvar f$5 = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\n  return _objectKeysInternal(O, hiddenKeys);\n};\n\nvar _objectGopn = {\n\tf: f$5\n};\n\n// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar gOPN$1      = _objectGopn.f;\nvar toString$1  = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function(it){\n  try {\n    return gOPN$1(it);\n  } catch(e){\n    return windowNames.slice();\n  }\n};\n\nvar f$4 = function getOwnPropertyNames(it){\n  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN$1(_toIobject(it));\n};\n\nvar _objectGopnExt = {\n\tf: f$4\n};\n\nvar gOPD$1           = Object.getOwnPropertyDescriptor;\n\nvar f$6 = _descriptors ? gOPD$1 : function getOwnPropertyDescriptor(O, P){\n  O = _toIobject(O);\n  P = _toPrimitive(P, true);\n  if(_ie8DomDefine)try {\n    return gOPD$1(O, P);\n  } catch(e){ /* empty */ }\n  if(_has(O, P))return _propertyDesc(!_objectPie.f.call(O, P), O[P]);\n};\n\nvar _objectGopd = {\n\tf: f$6\n};\n\n// ECMAScript 6 symbols shim\nvar META           = _meta.KEY;\nvar gOPD           = _objectGopd.f;\nvar dP$2             = _objectDp.f;\nvar gOPN           = _objectGopnExt.f;\nvar $Symbol        = _global.Symbol;\nvar $JSON          = _global.JSON;\nvar _stringify     = $JSON && $JSON.stringify;\nvar PROTOTYPE$2      = 'prototype';\nvar HIDDEN         = _wks('_hidden');\nvar TO_PRIMITIVE   = _wks('toPrimitive');\nvar isEnum         = {}.propertyIsEnumerable;\nvar SymbolRegistry = _shared('symbol-registry');\nvar AllSymbols     = _shared('symbols');\nvar OPSymbols      = _shared('op-symbols');\nvar ObjectProto$1    = Object[PROTOTYPE$2];\nvar USE_NATIVE     = typeof $Symbol == 'function';\nvar QObject        = _global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = _descriptors && _fails(function(){\n  return _objectCreate(dP$2({}, 'a', {\n    get: function(){ return dP$2(this, 'a', {value: 7}).a; }\n  })).a != 7;\n}) ? function(it, key, D){\n  var protoDesc = gOPD(ObjectProto$1, key);\n  if(protoDesc)delete ObjectProto$1[key];\n  dP$2(it, key, D);\n  if(protoDesc && it !== ObjectProto$1)dP$2(ObjectProto$1, key, protoDesc);\n} : dP$2;\n\nvar wrap = function(tag){\n  var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n  return typeof it == 'symbol';\n} : function(it){\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D){\n  if(it === ObjectProto$1)$defineProperty(OPSymbols, key, D);\n  _anObject(it);\n  key = _toPrimitive(key, true);\n  _anObject(D);\n  if(_has(AllSymbols, key)){\n    if(!D.enumerable){\n      if(!_has(it, HIDDEN))dP$2(it, HIDDEN, _propertyDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if(_has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n      D = _objectCreate(D, {enumerable: _propertyDesc(0, false)});\n    } return setSymbolDesc(it, key, D);\n  } return dP$2(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P){\n  _anObject(it);\n  var keys = _enumKeys(P = _toIobject(P))\n    , i    = 0\n    , l = keys.length\n    , key;\n  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P){\n  return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n  var E = isEnum.call(this, key = _toPrimitive(key, true));\n  if(this === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key))return false;\n  return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n  it  = _toIobject(it);\n  key = _toPrimitive(key, true);\n  if(it === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key))return;\n  var D = gOPD(it, key);\n  if(D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n  var names  = gOPN(_toIobject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n  var IS_OP  = it === ObjectProto$1\n    , names  = gOPN(IS_OP ? OPSymbols : _toIobject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto$1, key) : true))result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif(!USE_NATIVE){\n  $Symbol = function Symbol(){\n    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n    var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function(value){\n      if(this === ObjectProto$1)$set.call(OPSymbols, value);\n      if(_has(this, HIDDEN) && _has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, _propertyDesc(1, value));\n    };\n    if(_descriptors && setter)setSymbolDesc(ObjectProto$1, tag, {configurable: true, set: $set});\n    return wrap(tag);\n  };\n  _redefine($Symbol[PROTOTYPE$2], 'toString', function toString(){\n    return this._k;\n  });\n\n  _objectGopd.f = $getOwnPropertyDescriptor;\n  _objectDp.f   = $defineProperty;\n  _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;\n  _objectPie.f  = $propertyIsEnumerable;\n  _objectGops.f = $getOwnPropertySymbols;\n\n  if(_descriptors && !_library){\n    _redefine(ObjectProto$1, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  _wksExt.f = function(name){\n    return wrap(_wks(name));\n  };\n}\n\n_export(_export.G + _export.W + _export.F * !USE_NATIVE, {Symbol: $Symbol});\n\nfor(var symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), i$1 = 0; symbols.length > i$1; )_wks(symbols[i$1++]);\n\nfor(var symbols = _objectKeys(_wks.store), i$1 = 0; symbols.length > i$1; )_wksDefine(symbols[i$1++]);\n\n_export(_export.S + _export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function(key){\n    return _has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(key){\n    if(isSymbol(key))return _keyof(SymbolRegistry, key);\n    throw TypeError(key + ' is not a symbol!');\n  },\n  useSetter: function(){ setter = true; },\n  useSimple: function(){ setter = false; }\n});\n\n_export(_export.S + _export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && _export(_export.S + _export.F * (!USE_NATIVE || _fails(function(){\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it){\n    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n    var args = [it]\n      , i    = 1\n      , replacer, $replacer;\n    while(arguments.length > i)args.push(arguments[i++]);\n    replacer = args[1];\n    if(typeof replacer == 'function')$replacer = replacer;\n    if($replacer || !_isArray(replacer))replacer = function(key, value){\n      if($replacer)value = $replacer.call(this, key, value);\n      if(!isSymbol(value))return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\n_setToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\n_setToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\n_setToStringTag(_global.JSON, 'JSON', true);\n\n_wksDefine('asyncIterator');\n\n_wksDefine('observable');\n\nvar index = _core.Symbol;\n\nvar symbol = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": index, __esModule: true };\n});\n\nvar _typeof_1 = createCommonjsModule(function (module, exports) {\n\"use strict\";\n\nexports.__esModule = true;\n\n\n\nvar _iterator2 = _interopRequireDefault(iterator);\n\n\n\nvar _symbol2 = _interopRequireDefault(symbol);\n\nvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n};\n});\n\nvar _typeof = unwrapExports(_typeof_1);\n\n// most Object methods by ES6 should accept primitives\n\nvar _objectSap = function(KEY, exec){\n  var fn  = (_core.Object || {})[KEY] || Object[KEY]\n    , exp = {};\n  exp[KEY] = exec(fn);\n  _export(_export.S + _export.F * _fails(function(){ fn(1); }), 'Object', exp);\n};\n\n// 19.1.2.14 Object.keys(O)\n\n\n_objectSap('keys', function(){\n  return function keys(it){\n    return _objectKeys(_toObject(it));\n  };\n});\n\nvar keys$1 = _core.Object.keys;\n\nvar keys = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": keys$1, __esModule: true };\n});\n\nvar _Object$keys = unwrapExports(keys);\n\n// 20.1.2.3 Number.isInteger(number)\nvar floor$1    = Math.floor;\nvar _isInteger = function isInteger(it){\n  return !_isObject(it) && isFinite(it) && floor$1(it) === it;\n};\n\n// 20.1.2.3 Number.isInteger(number)\n\n\n_export(_export.S, 'Number', {isInteger: _isInteger});\n\nvar isInteger$2 = _core.Number.isInteger;\n\nvar isInteger$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": isInteger$2, __esModule: true };\n});\n\nvar _Number$isInteger = unwrapExports(isInteger$1);\n\nvar _stringWs = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n  '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\nvar space   = '[' + _stringWs + ']';\nvar non     = '\\u200b\\u0085';\nvar ltrim   = RegExp('^' + space + space + '*');\nvar rtrim   = RegExp(space + space + '*$');\n\nvar exporter = function(KEY, exec, ALIAS){\n  var exp   = {};\n  var FORCE = _fails(function(){\n    return !!_stringWs[KEY]() || non[KEY]() != non;\n  });\n  var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];\n  if(ALIAS)exp[ALIAS] = fn;\n  _export(_export.P + _export.F * FORCE, 'String', exp);\n};\n\n// 1 -> String#trimLeft\n// 2 -> String#trimRight\n// 3 -> String#trim\nvar trim = exporter.trim = function(string, TYPE){\n  string = String(_defined(string));\n  if(TYPE & 1)string = string.replace(ltrim, '');\n  if(TYPE & 2)string = string.replace(rtrim, '');\n  return string;\n};\n\nvar _stringTrim = exporter;\n\nvar $parseFloat = _global.parseFloat;\nvar $trim       = _stringTrim.trim;\n\nvar _parseFloat$3 = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str){\n  var string = $trim(String(str), 3)\n    , result = $parseFloat(string);\n  return result === 0 && string.charAt(0) == '-' ? -0 : result;\n} : $parseFloat;\n\n// 20.1.2.12 Number.parseFloat(string)\n_export(_export.S + _export.F * (Number.parseFloat != _parseFloat$3), 'Number', {parseFloat: _parseFloat$3});\n\nvar _parseFloat$1 = parseFloat;\n\nvar _parseFloat = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": _parseFloat$1, __esModule: true };\n});\n\nvar _Number$parseFloat = unwrapExports(_parseFloat);\n\n/**\n * toxic-predicate-functions v0.1.2\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n/**\n * is void element or not ? Means it will return true when val is undefined or null\n * @param  {Anything}  obj\n * @return {Boolean}   return true when val is undefined or null\n */\nfunction isVoid(obj) {\n  return obj === undefined || obj === null;\n}\n/**\n * to check whether a variable is array\n * @param {Anything} arr\n * @return {Boolean} true when it is a boolean\n */\nfunction isArray(arr) {\n  return Array.isArray(arr);\n}\n\n/**\n * 判断是否为function\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isFunction(obj) {\n  return typeof obj === 'function';\n}\n\n/**\n * 判断是否是对象\n * @param  {Anything}  obj 传入对象\n * @return {Boolean}     [description]\n */\nfunction isObject$1(obj) {\n  // incase of arrow function and array\n  return Object(obj) === obj && String(obj) === '[object Object]' && !isFunction(obj) && !isArray(obj);\n}\n/**\n * to tell you if it's a real number\n * @param  {Anything}  obj\n * @return {Boolean}   return true when it's a number\n */\nfunction isNumber(obj) {\n  return typeof obj === 'number';\n}\n/**\n * to tell you if the val can be transfer into data\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isNumeric(obj) {\n  return !isArray(obj) && obj - _Number$parseFloat(obj) + 1 >= 0;\n}\n/**\n * 判断是否为整数\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isInteger(num) {\n  return _Number$isInteger(num);\n}\n\n/**\n * 判断是否为空\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n * @example\n * \"\", {}, [], 0, null, undefined, false 为空\n */\nfunction isEmpty(obj) {\n  if (isArray(obj)) {\n    return obj.length === 0;\n  } else if (isObject$1(obj)) {\n    return _Object$keys(obj).length === 0;\n  } else {\n    return !obj;\n  }\n}\n/**\n * 判断是否为事件\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isEvent(obj) {\n  return obj instanceof Event || obj.originalEvent instanceof Event;\n}\n/**\n * 判断是否为blob\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isBlob(obj) {\n  return obj instanceof Blob;\n}\n/**\n * 判断是否为file上传的文件\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isFile(obj) {\n  return isBlob(obj) && isString(obj.name);\n}\n/**\n * 判断是否为日期对象\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isDate(obj) {\n  return Object.prototype.toString.call(obj) === '[object Date]';\n}\n/**\n * 判断是否是string\n * @param  {Anything}  str [description]\n * @return {Boolean}     [description]\n */\nfunction isString(str) {\n  return typeof str === 'string' || str instanceof String;\n}\n/**\n * is Boolean or not\n * @param  {Anything} bool\n * @return {Boolean}\n */\nfunction isBoolean(bool) {\n  return typeof bool === 'boolean';\n}\n/**\n * is a promise or not\n * @param {Anything} obj\n * @return {boolean}\n */\nfunction isPromise(obj) {\n  return !!obj && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n}\n/**\n * is Primitive type or not, whick means it will return true when data is number/string/boolean/undefined/null\n * @param  {Anyting}  val\n * @return {Boolean}  true when type is number/string/boolean/undefined/null\n */\nfunction isPrimitive(val) {\n  return isVoid(val) || isBoolean(val) || isString(val) || isNumber(val);\n}\n/**\n * 判断是否为url且必须要带有协议头\n * @param  {Anything}  str [description]\n * @return {Boolean}     [description]\n */\nfunction isUrl(str) {\n  return isString(str) && !!str.match(/^((https?|ftp|rtsp|mms):\\/\\/)(([0-9a-z_!~*'().&=+$%-]+: )?[0-9a-z_!~*'().&=+$%-]+@)?(([0-9]{1,3}\\.){3}[0-9]{1,3}|([0-9a-z_!~*'()-]+\\.)*([0-9a-z][0-9a-z-]{0,61})?[0-9a-z]\\.[a-z]{2,6}|localhost)(:[0-9]{1,4})?((\\/?)|(\\/[0-9a-z_!~*'().;?:@&=+$,%#-]+)+\\/?)$/i);\n}\n/**\n * to test if a HTML node\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isNode(obj) {\n  return !!((typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? obj instanceof Node : obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string');\n}\n/**\n * to test if a HTML element\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isElement(obj) {\n  return !!((typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement)) === 'object' ? obj instanceof HTMLElement : obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === 'string');\n}\n/**\n * check if node A is node B's parent or not\n * @param  {Node}  parent\n * @param  {Node}  child\n * @return {Boolean}\n */\nfunction isChildNode(parent, child) {\n  if (!isNode(parent) || !isNode(child)) {\n    return false;\n  }\n  return child.parentNode === parent;\n}\n/**\n * check if node B is node A's posterrity or not\n * @param  {Node}  parent\n * @param  {Node}  child\n * @return {Boolean}\n */\nfunction isPosterityNode(parent, child) {\n  if (!isNode(parent) || !isNode(child)) {\n    return false;\n  }\n  while (child.parentNode) {\n    child = child.parentNode;\n    if (child === parent) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * check if the string is an HTMLString\n * @param  {string}  str only accept string\n * @return {Boolean}\n */\nfunction isHTMLString(str) {\n  return (/<[^>]+?>/.test(str)\n  );\n}\n/**\n * check if is an error\n * @param {anything} val\n * @return {boolean}\n */\nfunction isError(val) {\n  return val instanceof Error;\n}\n\n/**\n * toxic-utils v0.1.3\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n/**\n * 生成深度遍历函数的处理器，常用于生成深度拷贝等\n * @param  {Function} fn 遍历到深度变量的时候的操作\n * @return {Function}     可用的操作函数\n */\nfunction genTraversalHandler(fn) {\n  function recursiveFn(source, target, key) {\n    if (isArray(source) || isObject$1(source)) {\n      target = target || (isObject$1(source) ? {} : []);\n      for (var _key in source) {\n        target[_key] = recursiveFn(source[_key], target[_key], _key);\n      }\n      return target;\n    }\n    return fn(source, target, key);\n  }\n  return recursiveFn;\n}\nvar _deepAssign = genTraversalHandler(function (val) {\n  return val;\n});\n/**\n * 对象克隆\n * @param  {Array|Object} source 传其他值会直接返回\n * @return {clone-target}        [description]\n */\nfunction deepClone(source) {\n  if (isPrimitive(source)) {\n    throw new TypeError('deepClone only accept non primitive type');\n  }\n  return _deepAssign(source);\n}\n/**\n * merge multiple objects\n * @param  {...Object} args [description]\n * @return {merge-object}         [description]\n */\nfunction deepAssign() {\n  for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  if (args.length < 2) {\n    throw new Error('deepAssign accept two and more argument');\n  }\n  for (var i = args.length - 1; i > -1; i--) {\n    if (isPrimitive(args[i])) {\n      throw new TypeError('deepAssign only accept non primitive type');\n    }\n  }\n  var target = args.shift();\n  args.forEach(function (source) {\n    return _deepAssign(source, target);\n  });\n  return target;\n}\n\n/**\n * camelize any string, e.g hello world -> helloWorld\n * @param  {string} str only accept string!\n * @return {string}     camelize string\n */\nfunction camelize(str, isBig) {\n  return str.replace(/(^|[^a-zA-Z]+)([a-zA-Z])/g, function (match, spilt, initials, index) {\n    return !isBig && index === 0 ? initials.toLowerCase() : initials.toUpperCase();\n  });\n}\n/**\n * hypenate any string e.g hello world -> hello-world\n * @param  {string} str only accept string\n * @return {string}\n */\nfunction hypenate(str) {\n  return camelize(str).replace(/([A-Z])/g, function (match) {\n    return '-' + match.toLowerCase();\n  });\n}\n\n/**\n * bind the function with some context. we have some fallback strategy here\n * @param {function} fn the function which we need to bind the context on\n * @param {any} context the context object\n */\nfunction bind(fn, context) {\n  if (fn.bind) {\n    return fn.bind(context);\n  } else if (fn.apply) {\n    return function __autobind__() {\n      for (var _len2 = arguments.length, args = Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return fn.apply(context, args);\n    };\n  } else {\n    return function __autobind__() {\n      for (var _len3 = arguments.length, args = Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return fn.call.apply(fn, [context].concat(_toConsumableArray(args)));\n    };\n  }\n}\n\n// **********************  计算类    ************************\n// 计算获取某种东西或者计算出某种东西\n// ********************************************************\n// 生成uuid\nfunction uuid() {\n  return S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4();\n}\n// 生成四个随机数\nfunction S4() {\n  return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);\n}\n// 生成任意长度的随机数\nfunction rand(length) {\n  var str = '';\n  while (str.length < length) {\n    str += S4();\n  }\n  return str.slice(0, length);\n}\n\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n_export(_export.S + _export.F * !_descriptors, 'Object', {defineProperty: _objectDp.f});\n\nvar $Object = _core.Object;\nvar defineProperty$2 = function defineProperty(it, key, desc){\n  return $Object.defineProperty(it, key, desc);\n};\n\nvar defineProperty$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": defineProperty$2, __esModule: true };\n});\n\nvar _Object$defineProperty = unwrapExports(defineProperty$1);\n\nvar _anInstance = function(it, Constructor, name, forbiddenField){\n  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n\nvar _forOf = createCommonjsModule(function (module) {\nvar BREAK       = {}\n  , RETURN      = {};\nvar exports = module.exports = function(iterable, entries, fn, that, ITERATOR){\n  var iterFn = ITERATOR ? function(){ return iterable; } : core_getIteratorMethod(iterable)\n    , f      = _ctx(fn, that, entries ? 2 : 1)\n    , index  = 0\n    , length, step, iterator, result;\n  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if(_isArrayIter(iterFn))for(length = _toLength(iterable.length); length > index; index++){\n    result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if(result === BREAK || result === RETURN)return result;\n  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){\n    result = _iterCall(iterator, f, step.value, entries);\n    if(result === BREAK || result === RETURN)return result;\n  }\n};\nexports.BREAK  = BREAK;\nexports.RETURN = RETURN;\n});\n\n// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar SPECIES   = _wks('species');\nvar _speciesConstructor = function(O, D){\n  var C = _anObject(O).constructor, S;\n  return C === undefined || (S = _anObject(C)[SPECIES]) == undefined ? D : _aFunction(S);\n};\n\n// fast apply, http://jsperf.lnkit.com/fast-apply/5\nvar _invoke = function(fn, args, that){\n  var un = that === undefined;\n  switch(args.length){\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return              fn.apply(that, args);\n};\n\nvar process$1            = _global.process;\nvar setTask            = _global.setImmediate;\nvar clearTask          = _global.clearImmediate;\nvar MessageChannel     = _global.MessageChannel;\nvar counter            = 0;\nvar queue              = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer;\nvar channel;\nvar port;\nvar run = function(){\n  var id = +this;\n  if(queue.hasOwnProperty(id)){\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function(event){\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif(!setTask || !clearTask){\n  setTask = function setImmediate(fn){\n    var args = [], i = 1;\n    while(arguments.length > i)args.push(arguments[i++]);\n    queue[++counter] = function(){\n      _invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id){\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if(_cof(process$1) == 'process'){\n    defer = function(id){\n      process$1.nextTick(_ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if(MessageChannel){\n    channel = new MessageChannel;\n    port    = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = _ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if(_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts){\n    defer = function(id){\n      _global.postMessage(id + '', '*');\n    };\n    _global.addEventListener('message', listener, false);\n  // IE8-\n  } else if(ONREADYSTATECHANGE in _domCreate('script')){\n    defer = function(id){\n      _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function(){\n        _html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function(id){\n      setTimeout(_ctx(run, id, 1), 0);\n    };\n  }\n}\nvar _task = {\n  set:   setTask,\n  clear: clearTask\n};\n\nvar macrotask = _task.set;\nvar Observer  = _global.MutationObserver || _global.WebKitMutationObserver;\nvar process$2   = _global.process;\nvar Promise   = _global.Promise;\nvar isNode$2    = _cof(process$2) == 'process';\n\nvar _microtask = function(){\n  var head, last, notify;\n\n  var flush = function(){\n    var parent, fn;\n    if(isNode$2 && (parent = process$2.domain))parent.exit();\n    while(head){\n      fn   = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch(e){\n        if(head)notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if(parent)parent.enter();\n  };\n\n  // Node.js\n  if(isNode$2){\n    notify = function(){\n      process$2.nextTick(flush);\n    };\n  // browsers with MutationObserver\n  } else if(Observer){\n    var toggle = true\n      , node   = document.createTextNode('');\n    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new\n    notify = function(){\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if(Promise && Promise.resolve){\n    var promise = Promise.resolve();\n    notify = function(){\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function(){\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(_global, flush);\n    };\n  }\n\n  return function(fn){\n    var task = {fn: fn, next: undefined};\n    if(last)last.next = task;\n    if(!head){\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n\nvar _redefineAll = function(target, src, safe){\n  for(var key in src){\n    if(safe && target[key])target[key] = src[key];\n    else _hide(target, key, src[key]);\n  } return target;\n};\n\nvar SPECIES$1     = _wks('species');\n\nvar _setSpecies = function(KEY){\n  var C = typeof _core[KEY] == 'function' ? _core[KEY] : _global[KEY];\n  if(_descriptors && C && !C[SPECIES$1])_objectDp.f(C, SPECIES$1, {\n    configurable: true,\n    get: function(){ return this; }\n  });\n};\n\nvar task               = _task.set;\nvar microtask          = _microtask();\nvar PROMISE            = 'Promise';\nvar TypeError$1          = _global.TypeError;\nvar process            = _global.process;\nvar $Promise           = _global[PROMISE];\nvar process            = _global.process;\nvar isNode$1             = _classof(process) == 'process';\nvar empty              = function(){ /* empty */ };\nvar Internal;\nvar GenericPromiseCapability;\nvar Wrapper;\n\nvar USE_NATIVE$1 = !!function(){\n  try {\n    // correct subclassing with @@species support\n    var promise     = $Promise.resolve(1)\n      , FakePromise = (promise.constructor = {})[_wks('species')] = function(exec){ exec(empty, empty); };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode$1 || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\n  } catch(e){ /* empty */ }\n}();\n\n// helpers\nvar sameConstructor = function(a, b){\n  // with library wrapper special case\n  return a === b || a === $Promise && b === Wrapper;\n};\nvar isThenable = function(it){\n  var then;\n  return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar newPromiseCapability = function(C){\n  return sameConstructor($Promise, C)\n    ? new PromiseCapability(C)\n    : new GenericPromiseCapability(C);\n};\nvar PromiseCapability = GenericPromiseCapability = function(C){\n  var resolve, reject;\n  this.promise = new C(function($$resolve, $$reject){\n    if(resolve !== undefined || reject !== undefined)throw TypeError$1('Bad Promise constructor');\n    resolve = $$resolve;\n    reject  = $$reject;\n  });\n  this.resolve = _aFunction(resolve);\n  this.reject  = _aFunction(reject);\n};\nvar perform = function(exec){\n  try {\n    exec();\n  } catch(e){\n    return {error: e};\n  }\n};\nvar notify = function(promise, isReject){\n  if(promise._n)return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function(){\n    var value = promise._v\n      , ok    = promise._s == 1\n      , i     = 0;\n    var run = function(reaction){\n      var handler = ok ? reaction.ok : reaction.fail\n        , resolve = reaction.resolve\n        , reject  = reaction.reject\n        , domain  = reaction.domain\n        , result, then;\n      try {\n        if(handler){\n          if(!ok){\n            if(promise._h == 2)onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if(handler === true)result = value;\n          else {\n            if(domain)domain.enter();\n            result = handler(value);\n            if(domain)domain.exit();\n          }\n          if(result === reaction.promise){\n            reject(TypeError$1('Promise-chain cycle'));\n          } else if(then = isThenable(result)){\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch(e){\n        reject(e);\n      }\n    };\n    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if(isReject && !promise._h)onUnhandled(promise);\n  });\n};\nvar onUnhandled = function(promise){\n  task.call(_global, function(){\n    var value = promise._v\n      , abrupt, handler, console;\n    if(isUnhandled(promise)){\n      abrupt = perform(function(){\n        if(isNode$1){\n          process.emit('unhandledRejection', value, promise);\n        } else if(handler = _global.onunhandledrejection){\n          handler({promise: promise, reason: value});\n        } else if((console = _global.console) && console.error){\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if(abrupt)throw abrupt.error;\n  });\n};\nvar isUnhandled = function(promise){\n  if(promise._h == 1)return false;\n  var chain = promise._a || promise._c\n    , i     = 0\n    , reaction;\n  while(chain.length > i){\n    reaction = chain[i++];\n    if(reaction.fail || !isUnhandled(reaction.promise))return false;\n  } return true;\n};\nvar onHandleUnhandled = function(promise){\n  task.call(_global, function(){\n    var handler;\n    if(isNode$1){\n      process.emit('rejectionHandled', promise);\n    } else if(handler = _global.onrejectionhandled){\n      handler({promise: promise, reason: promise._v});\n    }\n  });\n};\nvar $reject = function(value){\n  var promise = this;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if(!promise._a)promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function(value){\n  var promise = this\n    , then;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if(promise === value)throw TypeError$1(\"Promise can't be resolved itself\");\n    if(then = isThenable(value)){\n      microtask(function(){\n        var wrapper = {_w: promise, _d: false}; // wrap\n        try {\n          then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));\n        } catch(e){\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch(e){\n    $reject.call({_w: promise, _d: false}, e); // wrap\n  }\n};\n\n// constructor polyfill\nif(!USE_NATIVE$1){\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor){\n    _anInstance(this, $Promise, PROMISE, '_h');\n    _aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));\n    } catch(err){\n      $reject.call(this, err);\n    }\n  };\n  Internal = function Promise(executor){\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = _redefineAll($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected){\n      var reaction    = newPromiseCapability(_speciesConstructor(this, $Promise));\n      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail   = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode$1 ? process.domain : undefined;\n      this._c.push(reaction);\n      if(this._a)this._a.push(reaction);\n      if(this._s)notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function(onRejected){\n      return this.then(undefined, onRejected);\n    }\n  });\n  PromiseCapability = function(){\n    var promise  = new Internal;\n    this.promise = promise;\n    this.resolve = _ctx($resolve, promise, 1);\n    this.reject  = _ctx($reject, promise, 1);\n  };\n}\n\n_export(_export.G + _export.W + _export.F * !USE_NATIVE$1, {Promise: $Promise});\n_setToStringTag($Promise, PROMISE);\n_setSpecies(PROMISE);\nWrapper = _core[PROMISE];\n\n// statics\n_export(_export.S + _export.F * !USE_NATIVE$1, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r){\n    var capability = newPromiseCapability(this)\n      , $$reject   = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n_export(_export.S + _export.F * (_library || !USE_NATIVE$1), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x){\n    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;\n    var capability = newPromiseCapability(this)\n      , $$resolve  = capability.resolve;\n    $$resolve(x);\n    return capability.promise;\n  }\n});\n_export(_export.S + _export.F * !(USE_NATIVE$1 && _iterDetect(function(iter){\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , resolve    = capability.resolve\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      var values    = []\n        , index     = 0\n        , remaining = 1;\n      _forOf(iterable, false, function(promise){\n        var $index        = index++\n          , alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function(value){\n          if(alreadyCalled)return;\n          alreadyCalled  = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      _forOf(iterable, false, function(promise){\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  }\n});\n\nvar promise$1 = _core.Promise;\n\nvar promise = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": promise$1, __esModule: true };\n});\n\nvar _Promise = unwrapExports(promise);\n\n/**\n * chimee-helper-utils v0.1.2\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n// **********************  judgement   ************************\n/**\n * check if the code running in browser environment (not include worker env)\n * @returns {Boolean}\n */\nvar inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\n\n// **********************  对象操作  ************************\n/**\n * 转变一个类数组对象为数组\n */\nfunction makeArray(obj) {\n  return _Array$from(obj);\n}\n\n/**\n * sort Object attributes by function\n * and transfer them into array\n * @param  {Object} obj Object form from numric\n * @param  {Function} fn sort function\n * @return {Array} the sorted attirbutes array\n */\nfunction transObjectAttrIntoArray(obj) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (a, b) {\n    return +a - +b;\n  };\n\n  return _Object$keys(obj).sort(fn).reduce(function (order, key) {\n    return order.concat(obj[key]);\n  }, []);\n}\n// ********************** class operation ***************************\n// class MixinBuilder {\n//   constructor (superclass) {\n//     this.superclass = superclass || class {};\n//   }\n\n//   with (...mixins) {\n//     return mixins.reduce((c, mixin) => mixin(c), this.superclass);\n//   }\n// }\n// export const mix = (superclass) => {\n//   return new MixinBuilder(superclass);\n// };\n/**\n * run a queue one by one.If include function reject or return false it will stop\n * @param  {Array} queue the queue which we want to run one by one\n * @return {Promise}    tell us whether a queue run finished\n */\nfunction runRejectableQueue(queue) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return new _Promise(function (resolve, reject) {\n    var step = function step(index) {\n      if (index >= queue.length) {\n        resolve();\n        return;\n      }\n      var result = isFunction(queue[index]) ? queue[index].apply(queue, _toConsumableArray(args)) : queue[index];\n      if (result === false) return reject('stop');\n      return _Promise.resolve(result).then(function () {\n        return step(index + 1);\n      }).catch(function () {\n        return reject('stop');\n      });\n    };\n    step(0);\n  });\n}\n/**\n * run a queue one by one.If include function return false it will stop\n * @param  {Array} queue the queue which we want to run one by one\n * @return {boolean} tell the user if the queue run finished\n */\nfunction runStoppableQueue(queue) {\n  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  var step = function step(index) {\n    if (index >= queue.length) {\n      return true;\n    }\n    var result = isFunction(queue[index]) ? queue[index].apply(queue, _toConsumableArray(args)) : queue[index];\n    if (result === false) return false;\n    return step(++index);\n  };\n  return step(0);\n}\n/**\n * set an attribute to an object which is frozen.\n * Means you can't remove it, iterate it or rewrite it.\n * @param {!primitive} obj\n * @param {string} key\n * @param {Anything} value\n */\nfunction setFrozenAttr(obj, key, value) {\n  if (isPrimitive(obj)) throw TypeError('setFrozenAttr obj parameter can not be primitive type');\n  if (!isString(key)) throw TypeError('setFrozenAttr key parameter must be String');\n  _Object$defineProperty(obj, key, {\n    value: value,\n    configurable: false,\n    enumerable: false,\n    writable: false\n  });\n}\n/**\n * set attr on an Object. We will bind getter and setter on it if you provide to us\n * @param {!primitive} obj\n * @param {string} key\n * @param {Function} options.get\n * @param {Function} options.set\n * @param {String} prefix the origin data's prefix. We do not plan to save it by closure.\n */\nfunction setAttrGetterAndSetter(obj, key) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      get = _ref.get,\n      set = _ref.set;\n\n  var prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '__';\n\n  if (isPrimitive(obj)) throw TypeError('setFrozenAttr obj parameter can not be primitive type');\n  if (!isString(key)) throw TypeError('setAttrGetterAndSetter key parameter must be String');\n  var originalData = obj[key];\n  if (!isFunction(get)) {\n    _Object$defineProperty(obj, prefix + key, {\n      value: originalData,\n      configurable: true,\n      writable: true,\n      enumerable: false\n    });\n    get = function get() {\n      return this[prefix + key];\n    };\n    if (set && isFunction(set)) {\n      var originSetter = set;\n      set = function set() {\n        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        this[prefix + key] = originSetter.call.apply(originSetter, [this].concat(args));\n      };\n    }\n  }\n  _Object$defineProperty(obj, key, { get: get, set: set });\n}\n\nfunction checkContinuation(uint8array, start, checkLength) {\n  var array = uint8array;\n  if (start + checkLength < array.length) {\n    while (checkLength--) {\n      if ((array[++start] & 0xC0) !== 0x80) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// decodeUTF8\nfunction decodeUTF8(uint8array) {\n  var out = [];\n  var input = uint8array;\n  var i = 0;\n  var length = uint8array.length;\n\n  while (i < length) {\n    if (input[i] < 0x80) {\n      out.push(String.fromCharCode(input[i]));\n      ++i;\n      continue;\n    } else if (input[i] < 0xC0) {\n      // fallthrough\n    } else if (input[i] < 0xE0) {\n      if (checkContinuation(input, i, 1)) {\n        var ucs4 = (input[i] & 0x1F) << 6 | input[i + 1] & 0x3F;\n        if (ucs4 >= 0x80) {\n          out.push(String.fromCharCode(ucs4 & 0xFFFF));\n          i += 2;\n          continue;\n        }\n      }\n    } else if (input[i] < 0xF0) {\n      if (checkContinuation(input, i, 2)) {\n        var _ucs = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F;\n        if (_ucs >= 0x800 && (_ucs & 0xF800) !== 0xD800) {\n          out.push(String.fromCharCode(_ucs & 0xFFFF));\n          i += 3;\n          continue;\n        }\n      }\n    } else if (input[i] < 0xF8) {\n      if (checkContinuation(input, i, 3)) {\n        var _ucs2 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12 | (input[i + 2] & 0x3F) << 6 | input[i + 3] & 0x3F;\n        if (_ucs2 > 0x10000 && _ucs2 < 0x110000) {\n          _ucs2 -= 0x10000;\n          out.push(String.fromCharCode(_ucs2 >>> 10 | 0xD800));\n          out.push(String.fromCharCode(_ucs2 & 0x3FF | 0xDC00));\n          i += 4;\n          continue;\n        }\n      }\n    }\n    out.push(String.fromCharCode(0xFFFD));\n    ++i;\n  }\n  return out.join('');\n}\n\nfunction debounce(func, wait, immediate) {\n  // immediate默认为false\n  var timeout = void 0,\n      args = void 0,\n      context = void 0,\n      timestamp = void 0,\n      result = void 0;\n\n  var later = function later() {\n    // 当wait指定的时间间隔期间多次调用_.debounce返回的函数，则会不断更新timestamp的值，导致last < wait && last >= 0一直为true，从而不断启动新的计时器延时执行func\n    var last = new Date() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = new Date();\n    // 第一次调用该方法时，且immediate为true，则调用func函数\n    var callNow = immediate && !timeout;\n    // 在wait指定的时间间隔内首次调用该方法，则启动计时器定时调用func函数\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n}\n\n/**\n * 函数节流（控制函数执行频率）\n * @param  {Function} func 要节流控制的函数，必填\n * @return {Number}   wait 等待时长\n * @return {Object}   options {\n *                      leading<是否首次调用立即执行，否：则按wait设定等待到期后调用才执行>:false,\n *                      trailing<是否在调用并未到期时启用定时器，以保证一定执行>:true\n *                    }\n * @return {Object}   cxt 上下文对象\n * @return {Function}\n */\nfunction throttle(func, wait, options, cxt) {\n  /* options的默认值\n   *  表示首次调用返回值方法时，会马上调用func；否则仅会记录当前时刻，当第二次调用的时间间隔超过wait时，才调用func。\n   *  options.leading = true;\n   * 表示当调用方法时，未到达wait指定的时间间隔，则启动计时器延迟调用func函数，若后续在既未达到wait指定的时间间隔和func函数又未被调用的情况下调用返回值方法，则被调用请求将被丢弃。\n   *  options.trailing = true;\n   * 注意：当options.trailing = false时，效果与上面的简单实现效果相同\n   */\n  var context = void 0,\n      args = void 0,\n      result = void 0;\n  var timeout = null;\n  var previous = 0;\n  if (!options) options = {};\n  var later = function later() {\n    previous = options.leading === false ? 0 : new Date() - 0;\n    timeout = null;\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n  wait = wait || 0;\n  return function () {\n    var now = new Date();\n    if (!previous && options.leading === false) previous = now;\n    // 计算剩余时间\n    var remaining = wait - (now - previous);\n    if (cxt) {\n      context = cxt;\n    } else {\n      context = this;\n    }\n\n    args = arguments;\n    // 当到达wait指定的时间间隔，则调用func函数\n    // 精彩之处：按理来说remaining <= 0已经足够证明已经到达wait的时间间隔，但这里还考虑到假如客户端修改了系统时间则马上执行func函数。\n    if (remaining <= 0 || remaining > wait) {\n      // 由于setTimeout存在最小时间精度问题，因此会存在到达wait的时间间隔，但之前设置的setTimeout操作还没被执行，因此为保险起见，这里先清理setTimeout操作\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      // options.trailing=true时，延时执行func函数\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\n\n// requestAnimationFrame\nvar raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (cb) {\n  return setTimeout(cb, 17);\n};\n\n// cancelAnimationFrame\nvar caf = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame || function (id) {\n  clearTimeout(id);\n};\n\n// 根据要求的位数，将9格式化为 09\\009\\0009...\nfunction strRepeat(num, bit) {\n  var pBit = bit;\n  num = '' + (num || '');\n  var numLen = num.length;\n  bit = (bit || numLen) - numLen;\n  var paddingStr = bit > 0 ? num.repeat ? '0'.repeat(bit) : new Array(bit + 1).join('0') : '';\n  return (paddingStr + num).slice(0, pBit);\n}\n\n// video 时间格式化\nfunction formatTime(time) {\n  var hh = Math.floor(time / 3600);\n  time = Math.floor(time % 3600);\n  var mm = strRepeat(Math.floor(time / 60), 2);\n  time = Math.floor(time % 60);\n  var ss = strRepeat(time, 2);\n  return hh >= 1 ? hh + ':' + mm + ':' + ss : mm + ':' + ss;\n}\n\n/**\n * 给obj对象扩展上trans方法，用以实现methodName对应的属性方法包装为静态函数且保持上下文的功能\n * @param  {Object} obj 目标对象\n */\nfunction addTransMethod(obj) {\n  setFrozenAttr(obj, 'trans', function (methodName) {\n    if (!obj.__fns) {\n      setFrozenAttr(obj, '__fns', {});\n    }\n    if (!obj.__fns[methodName]) {\n      obj.__fns[methodName] = function () {\n        if (!isFunction(obj[methodName])) throw TypeError('obj.trans(methodName) parameter must be Function');\n        return obj[methodName].apply(obj, arguments);\n      };\n    }\n    return obj.__fns[methodName];\n  });\n}\n\n/**\n * 追加样式代码到head的style标签，不存在则创建\n * @param {String} cssText 样式文本\n * @return {HTMLElement}\n */\nfunction appendCSS(cssText) {\n  var doc = document;\n  var styleEl = doc.querySelector('style');\n  if (!styleEl) {\n    styleEl = doc.createElement('style');\n    var header = doc.querySelector('head');\n    header && header.appendChild(styleEl);\n  }\n  styleEl.appendChild(doc.createTextNode(cssText));\n  return styleEl;\n}\n\n/**\n * 格式化日期对象为：年-月-日 时:分:秒.毫秒\n * @param {Date} date Date日期对象\n * @param {String} pattern 要输出的日期格式，默认：`yyyy-MM-dd hh:mm:ss.i`\n * @return {String}\n */\nfunction formatDate() {\n  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n  var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'yyyy-MM-dd hh:mm:ss.i';\n\n  var year = date.getFullYear().toString();\n  var fields = {\n    M: date.getMonth() + 1,\n    d: date.getDate(),\n    h: date.getHours(),\n    m: date.getMinutes(),\n    s: date.getSeconds(),\n    i: date.getMilliseconds()\n  };\n  pattern = pattern.replace(/(y+)/ig, function (_, yearPattern) {\n    return year.substr(4 - Math.min(4, yearPattern.length));\n  });\n\n  var _loop = function _loop(i) {\n    pattern = pattern.replace(new RegExp('(' + i + '+)', 'g'), function (_, pattStr) {\n      return (fields[i] < 10 && pattStr.length > 1 ? '0' : '') + fields[i];\n    });\n  };\n\n  for (var i in fields) {\n    _loop(i);\n  }\n  return pattern;\n}\n\n/**\n * 读取本地存储的值（不支持localStorage则降级到cookie）\n * @param {String} key 目标数据key\n * @return {String}\n */\nfunction getLocalStorage(key) {\n  try {\n    return window.localStorage.getItem(key);\n  } catch (e) {\n    try {\n      var regRt = document.cookie.match(new RegExp('(^| )' + key + '=([^;]*)(;|$)'));\n      return isArray(regRt) ? unescape(regRt[2]) : '';\n    } catch (e) {\n      return '';\n    }\n  }\n}\n/**\n * 将指定key对应值写入本地存储（不支持localStorage则降级到cookie）\n * @param {String} key\n * @param {String} val\n * @return {String}\n */\nfunction setLocalStorage(key, val) {\n  try {\n    window.localStorage.setItem(key, val);\n  } catch (e) {\n    var expires = new Date();\n    // 默认存储300天\n    expires.setTime(expires.getTime() + 24 * 3600 * 1000 * 300);\n    try {\n      document.cookie = key + '=' + escape(val) + ';expires=' + expires.toUTCString() + ';path=/;';\n    } catch (e) {}\n  }\n}\n\nvar classCallCheck = createCommonjsModule(function (module, exports) {\n\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n});\n\nvar _classCallCheck = unwrapExports(classCallCheck);\n\nvar createClass = createCommonjsModule(function (module, exports) {\n\"use strict\";\n\nexports.__esModule = true;\n\n\n\nvar _defineProperty2 = _interopRequireDefault(defineProperty$1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n});\n\nvar _createClass = unwrapExports(createClass);\n\n// 19.1.2.1 Object.assign(target, source, ...)\nvar $assign  = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nvar _objectAssign = !$assign || _fails(function(){\n  var A = {}\n    , B = {}\n    , S = Symbol()\n    , K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function(k){ B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n  var T     = _toObject(target)\n    , aLen  = arguments.length\n    , index = 1\n    , getSymbols = _objectGops.f\n    , isEnum     = _objectPie.f;\n  while(aLen > index){\n    var S      = _iobject(arguments[index++])\n      , keys   = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S)\n      , length = keys.length\n      , j      = 0\n      , key;\n    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n  } return T;\n} : $assign;\n\n// 19.1.3.1 Object.assign(target, source)\n\n\n_export(_export.S + _export.F, 'Object', {assign: _objectAssign});\n\nvar assign$1 = _core.Object.assign;\n\nvar assign = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": assign$1, __esModule: true };\n});\n\nvar _Object$assign = unwrapExports(assign);\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n_export(_export.S, 'Object', {create: _objectCreate});\n\nvar $Object$1 = _core.Object;\nvar create$1 = function create(P, D){\n  return $Object$1.create(P, D);\n};\n\nvar create = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": create$1, __esModule: true };\n});\n\nvar _Object$create = unwrapExports(create);\n\n/**\n * chimee-helper-events v0.1.0\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n/**\n* @module event\n* @author huzunjie\n* @description 自定义事件基础类\n*/\n\n/* 缓存事件监听方法及包装，内部数据格式：\n * targetIndex_<type:'click|mouseup|done'>: [ [\n *   function(){ ... handler ... },\n *   function(){ ... handlerWrap ... handler.apply(target, arguments) ... },\n *   isOnce\n * ]]\n */\nvar _evtListenerCache = _Object$create(null);\n_evtListenerCache.count = 0;\n\n/**\n * 得到某对象的某事件类型对应的监听队列数组\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型(这里的时间类型不只是名称，还是缓存标识，可以通过添加后缀来区分)\n * @return {Array}\n */\nfunction getEvtTypeCache(target, type) {\n\n  var evtId = target.__evt_id;\n  if (!evtId) {\n\n    /* 设置__evt_id不可枚举 */\n    Object.defineProperty(target, '__evt_id', {\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n\n    /* 空对象初始化绑定索引 */\n    evtId = target.__evt_id = ++_evtListenerCache.count;\n  }\n\n  var typeCacheKey = evtId + '_' + type;\n  var evtTypeCache = _evtListenerCache[typeCacheKey];\n  if (!evtTypeCache) {\n    evtTypeCache = _evtListenerCache[typeCacheKey] = [];\n  }\n\n  return evtTypeCache;\n}\n\n/**\n * 触发事件监听方法\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型\n * @param {Object} eventObj 触发事件时要传回的event对象\n * @return {undefined}\n */\nfunction emitEventCache(target, type, eventObj) {\n  var evt = _Object$create(null);\n  evt.type = type;\n  evt.target = target;\n  if (eventObj) {\n    _Object$assign(evt, isObject$1(eventObj) ? eventObj : { data: eventObj });\n  }\n  getEvtTypeCache(target, type).forEach(function (item) {\n    (item[1] || item[0]).apply(target, [evt]);\n  });\n}\n\n/**\n * 添加事件监听到缓存\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型\n * @param {Function} handler 监听函数\n * @param {Boolean} isOnce 是否单次执行\n * @param {Function} handlerWrap\n * @return {undefined}\n */\nfunction addEventCache(target, type, handler) {\n  var isOnce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var handlerWrap = arguments[4];\n\n  if (isFunction(isOnce) && !handlerWrap) {\n    handlerWrap = isOnce;\n    isOnce = undefined;\n  }\n  var handlers = [handler, undefined, isOnce];\n  if (isOnce && !handlerWrap) {\n    handlerWrap = function handlerWrap() {\n      removeEventCache(target, type, handler, isOnce);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      handler.apply(target, args);\n    };\n  }\n  if (handlerWrap) {\n    handlers[1] = handlerWrap;\n  }\n  getEvtTypeCache(target, type).push(handlers);\n}\n\n/**\n * 移除事件监听\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型\n * @param {Function} handler 监听函数\n * @return {undefined}\n */\nfunction removeEventCache(target, type, handler) {\n  var isOnce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  var typeCache = getEvtTypeCache(target, type);\n\n  if (handler || isOnce) {\n    /* 有指定 handler 则清除对应监听 */\n    var handlerId = -1;\n    var handlerWrap = void 0;\n    typeCache.find(function (item, i) {\n      if ((!handler || item[0] === handler) && (!isOnce || item[2])) {\n        handlerId = i;\n        handlerWrap = item[1];\n        return true;\n      }\n    });\n    if (handlerId !== -1) {\n      typeCache.splice(handlerId, 1);\n    }\n    return handlerWrap;\n  } else {\n    /* 未指定 handler 则清除type对应的所有监听 */\n    typeCache.length = 0;\n  }\n}\n\n/**\n * @class CustEvent\n * @description\n * Event 自定义事件类\n * 1. 可以使用不传参得到的实例作为eventBus使用\n * 2. 可以通过指定target，用多个实例操作同一target对象的事件管理\n * 3. 当设定target时，可以通过设置assign为true，来给target实现\"on\\once\\off\\emit\"方法\n * @param  {Object}  target 发生事件的对象（空则默认为event实例）\n * @param  {Boolean}  assign 是否将\"on\\once\\off\\emit\"方法实现到target对象上\n * @return {event}\n */\nvar CustEvent = function () {\n  function CustEvent(target, assign$$1) {\n    var _this = this;\n\n    _classCallCheck(this, CustEvent);\n\n    /* 设置__target不可枚举 */\n    Object.defineProperty(this, '__target', {\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n    this.__target = this;\n\n    if (target) {\n\n      if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== 'object') {\n        throw new Error('CusEvent target are not object');\n      }\n      this.__target = target;\n\n      /* 为target实现on\\once\\off\\emit */\n      if (assign$$1) {\n        ['on', 'once', 'off', 'emit'].forEach(function (mth) {\n          target[mth] = _this[mth];\n        });\n      }\n    }\n  }\n\n  /**\n   * 添加事件监听\n   * @param {String} type 事件类型\n   * @param {Function} handler 监听函数\n   * @param {Boolean} isOnce 单次监听类型\n   * @return {event}\n   */\n\n\n  _createClass(CustEvent, [{\n    key: 'on',\n    value: function on(type, handler) {\n      var isOnce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      addEventCache(this.__target, type, handler, isOnce);\n      return this;\n    }\n\n    /**\n     * 添加事件监听,并且只执行一次\n     * @param {String} type 事件类型\n     * @param {Function} handler 监听函数\n     * @return {event}\n     */\n\n  }, {\n    key: 'once',\n    value: function once(type, handler) {\n      return this.on(type, handler, true);\n    }\n\n    /**\n     * 移除事件监听\n     * @param {String} type 事件类型\n     * @param {Function} handler 监听函数(不指定handler则清除type对应的所有事件监听)\n     * @param {Boolean} isOnce 单次监听类型\n     * @return {event}\n     */\n\n  }, {\n    key: 'off',\n    value: function off(type, handler) {\n      var isOnce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      removeEventCache(this.__target, type, handler, isOnce);\n      return this;\n    }\n\n    /**\n     * 触发事件监听函数\n     * @param {String} type 事件类型\n     * @return {event}\n     */\n\n  }, {\n    key: 'emit',\n    value: function emit(type, data) {\n      emitEventCache(this.__target, type, { data: data });\n      return this;\n    }\n  }]);\n\n  return CustEvent;\n}();\n\n/**\n * chimee-helper-dom v0.1.0\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n/**\n * chimee-helper-events v0.1.0\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n/**\n* @module event\n* @author huzunjie\n* @description 自定义事件基础类\n*/\n\n/* 缓存事件监听方法及包装，内部数据格式：\n * targetIndex_<type:'click|mouseup|done'>: [ [\n *   function(){ ... handler ... },\n *   function(){ ... handlerWrap ... handler.apply(target, arguments) ... },\n *   isOnce\n * ]]\n */\nvar _evtListenerCache$1 = _Object$create(null);\n_evtListenerCache$1.count = 0;\n\n/**\n * 得到某对象的某事件类型对应的监听队列数组\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型(这里的时间类型不只是名称，还是缓存标识，可以通过添加后缀来区分)\n * @return {Array}\n */\nfunction getEvtTypeCache$1(target, type) {\n\n  var evtId = target.__evt_id;\n  if (!evtId) {\n\n    /* 设置__evt_id不可枚举 */\n    Object.defineProperty(target, '__evt_id', {\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n\n    /* 空对象初始化绑定索引 */\n    evtId = target.__evt_id = ++_evtListenerCache$1.count;\n  }\n\n  var typeCacheKey = evtId + '_' + type;\n  var evtTypeCache = _evtListenerCache$1[typeCacheKey];\n  if (!evtTypeCache) {\n    evtTypeCache = _evtListenerCache$1[typeCacheKey] = [];\n  }\n\n  return evtTypeCache;\n}\n\n/**\n * 触发事件监听方法\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型\n * @param {Object} eventObj 触发事件时要传回的event对象\n * @return {undefined}\n */\nfunction emitEventCache$1(target, type, eventObj) {\n  var evt = _Object$create(null);\n  evt.type = type;\n  evt.target = target;\n  if (eventObj) {\n    _Object$assign(evt, isObject$1(eventObj) ? eventObj : { data: eventObj });\n  }\n  getEvtTypeCache$1(target, type).forEach(function (item) {\n    (item[1] || item[0]).apply(target, [evt]);\n  });\n}\n\n/**\n * 添加事件监听到缓存\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型\n * @param {Function} handler 监听函数\n * @param {Boolean} isOnce 是否单次执行\n * @param {Function} handlerWrap\n * @return {undefined}\n */\nfunction addEventCache$1(target, type, handler) {\n  var isOnce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var handlerWrap = arguments[4];\n\n  if (isFunction(isOnce) && !handlerWrap) {\n    handlerWrap = isOnce;\n    isOnce = undefined;\n  }\n  var handlers = [handler, undefined, isOnce];\n  if (isOnce && !handlerWrap) {\n    handlerWrap = function handlerWrap() {\n      removeEventCache$1(target, type, handler, isOnce);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      handler.apply(target, args);\n    };\n  }\n  if (handlerWrap) {\n    handlers[1] = handlerWrap;\n  }\n  getEvtTypeCache$1(target, type).push(handlers);\n}\n\n/**\n * 移除事件监听\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型\n * @param {Function} handler 监听函数\n * @return {undefined}\n */\nfunction removeEventCache$1(target, type, handler) {\n  var isOnce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  var typeCache = getEvtTypeCache$1(target, type);\n\n  if (handler || isOnce) {\n    /* 有指定 handler 则清除对应监听 */\n    var handlerId = -1;\n    var handlerWrap = void 0;\n    typeCache.find(function (item, i) {\n      if ((!handler || item[0] === handler) && (!isOnce || item[2])) {\n        handlerId = i;\n        handlerWrap = item[1];\n        return true;\n      }\n    });\n    if (handlerId !== -1) {\n      typeCache.splice(handlerId, 1);\n    }\n    return handlerWrap;\n  } else {\n    /* 未指定 handler 则清除type对应的所有监听 */\n    typeCache.length = 0;\n  }\n}\n\n/**\n * @class CustEvent\n * @description\n * Event 自定义事件类\n * 1. 可以使用不传参得到的实例作为eventBus使用\n * 2. 可以通过指定target，用多个实例操作同一target对象的事件管理\n * 3. 当设定target时，可以通过设置assign为true，来给target实现\"on\\once\\off\\emit\"方法\n * @param  {Object}  target 发生事件的对象（空则默认为event实例）\n * @param  {Boolean}  assign 是否将\"on\\once\\off\\emit\"方法实现到target对象上\n * @return {event}\n */\nvar CustEvent$1 = function () {\n  function CustEvent(target, assign$$1) {\n    var _this = this;\n\n    _classCallCheck(this, CustEvent);\n\n    /* 设置__target不可枚举 */\n    Object.defineProperty(this, '__target', {\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n    this.__target = this;\n\n    if (target) {\n\n      if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== 'object') {\n        throw new Error('CusEvent target are not object');\n      }\n      this.__target = target;\n\n      /* 为target实现on\\once\\off\\emit */\n      if (assign$$1) {\n        ['on', 'once', 'off', 'emit'].forEach(function (mth) {\n          target[mth] = _this[mth];\n        });\n      }\n    }\n  }\n\n  /**\n   * 添加事件监听\n   * @param {String} type 事件类型\n   * @param {Function} handler 监听函数\n   * @param {Boolean} isOnce 单次监听类型\n   * @return {event}\n   */\n\n\n  _createClass(CustEvent, [{\n    key: 'on',\n    value: function on(type, handler) {\n      var isOnce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      addEventCache$1(this.__target, type, handler, isOnce);\n      return this;\n    }\n\n    /**\n     * 添加事件监听,并且只执行一次\n     * @param {String} type 事件类型\n     * @param {Function} handler 监听函数\n     * @return {event}\n     */\n\n  }, {\n    key: 'once',\n    value: function once(type, handler) {\n      return this.on(type, handler, true);\n    }\n\n    /**\n     * 移除事件监听\n     * @param {String} type 事件类型\n     * @param {Function} handler 监听函数(不指定handler则清除type对应的所有事件监听)\n     * @param {Boolean} isOnce 单次监听类型\n     * @return {event}\n     */\n\n  }, {\n    key: 'off',\n    value: function off(type, handler) {\n      var isOnce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      removeEventCache$1(this.__target, type, handler, isOnce);\n      return this;\n    }\n\n    /**\n     * 触发事件监听函数\n     * @param {String} type 事件类型\n     * @return {event}\n     */\n\n  }, {\n    key: 'emit',\n    value: function emit(type, data) {\n      emitEventCache$1(this.__target, type, { data: data });\n      return this;\n    }\n  }]);\n\n  return CustEvent;\n}();\n\n/**\n * chimee-helper-utils v0.1.1\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n// **********************  judgement   ************************\n/**\n * check if the code running in browser environment (not include worker env)\n * @returns {Boolean}\n */\nvar inBrowser$1 = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\n\n// **********************  对象操作  ************************\n/**\n * 转变一个类数组对象为数组\n */\nfunction makeArray$1(obj) {\n  return _Array$from(obj);\n}\n\n/**\n* @module dom\n* @author huzunjie\n* @description 一些常用的DOM判断及操作方法，可以使用dom.$('*')包装DOM，实现类jQuery的链式操作；当然这里的静态方法也可以直接使用。\n*/\n\nvar _divEl = document.createElement('div');\nvar _textAttrName = 'innerText';\n'textContent' in _divEl && (_textAttrName = 'textContent');\nvar _arrPrototype = Array.prototype;\n\n/**\n * 读取HTML元素属性值\n * @param {HTMLElement} el 目标元素\n * @param {String} attrName 目标属性名称\n * @return {String}\n */\nfunction getAttr(el, attrName) {\n  return el.getAttribute(attrName);\n}\n\n/**\n * 设置HTML元素属性值\n * @param {HTMLElement} el 目标元素\n * @param {String} attrName 目标属性名称\n * @param {String} attrVal 目标属性值\n */\nfunction setAttr(el, attrName, attrVal) {\n  if (attrVal === undefined) {\n    el.removeAttribute(attrName);\n  } else {\n    el.setAttribute(attrName, attrVal);\n  }\n}\n\n/**\n * 为HTML元素添加className\n * @param {HTMLElement} el 目标元素\n * @param {String} cls 要添加的className（多个以空格分割）\n */\nfunction addClassName(el, cls) {\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n  var clsArr = cls.split(/\\s+/);\n  if (el.classList) {\n    clsArr.forEach(function (c) {\n      return el.classList.add(c);\n    });\n  } else {\n    var curCls = ' ' + (el.className || '') + ' ';\n    clsArr.forEach(function (c) {\n      curCls.indexOf(' ' + c + ' ') === -1 && (curCls += ' ' + c);\n    });\n    el.className = curCls.trim();\n  }\n}\n\n/**\n * 为HTML元素移除className\n * @param {HTMLElement} el 目标元素\n * @param {String} cls 要移除的className（多个以空格分割）\n */\nfunction removeClassName(el, cls) {\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n\n  var clsArr = cls.split(/\\s+/);\n  if (el.classList) {\n    clsArr.forEach(function (c) {\n      return el.classList.remove(c);\n    });\n  } else {\n    var curCls = ' ' + el.className + ' ';\n    clsArr.forEach(function (c) {\n      var tar = ' ' + c + ' ';\n      while (curCls.indexOf(tar) !== -1) {\n        curCls = curCls.replace(tar, ' ');\n      }\n    });\n    el.className = curCls.trim();\n  }\n}\n\n/**\n * 检查HTML元素是否已设置className\n * @param {HTMLElement} el 目标元素\n * @param {String} className 要检查的className\n * @return {Boolean}\n */\nfunction hasClassName(el, className) {\n  return new RegExp('(?:^|\\\\s)' + className + '(?=\\\\s|$)').test(el.className);\n}\n\n/**\n * 为HTML元素移除事件监听\n * @param {HTMLElement} el 目标元素\n * @param {String} type 事件名称\n * @param {Function} handler 处理函数\n * @param {Boolean} once 是否只监听一次\n * @param {Boolean} capture 是否在捕获阶段的监听\n */\nfunction removeEvent(el, type, handler) {\n  var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  if (once) {\n    /* 尝试从缓存中读取包装后的方法 */\n    var handlerWrap = removeEventCache$1(el, type + '_once', handler);\n    if (handlerWrap) {\n      handler = handlerWrap;\n    }\n  }\n  el.removeEventListener(type, handler, capture);\n}\n\n/**\n * 为HTML元素添加事件监听\n * @param {HTMLElement} el 目标元素\n * @param {String} type 事件名称\n * @param {Function} handler 处理函数\n * @param {Boolean} once 是否只监听一次\n * @param {Boolean} capture 是否在捕获阶段监听\n */\nfunction addEvent(el, type, handler) {\n  var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  if (once) {\n    var oldHandler = handler;\n    handler = function () {\n      return function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        oldHandler.apply(this, args);\n        removeEvent(el, type, handler, once, capture);\n      };\n    }();\n    /* 将包装后的方法记录到缓存中 */\n    addEventCache$1(el, type + '_once', oldHandler, handler);\n  }\n\n  el.addEventListener(type, handler, capture);\n}\n\n/**\n * 为HTML元素添加事件代理\n * @param {HTMLElement} el 目标元素\n * @param {String} selector 要被代理的元素\n * @param {String} type 事件名称\n * @param {Function} handler 处理函数\n * @param {Boolean} capture 是否在捕获阶段监听\n */\nfunction addDelegate(el, selector, type, handler) {\n  var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n\n  var handlerWrap = function handlerWrap(e) {\n    var targetEls = findParents(e.srcElement, el, true);\n    var targetEl = query(selector, el, true).find(function (seEl) {\n      return targetEls.find(function (tgEl) {\n        return seEl === tgEl;\n      });\n    });\n    targetEl && handler.apply(targetEl, arguments);\n  };\n  /* 将包装后的方法记录到缓存中 */\n  addEventCache$1(el, type + '_delegate_' + selector, handler, handlerWrap);\n  el.addEventListener(type, handlerWrap, capture);\n}\n\n/**\n * 为HTML元素移除事件代理\n * @param {HTMLElement} el 目标元素\n * @param {String} selector 要被代理的元素\n * @param {String} type 事件名称\n * @param {Function} handler 处理函数\n * @param {Boolean} capture 是否在捕获阶段监听\n */\nfunction removeDelegate(el, selector, type, handler) {\n  var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  /* 尝试从缓存中读取包装后的方法 */\n  var handlerWrap = removeEventCache$1(el, type + '_delegate_' + selector, handler);\n  handlerWrap && el.removeEventListener(type, handlerWrap, capture);\n}\n\n/**\n * 读取HTML元素样式值\n * @param {HTMLElement} el 目标元素\n * @param {String} key 样式key\n * @return {String}\n */\nfunction getStyle(el, key) {\n  return (el.currentStyle || document.defaultView.getComputedStyle(el, null))[key] || el.style[key];\n}\n\n/**\n * 设置HTML元素样式值\n * @param {HTMLElement} el 目标元素\n * @param {String} key 样式key\n * @param {String} val 样式值\n */\nfunction setStyle(el, key, val) {\n  if (isObject$1(key)) {\n    for (var k in key) {\n      setStyle(el, k, key[k]);\n    }\n  } else {\n    el.style[key] = val;\n  }\n}\n\n/**\n * 根据选择器查询目标元素\n * @param {String} selector 选择器,用于 querySelectorAll\n * @param {HTMLElement} container 父容器\n * @param {Boolean} toArray 强制输出为数组\n * @return {NodeList|Array}\n */\nfunction query(selector) {\n  var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n  var toArray = arguments[2];\n\n  var retNodeList = container.querySelectorAll(selector);\n  return toArray ? _Array$from(retNodeList) : retNodeList;\n}\n\n/**\n * 从DOM树中移除el\n * @param {HTMLElement} el 目标元素\n */\nfunction removeEl(el) {\n  el.parentNode.removeChild(el);\n}\n\n/**\n * 查找元素的父节点们\n * @param {HTMLElement} el 目标元素\n * @param {HTMLElement} endEl 最大父容器（不指定则找到html）\n * @param {Boolean} haveEl 包含当前元素\n * @param {Boolean} haveEndEl 包含设定的最大父容器\n */\nfunction findParents(el) {\n  var endEl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var haveEl = arguments[2];\n  var haveEndEl = arguments[3];\n\n  var retEls = [];\n  if (haveEl) {\n    retEls.push(el);\n  }\n  while (el && el.parentNode !== endEl) {\n    el = el.parentNode;\n    el && retEls.push(el);\n  }\n  if (haveEndEl) {\n    retEls.push(endEl);\n  }\n  return retEls;\n}\n\n/**\n * 根据选择器查询并得到目标元素的wrap包装器\n * @param {String} selector 选择器,另外支持 HTMLString||NodeList||NodeArray||HTMLElement\n * @param {HTMLElement} container 父容器\n * @return {Object}\n */\nfunction $(selector, container) {\n  return selector.constructor === NodeWrap ? selector : new NodeWrap(selector, container);\n}\n\n/**\n * @class NodeWrap\n * @description\n * NodeWrap DOM包装器，用以实现基本的链式操作\n * new dom.NodeWrap('*') 相当于 dom.$('*')\n * 这里面用于DOM操作的属性方法都是基于上面静态方法实现，有需要可以随时修改补充\n * @param {String} selector 选择器(兼容 String||HTMLString||NodeList||NodeArray||HTMLElement)\n * @param {HTMLElement} container 父容器（默认为document）\n */\n\nvar NodeWrap = function () {\n  function NodeWrap(selector) {\n    var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n\n    _classCallCheck(this, NodeWrap);\n\n    var _this = this;\n    _this.selector = selector;\n\n    /* String||NodeList||HTMLElement 识别处理 */\n    var elsArr = void 0;\n    if (selector && selector.constructor === NodeList) {\n      /* 支持直接传入NodeList来构建包装器 */\n      elsArr = makeArray$1(selector);\n    } else if (isArray(selector)) {\n      /* 支持直接传入Node数组来构建包装器 */\n      elsArr = selector;\n    } else if (isString(selector)) {\n      if (selector.indexOf('<') === 0) {\n        /* 支持直接传入HTML字符串来新建DOM并构建包装器 */\n        _divEl.innerHTML = selector;\n        elsArr = query('*', _divEl, true);\n      } else {\n        /* 支持直接传入字符串选择器来查找DOM并构建包装器 */\n        elsArr = query(selector, container, true);\n      }\n    } else {\n      /* 其他任意对象直接构建包装器 */\n      elsArr = [selector];\n    }\n    _Object$assign(_this, elsArr);\n\n    /* NodeWrap本意可以 extends Array省略构造方法中下面这部分代码，但目前编译不支持 */\n    _this.length = elsArr.length;\n  }\n\n  /**\n   * 循环遍历DOM集合\n   * @param {Function} fn 遍历函数 fn(item, i)\n   * @return {Object}\n   */\n\n\n  _createClass(NodeWrap, [{\n    key: 'each',\n    value: function each() {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _arrPrototype.forEach.apply(this, args);\n      return this;\n    }\n  }, {\n    key: 'push',\n\n\n    /**\n     * 添加元素到DOM集合\n     * @param {HTMLElement} el 要加入的元素\n     * @return {this}\n     */\n    value: function push() {\n      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      _arrPrototype.push.apply(this, args);\n      return this;\n    }\n  }, {\n    key: 'splice',\n\n\n    /**\n     * 截取DOM集合片段，并得到新的包装器splice\n     * @param {Nubmer} start\n     * @param {Nubmer} count\n     * @return {NodeWrap} 新的DOM集合包装器\n     */\n    value: function splice() {\n      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return $(_arrPrototype.splice.apply(this, args));\n    }\n  }, {\n    key: 'find',\n\n\n    /**\n     * 查找子元素\n     * @param {String} selector 选择器\n     * @return {NodeWrap} 新的DOM集合包装器\n     */\n    value: function find(selector) {\n      var childs = [];\n      this.each(function (el) {\n        childs = childs.concat(query(selector, el, true));\n      });\n      var childsWrap = $(childs);\n      childsWrap.parent = this;\n      childsWrap.selector = selector;\n      return childsWrap;\n    }\n\n    /**\n     * 添加子元素\n     * @param {HTMLElement} childEls 要添加的HTML元素\n     * @return {this}\n     */\n\n  }, {\n    key: 'append',\n    value: function append(childEls) {\n      var childsWrap = $(childEls);\n      var firstEl = this[0];\n      childsWrap.each(function (newEl) {\n        return firstEl.appendChild(newEl);\n      });\n      return this;\n    }\n\n    /**\n     * 将元素集合添加到指定容器\n     * @param {HTMLElement} parentEl 要添加到父容器\n     * @return {this}\n     */\n\n  }, {\n    key: 'appendTo',\n    value: function appendTo(parentEl) {\n      $(parentEl).append(this);\n      return this;\n    }\n\n    /**\n     * DOM集合text内容读写操作\n     * @param {String} val 文本内容（如果有设置该参数则执行写操作，否则执行读操作）\n     * @return {this}\n     */\n\n  }, {\n    key: 'text',\n    value: function text(val) {\n      if (arguments.length === 0) {\n        return this[0][_textAttrName];\n      }\n      return this.each(function (el) {\n        el[_textAttrName] = val;\n      });\n    }\n\n    /**\n     * DOM集合HTML内容读写操作\n     * @param {String} html html内容（如果有设置该参数则执行写操作，否则执行读操作）\n     * @return {this}\n     */\n\n  }, {\n    key: 'html',\n    value: function html(_html) {\n      if (arguments.length === 0) {\n        return this[0].innerHTML;\n      }\n      return this.each(function (el) {\n        el.innerHTML = _html;\n      });\n    }\n\n    /**\n     * DOM集合属性读写操作\n     * @param {String} name 属性名称\n     * @param {String} val 属性值（如果有设置该参数则执行写操作，否则执行读操作）\n     * @return {this}\n     */\n\n  }, {\n    key: 'attr',\n    value: function attr(name, val) {\n      if (arguments.length === 1) {\n        return getAttr(this[0], name);\n      }\n      return this.each(function (el) {\n        return setAttr(el, name, val);\n      });\n    }\n\n    /**\n     * DOM集合dataset读写操作\n     * @param {String} key 键名\n     * @param {Any} val 键值（如果有设置该参数则执行写操作，否则执行读操作）\n     * @return {this}\n     */\n\n  }, {\n    key: 'data',\n    value: function data(key, val) {\n      if (arguments.length === 0) {\n        return this[0].dataset || {};\n      }\n      if (arguments.length === 1) {\n        return (this[0].dataset || {})[key];\n      }\n      return this.each(function (el) {\n        (el.dataset || (el.dataset = {}))[key] = val;\n      });\n    }\n\n    /**\n     * DOM集合样式读写操作\n     * @param {String} key 样式key\n     * @param {String} val 样式值（如果有设置该参数则执行写操作，否则执行读操作）\n     * @return {this}\n     */\n\n  }, {\n    key: 'css',\n    value: function css(key, val) {\n      if (arguments.length === 1 && !isObject$1(key)) {\n        return getStyle(this[0], key);\n      }\n      return this.each(function (el) {\n        return setStyle(el, key, val);\n      });\n    }\n\n    /**\n     * 为DOM集合增加className\n     * @param {String} cls 要增加的className\n     * @return {this}\n     */\n\n  }, {\n    key: 'addClass',\n    value: function addClass(cls) {\n      return this.each(function (el) {\n        return addClassName(el, cls);\n      });\n    }\n\n    /**\n     * 移除当前DOM集合的className\n     * @param {String} cls 要移除的className\n     * @return {this}\n     */\n\n  }, {\n    key: 'removeClass',\n    value: function removeClass(cls) {\n      return this.each(function (el) {\n        return removeClassName(el, cls);\n      });\n    }\n\n    /**\n     * 检查索引0的DOM是否有className\n     * @param {String} cls 要检查的className\n     * @return {this}\n     */\n\n  }, {\n    key: 'hasClass',\n    value: function hasClass(cls) {\n      return hasClassName(this[0], cls);\n    }\n\n    /**\n     * 为DOM集合添加事件监听\n     * @param {String} type 事件名称\n     * @param {Function} handler 处理函数\n     * @param {Boolean} once 是否只监听一次\n     * @param {Boolean} capture 是否在捕获阶段监听\n     * @return {this}\n     */\n\n  }, {\n    key: 'on',\n    value: function on(type, handler) {\n      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      return this.each(function (el) {\n        return addEvent(el, type, handler, once, capture);\n      });\n    }\n\n    /**\n     * 为DOM集合解除事件监听\n     * @param {String} type 事件名称\n     * @param {Function} handler 处理函数\n     * @param {Boolean} once 是否只监听一次\n     * @param {Boolean} capture 是否在捕获阶段监听\n     * @return {this}\n     */\n\n  }, {\n    key: 'off',\n    value: function off(type, handler) {\n      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      return this.each(function (el) {\n        return removeEvent(el, type, handler, once, capture);\n      });\n    }\n\n    /**\n     * 为DOM集合绑定事件代理\n     * @param {String} selector 目标子元素选择器\n     * @param {String} type 事件名称\n     * @param {Function} handler 处理函数\n     * @param {Boolean} capture 是否在捕获阶段监听\n     * @return {this}\n     */\n\n  }, {\n    key: 'delegate',\n    value: function delegate(selector, type, handler) {\n      var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      return this.each(function (el) {\n        return addDelegate(el, selector, type, handler, capture);\n      });\n    }\n\n    /**\n     * 为DOM集合解绑事件代理\n     * @param {String} selector 目标子元素选择器\n     * @param {String} type 事件名称\n     * @param {Function} handler 处理函数\n     * @param {Boolean} capture 是否在捕获阶段监听\n     * @return {this}\n     */\n\n  }, {\n    key: 'undelegate',\n    value: function undelegate(selector, type, handler) {\n      var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      return this.each(function (el) {\n        return removeDelegate(el, selector, type, handler, capture);\n      });\n    }\n\n    /**\n     * 从DOM树中移除\n     * @return {this}\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove() {\n      return this.each(function (el) {\n        return removeEl(el);\n      });\n    }\n  }]);\n\n  return NodeWrap;\n}();\n\n/**\n * chimee-helper-log v0.1.0\n * (c) 2017 songguangyu\n * Released under MIT\n */\n\nvar Log = function () {\n  function Log() {\n    _classCallCheck(this, Log);\n  }\n\n  _createClass(Log, null, [{\n    key: 'error',\n    value: function error(tag, msg) {\n      if (!Log.ENABLE_ERROR) {\n        return;\n      }\n\n      if (!tag || Log.FORCE_GLOBAL_TAG) {\n        tag = Log.GLOBAL_TAG;\n      }\n      var str = '[' + tag + '] > ' + msg;\n\n      if (console.error) {\n        console.error(str);\n      } else if (console.warn) {\n        console.warn(str);\n      } else {\n        console.log(str);\n      }\n    }\n  }, {\n    key: 'info',\n    value: function info(tag, msg) {\n      if (!Log.ENABLE_INFO) {\n        return;\n      }\n\n      if (!tag || Log.FORCE_GLOBAL_TAG) {\n        tag = Log.GLOBAL_TAG;\n      }\n\n      var str = '[' + tag + '] > ' + msg;\n\n      if (console.info) {\n        console.info(str);\n      } else {\n        console.log(str);\n      }\n    }\n  }, {\n    key: 'warn',\n    value: function warn(tag, msg) {\n      if (!Log.ENABLE_WARN) {\n        return;\n      }\n\n      if (!tag || Log.FORCE_GLOBAL_TAG) {\n        tag = Log.GLOBAL_TAG;\n      }\n\n      var str = '[' + tag + '] > ' + msg;\n\n      if (console.warn) {\n        console.warn(str);\n      } else {\n        console.log(str);\n      }\n    }\n  }, {\n    key: 'debug',\n    value: function debug(tag, msg) {\n      if (!Log.ENABLE_DEBUG) {\n        return;\n      }\n\n      if (!tag || Log.FORCE_GLOBAL_TAG) {\n        tag = Log.GLOBAL_TAG;\n      }\n\n      var str = '[' + tag + '] > ' + msg;\n\n      if (console.debug) {\n        console.debug(str);\n      } else {\n        console.log(str);\n      }\n    }\n  }, {\n    key: 'verbose',\n    value: function verbose(tag, msg) {\n      if (!Log.ENABLE_VERBOSE) {\n        return;\n      }\n\n      if (!tag || Log.FORCE_GLOBAL_TAG) {\n        tag = Log.GLOBAL_TAG;\n      }\n\n      console.log('[' + tag + '] > ' + msg);\n    }\n  }]);\n\n  return Log;\n}();\n\nLog.GLOBAL_TAG = 'chimee';\nLog.FORCE_GLOBAL_TAG = false;\nLog.ENABLE_ERROR = true;\nLog.ENABLE_INFO = true;\nLog.ENABLE_WARN = true;\nLog.ENABLE_DEBUG = true;\nLog.ENABLE_VERBOSE = true;\n\nexports.Log = Log;\nexports.genTraversalHandler = genTraversalHandler;\nexports.deepClone = deepClone;\nexports.deepAssign = deepAssign;\nexports.camelize = camelize;\nexports.hypenate = hypenate;\nexports.bind = bind;\nexports.uuid = uuid;\nexports.S4 = S4;\nexports.rand = rand;\nexports.isVoid = isVoid;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isObject = isObject$1;\nexports.isNumber = isNumber;\nexports.isNumeric = isNumeric;\nexports.isInteger = isInteger;\nexports.isEmpty = isEmpty;\nexports.isEvent = isEvent;\nexports.isBlob = isBlob;\nexports.isFile = isFile;\nexports.isDate = isDate;\nexports.isString = isString;\nexports.isBoolean = isBoolean;\nexports.isPromise = isPromise;\nexports.isPrimitive = isPrimitive;\nexports.isUrl = isUrl;\nexports.isNode = isNode;\nexports.isElement = isElement;\nexports.isChildNode = isChildNode;\nexports.isPosterityNode = isPosterityNode;\nexports.isHTMLString = isHTMLString;\nexports.isError = isError;\nexports.inBrowser = inBrowser;\nexports.makeArray = makeArray;\nexports.transObjectAttrIntoArray = transObjectAttrIntoArray;\nexports.runRejectableQueue = runRejectableQueue;\nexports.runStoppableQueue = runStoppableQueue;\nexports.setFrozenAttr = setFrozenAttr;\nexports.setAttrGetterAndSetter = setAttrGetterAndSetter;\nexports.decodeUTF8 = decodeUTF8;\nexports.debounce = debounce;\nexports.throttle = throttle;\nexports.raf = raf;\nexports.caf = caf;\nexports.strRepeat = strRepeat;\nexports.formatTime = formatTime;\nexports.addTransMethod = addTransMethod;\nexports.appendCSS = appendCSS;\nexports.formatDate = formatDate;\nexports.getLocalStorage = getLocalStorage;\nexports.setLocalStorage = setLocalStorage;\nexports.emitEventCache = emitEventCache;\nexports.addEventCache = addEventCache;\nexports.removeEventCache = removeEventCache;\nexports.CustEvent = CustEvent;\nexports.getAttr = getAttr;\nexports.setAttr = setAttr;\nexports.addClassName = addClassName;\nexports.removeClassName = removeClassName;\nexports.hasClassName = hasClassName;\nexports.removeEvent = removeEvent;\nexports.addEvent = addEvent;\nexports.addDelegate = addDelegate;\nexports.removeDelegate = removeDelegate;\nexports.getStyle = getStyle;\nexports.setStyle = setStyle;\nexports.query = query;\nexports.removeEl = removeEl;\nexports.findParents = findParents;\nexports.$ = $;\nexports.NodeWrap = NodeWrap;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1oZWxwZXIvbGliL2luZGV4LmJyb3dzZXIuanM/YWIxNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixZQUFZLEVBQUU7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLENBQUM7O0FBRUQ7QUFDQSw2QkFBNkI7QUFDN0IscUNBQXFDO0FBQ3JDLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUSxnQkFBZ0IsVUFBVSxHQUFHO0FBQ3RFLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCxnQkFBZ0IsVUFBVSxHQUFHO0FBQ3JGLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxVQUFVO0FBQ2I7QUFDQTtBQUNB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QUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtB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T0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxjQUFjOztBQUU1RCxDQUFDIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogY2hpbWVlLWhlbHBlciB2MC4xLjhcbiAqIChjKSAyMDE3IHRveGljLWpvaGFublxuICogUmVsZWFzZWQgdW5kZXIgTUlUXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmNoaW1lZUhlbHBlciA9IGdsb2JhbC5jaGltZWVIZWxwZXIgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHVud3JhcEV4cG9ydHMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBfdG9JbnRlZ2VyID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cbi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG52YXIgX2RlZmluZWQgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG52YXIgX3N0cmluZ0F0ID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG4gICAgdmFyIHMgPSBTdHJpbmcoX2RlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSBfdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG52YXIgX2xpYnJhcnkgPSB0cnVlO1xuXG52YXIgX2dsb2JhbCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbn0pO1xuXG52YXIgX2NvcmUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG52YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG59KTtcblxudmFyIF9hRnVuY3Rpb24gPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG5cbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xuXG52YXIgX2N0eCA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBfYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxudmFyIF9pc09iamVjdCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBfYW5PYmplY3QgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFfaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxudmFyIF9mYWlscyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxudmFyIF9kZXNjcmlwdG9ycyA9ICFfZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG52YXIgZG9jdW1lbnQkMSA9IF9nbG9iYWwuZG9jdW1lbnQ7XG52YXIgaXMgPSBfaXNPYmplY3QoZG9jdW1lbnQkMSkgJiYgX2lzT2JqZWN0KGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCk7XG52YXIgX2RvbUNyZWF0ZSA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxudmFyIF9pZThEb21EZWZpbmUgPSAhX2Rlc2NyaXB0b3JzICYmICFfZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZG9tQ3JlYXRlKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG4vLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcblxuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG52YXIgX3RvUHJpbWl0aXZlID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighX2lzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhX2lzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhX2lzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIV9pc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxudmFyIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgZiA9IF9kZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBfYW5PYmplY3QoTyk7XG4gIFAgPSBfdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIF9hbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoX2llOERvbURlZmluZSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cbnZhciBfb2JqZWN0RHAgPSB7XG5cdGY6IGZcbn07XG5cbnZhciBfcHJvcGVydHlEZXNjID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxudmFyIF9oaWRlID0gX2Rlc2NyaXB0b3JzID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIF9vYmplY3REcC5mKG9iamVjdCwga2V5LCBfcHJvcGVydHlEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gX2NvcmUgOiBfY29yZVtuYW1lXSB8fCAoX2NvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gX2dsb2JhbCA6IElTX1NUQVRJQyA/IF9nbG9iYWxbbmFtZV0gOiAoX2dsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBfY3R4KG91dCwgX2dsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG4gICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEM7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IF9jdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZihJU19QUk9UTyl7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSlfaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG52YXIgX2V4cG9ydCA9ICRleHBvcnQ7XG5cbnZhciBfcmVkZWZpbmUgPSBfaGlkZTtcblxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgX2hhcyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cbnZhciBfaXRlcmF0b3JzID0ge307XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgX2NvZiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5cbnZhciBfaW9iamVjdCA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gX2NvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG5cbnZhciBfdG9Jb2JqZWN0ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gX2lvYmplY3QoX2RlZmluZWQoaXQpKTtcbn07XG5cbi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIG1pbiAgICAgICA9IE1hdGgubWluO1xudmFyIF90b0xlbmd0aCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbihfdG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG52YXIgbWF4ICAgICAgID0gTWF0aC5tYXg7XG52YXIgbWluJDEgICAgICAgPSBNYXRoLm1pbjtcbnZhciBfdG9JbmRleCA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IF90b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbiQxKGluZGV4LCBsZW5ndGgpO1xufTtcblxuLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcblxudmFyIF9hcnJheUluY2x1ZGVzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSBfdG9Jb2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSBfdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IF90b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuICAgICAgLCB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSAgPSBfZ2xvYmFsW1NIQVJFRF0gfHwgKF9nbG9iYWxbU0hBUkVEXSA9IHt9KTtcbnZhciBfc2hhcmVkID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG52YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbnZhciBfdWlkID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cbnZhciBzaGFyZWQgPSBfc2hhcmVkKCdrZXlzJyk7XG52YXIgX3NoYXJlZEtleSA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSBfdWlkKGtleSkpO1xufTtcblxudmFyIGFycmF5SW5kZXhPZiA9IF9hcnJheUluY2x1ZGVzKGZhbHNlKTtcbnZhciBJRV9QUk9UTyQxICAgICA9IF9zaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cbnZhciBfb2JqZWN0S2V5c0ludGVybmFsID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XG4gIHZhciBPICAgICAgPSBfdG9Jb2JqZWN0KG9iamVjdClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8kMSlfaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKF9oYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbnZhciBfZW51bUJ1Z0tleXMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG5cbi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxuXG5cbnZhciBfb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiBfb2JqZWN0S2V5c0ludGVybmFsKE8sIF9lbnVtQnVnS2V5cyk7XG59O1xuXG52YXIgX29iamVjdERwcyA9IF9kZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcbiAgX2FuT2JqZWN0KE8pO1xuICB2YXIga2V5cyAgID0gX29iamVjdEtleXMoUHJvcGVydGllcylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpID0gMFxuICAgICwgUDtcbiAgd2hpbGUobGVuZ3RoID4gaSlfb2JqZWN0RHAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgX2h0bWwgPSBfZ2xvYmFsLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgSUVfUFJPVE8gICAgPSBfc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUkMSAgID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IF9kb21DcmVhdGUoJ2lmcmFtZScpXG4gICAgLCBpICAgICAgPSBfZW51bUJ1Z0tleXMubGVuZ3RoXG4gICAgLCBsdCAgICAgPSAnPCdcbiAgICAsIGd0ICAgICA9ICc+J1xuICAgICwgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBfaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFJDFdW19lbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG52YXIgX29iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xuICB2YXIgcmVzdWx0O1xuICBpZihPICE9PSBudWxsKXtcbiAgICBFbXB0eVtQUk9UT1RZUEUkMV0gPSBfYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xuICAgIEVtcHR5W1BST1RPVFlQRSQxXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogX29iamVjdERwcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxudmFyIF93a3MgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG52YXIgc3RvcmUgICAgICA9IF9zaGFyZWQoJ3drcycpXG4gICwgU3ltYm9sICAgICA9IF9nbG9iYWwuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiBfdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xufSk7XG5cbnZhciBkZWYgPSBfb2JqZWN0RHAuZjtcbnZhciBUQUcgPSBfd2tzKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgX3NldFRvU3RyaW5nVGFnID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICFfaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59O1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbl9oaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBfd2tzKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbnZhciBfaXRlckNyZWF0ZSA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gX29iamVjdENyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IF9wcm9wZXJ0eURlc2MoMSwgbmV4dCl9KTtcbiAgX3NldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxuXG52YXIgX3RvT2JqZWN0ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KF9kZWZpbmVkKGl0KSk7XG59O1xuXG4vLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIElFX1BST1RPJDIgICAgPSBfc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxudmFyIF9vYmplY3RHcG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTyl7XG4gIE8gPSBfdG9PYmplY3QoTyk7XG4gIGlmKF9oYXMoTywgSUVfUFJPVE8kMikpcmV0dXJuIE9bSUVfUFJPVE8kMl07XG4gIGlmKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG5cbnZhciBJVEVSQVRPUiAgICAgICA9IF93a3MoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7XG52YXIgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyAgICAgICAgICAgPSAna2V5cyc7XG52YXIgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxudmFyIF9pdGVyRGVmaW5lID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcbiAgX2l0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oa2luZCl7XG4gICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXG4gICAgLCBWQUxVRVNfQlVHID0gZmFsc2VcbiAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgJGRlZmF1bHQgICA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG4gICAgLCAkZW50cmllcyAgID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZFxuICAgICwgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmVcbiAgICAsIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoJGFueU5hdGl2ZSl7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBfb2JqZWN0R3BvKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIF9zZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYoIV9saWJyYXJ5ICYmICFfaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpX2hpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZihERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCghX2xpYnJhcnkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgX2hpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBfaXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIF9pdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpX3JlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlIF9leHBvcnQoX2V4cG9ydC5QICsgX2V4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cbnZhciAkYXQgID0gX3N0cmluZ0F0KHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5faXRlckRlZmluZShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTtcblxuLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxuXG52YXIgX2l0ZXJDYWxsID0gZnVuY3Rpb24oaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihfYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2goZSl7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZihyZXQgIT09IHVuZGVmaW5lZClfYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSVRFUkFUT1IkMSAgID0gX3drcygnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgX2lzQXJyYXlJdGVyID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoX2l0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUiQxXSA9PT0gaXQpO1xufTtcblxudmFyIF9jcmVhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iamVjdCwgaW5kZXgsIHZhbHVlKXtcbiAgaWYoaW5kZXggaW4gb2JqZWN0KV9vYmplY3REcC5mKG9iamVjdCwgaW5kZXgsIF9wcm9wZXJ0eURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIFRBRyQxID0gX3drcygndG9TdHJpbmdUYWcnKTtcbnZhciBBUkcgPSBfY29mKGZ1bmN0aW9uKCl7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbn07XG5cbnZhciBfY2xhc3NvZiA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUckMSkpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gX2NvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gX2NvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG52YXIgSVRFUkFUT1IkMiAgPSBfd2tzKCdpdGVyYXRvcicpO1xudmFyIGNvcmVfZ2V0SXRlcmF0b3JNZXRob2QgPSBfY29yZS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUiQyXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBfaXRlcmF0b3JzW19jbGFzc29mKGl0KV07XG59O1xuXG52YXIgSVRFUkFUT1IkMyAgICAgPSBfd2tzKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1IkM10oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24oKXsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24oKXsgdGhyb3cgMjsgfSk7XG59IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5cbnZhciBfaXRlckRldGVjdCA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbSVRFUkFUT1IkM10oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbigpeyByZXR1cm4ge2RvbmU6IHNhZmUgPSB0cnVlfTsgfTtcbiAgICBhcnJbSVRFUkFUT1IkM10gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuXG5fZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqICFfaXRlckRldGVjdChmdW5jdGlvbihpdGVyKXsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZS8qLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCovKXtcbiAgICB2YXIgTyAgICAgICA9IF90b09iamVjdChhcnJheUxpa2UpXG4gICAgICAsIEMgICAgICAgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5XG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpbmRleCAgID0gMFxuICAgICAgLCBpdGVyRm4gID0gY29yZV9nZXRJdGVyYXRvck1ldGhvZChPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IF9jdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZihpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBfaXNBcnJheUl0ZXIoaXRlckZuKSkpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xuICAgICAgICBfY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IF9pdGVyQ2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IF90b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICBfY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxudmFyIGZyb20kMSA9IF9jb3JlLkFycmF5LmZyb207XG5cbnZhciBmcm9tID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBmcm9tJDEsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG52YXIgX0FycmF5JGZyb20gPSB1bndyYXBFeHBvcnRzKGZyb20pO1xuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXG5cbnZhciBfZnJvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGZyb20pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnIyW2ldID0gYXJyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX2Zyb20yLmRlZmF1bHQpKGFycik7XG4gIH1cbn07XG59KTtcblxudmFyIF90b0NvbnN1bWFibGVBcnJheSA9IHVud3JhcEV4cG9ydHModG9Db25zdW1hYmxlQXJyYXkpO1xuXG52YXIgX2FkZFRvVW5zY29wYWJsZXMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgX2l0ZXJTdGVwID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnZhciBlczZfYXJyYXlfaXRlcmF0b3IgPSBfaXRlckRlZmluZShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICB0aGlzLl90ID0gX3RvSW9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gX2l0ZXJTdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIF9pdGVyU3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIF9pdGVyU3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBfaXRlclN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5faXRlcmF0b3JzLkFyZ3VtZW50cyA9IF9pdGVyYXRvcnMuQXJyYXk7XG5cbl9hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5fYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5fYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IF93a3MoJ3RvU3RyaW5nVGFnJyk7XG5cbmZvcih2YXIgY29sbGVjdGlvbnMgPSBbJ05vZGVMaXN0JywgJ0RPTVRva2VuTGlzdCcsICdNZWRpYUxpc3QnLCAnU3R5bGVTaGVldExpc3QnLCAnQ1NTUnVsZUxpc3QnXSwgaSA9IDA7IGkgPCA1OyBpKyspe1xuICB2YXIgTkFNRSAgICAgICA9IGNvbGxlY3Rpb25zW2ldXG4gICAgLCBDb2xsZWN0aW9uID0gX2dsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSlfaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gIF9pdGVyYXRvcnNbTkFNRV0gPSBfaXRlcmF0b3JzLkFycmF5O1xufVxuXG52YXIgZiQxID0gX3drcztcblxudmFyIF93a3NFeHQgPSB7XG5cdGY6IGYkMVxufTtcblxudmFyIGl0ZXJhdG9yJDIgPSBfd2tzRXh0LmYoJ2l0ZXJhdG9yJyk7XG5cbnZhciBpdGVyYXRvciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogaXRlcmF0b3IkMiwgX19lc01vZHVsZTogdHJ1ZSB9O1xufSk7XG5cbnZhciBfbWV0YSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbnZhciBNRVRBICAgICA9IF91aWQoJ21ldGEnKVxuICAsIHNldERlc2MgID0gX29iamVjdERwLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIV9mYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIV9pc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIV9oYXMoaXQsIE1FVEEpKXtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIGlmKCFfaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhX2hhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbn0pO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBfb2JqZWN0RHAuZjtcbnZhciBfd2tzRGVmaW5lID0gZnVuY3Rpb24obmFtZSl7XG4gIHZhciAkU3ltYm9sID0gX2NvcmUuU3ltYm9sIHx8IChfY29yZS5TeW1ib2wgPSBfbGlicmFyeSA/IHt9IDogX2dsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogX3drc0V4dC5mKG5hbWUpfSk7XG59O1xuXG52YXIgX2tleW9mID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSBfdG9Jb2JqZWN0KG9iamVjdClcbiAgICAsIGtleXMgICA9IF9vYmplY3RLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTtcblxudmFyIGYkMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbnZhciBfb2JqZWN0R29wcyA9IHtcblx0ZjogZiQyXG59O1xuXG52YXIgZiQzID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbnZhciBfb2JqZWN0UGllID0ge1xuXHRmOiBmJDNcbn07XG5cbi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG5cbnZhciBfZW51bUtleXMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciByZXN1bHQgICAgID0gX29iamVjdEtleXMoaXQpXG4gICAgLCBnZXRTeW1ib2xzID0gX29iamVjdEdvcHMuZjtcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gX29iamVjdFBpZS5mXG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcblxudmFyIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZyl7XG4gIHJldHVybiBfY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cbi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciBoaWRkZW5LZXlzID0gX2VudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG52YXIgZiQ1ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKXtcbiAgcmV0dXJuIF9vYmplY3RLZXlzSW50ZXJuYWwoTywgaGlkZGVuS2V5cyk7XG59O1xuXG52YXIgX29iamVjdEdvcG4gPSB7XG5cdGY6IGYkNVxufTtcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIGdPUE4kMSAgICAgID0gX29iamVjdEdvcG4uZjtcbnZhciB0b1N0cmluZyQxICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOJDEoaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG52YXIgZiQ0ID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZyQxLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTiQxKF90b0lvYmplY3QoaXQpKTtcbn07XG5cbnZhciBfb2JqZWN0R29wbkV4dCA9IHtcblx0ZjogZiQ0XG59O1xuXG52YXIgZ09QRCQxICAgICAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbnZhciBmJDYgPSBfZGVzY3JpcHRvcnMgPyBnT1BEJDEgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XG4gIE8gPSBfdG9Jb2JqZWN0KE8pO1xuICBQID0gX3RvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZihfaWU4RG9tRGVmaW5lKXRyeSB7XG4gICAgcmV0dXJuIGdPUEQkMShPLCBQKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZihfaGFzKE8sIFApKXJldHVybiBfcHJvcGVydHlEZXNjKCFfb2JqZWN0UGllLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG52YXIgX29iamVjdEdvcGQgPSB7XG5cdGY6IGYkNlxufTtcblxuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIE1FVEEgICAgICAgICAgID0gX21ldGEuS0VZO1xudmFyIGdPUEQgICAgICAgICAgID0gX29iamVjdEdvcGQuZjtcbnZhciBkUCQyICAgICAgICAgICAgID0gX29iamVjdERwLmY7XG52YXIgZ09QTiAgICAgICAgICAgPSBfb2JqZWN0R29wbkV4dC5mO1xudmFyICRTeW1ib2wgICAgICAgID0gX2dsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gICAgICAgICAgPSBfZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFJDIgICAgICA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiAgICAgICAgID0gX3drcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSAgID0gX3drcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gX3NoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyAgICAgPSBfc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzICAgICAgPSBfc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8kMSAgICA9IE9iamVjdFtQUk9UT1RZUEUkMl07XG52YXIgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xudmFyIFFPYmplY3QgICAgICAgID0gX2dsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFJDJdIHx8ICFRT2JqZWN0W1BST1RPVFlQRSQyXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBfZGVzY3JpcHRvcnMgJiYgX2ZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBfb2JqZWN0Q3JlYXRlKGRQJDIoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQJDIodGhpcywgJ2EnLCB7dmFsdWU6IDd9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90byQxLCBrZXkpO1xuICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvJDFba2V5XTtcbiAgZFAkMihpdCwga2V5LCBEKTtcbiAgaWYocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90byQxKWRQJDIoT2JqZWN0UHJvdG8kMSwga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQJDI7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9vYmplY3RDcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEUkMl0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvJDEpJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgX2FuT2JqZWN0KGl0KTtcbiAga2V5ID0gX3RvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIF9hbk9iamVjdChEKTtcbiAgaWYoX2hhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFfaGFzKGl0LCBISURERU4pKWRQJDIoaXQsIEhJRERFTiwgX3Byb3BlcnR5RGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoX2hhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX29iamVjdENyZWF0ZShELCB7ZW51bWVyYWJsZTogX3Byb3BlcnR5RGVzYygwLCBmYWxzZSl9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUCQyKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBfYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IF9lbnVtS2V5cyhQID0gX3RvSW9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfb2JqZWN0Q3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9vYmplY3RDcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSBfdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmKHRoaXMgPT09IE9iamVjdFByb3RvJDEgJiYgX2hhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFfaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFfaGFzKHRoaXMsIGtleSkgfHwgIV9oYXMoQWxsU3ltYm9scywga2V5KSB8fCBfaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgaXQgID0gX3RvSW9iamVjdChpdCk7XG4gIGtleSA9IF90b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8kMSAmJiBfaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIV9oYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZihEICYmIF9oYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKF9oYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdPUE4oX3RvSW9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcbiAgICBpZighX2hhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG8kMVxuICAgICwgbmFtZXMgID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IF90b0lvYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoX2hhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBfaGFzKE9iamVjdFByb3RvJDEsIGtleSkgOiB0cnVlKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCFVU0VfTkFUSVZFKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSBfdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmKHRoaXMgPT09IE9iamVjdFByb3RvJDEpJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYoX2hhcyh0aGlzLCBISURERU4pICYmIF9oYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgX3Byb3BlcnR5RGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoX2Rlc2NyaXB0b3JzICYmIHNldHRlcilzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvJDEsIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgX3JlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFJDJdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICBfb2JqZWN0R29wZC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgX29iamVjdERwLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgX29iamVjdEdvcG4uZiA9IF9vYmplY3RHb3BuRXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgX29iamVjdFBpZS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgX29iamVjdEdvcHMuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoX2Rlc2NyaXB0b3JzICYmICFfbGlicmFyeSl7XG4gICAgX3JlZGVmaW5lKE9iamVjdFByb3RvJDEsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICBfd2tzRXh0LmYgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gd3JhcChfd2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuX2V4cG9ydChfZXhwb3J0LkcgKyBfZXhwb3J0LlcgKyBfZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1N5bWJvbDogJFN5bWJvbH0pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaSQxID0gMDsgc3ltYm9scy5sZW5ndGggPiBpJDE7IClfd2tzKHN5bWJvbHNbaSQxKytdKTtcblxuZm9yKHZhciBzeW1ib2xzID0gX29iamVjdEtleXMoX3drcy5zdG9yZSksIGkkMSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaSQxOyApX3drc0RlZmluZShzeW1ib2xzW2kkMSsrXSk7XG5cbl9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gX2hhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuICAgIGlmKGlzU3ltYm9sKGtleSkpcmV0dXJuIF9rZXlvZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbl9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmIF9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8IF9mYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFfaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEUkMl1bVE9fUFJJTUlUSVZFXSB8fCBfaGlkZSgkU3ltYm9sW1BST1RPVFlQRSQyXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRSQyXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbl9zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5fc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5fc2V0VG9TdHJpbmdUYWcoX2dsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5fd2tzRGVmaW5lKCdhc3luY0l0ZXJhdG9yJyk7XG5cbl93a3NEZWZpbmUoJ29ic2VydmFibGUnKTtcblxudmFyIGluZGV4ID0gX2NvcmUuU3ltYm9sO1xuXG52YXIgc3ltYm9sID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBpbmRleCwgX19lc01vZHVsZTogdHJ1ZSB9O1xufSk7XG5cbnZhciBfdHlwZW9mXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChpdGVyYXRvcik7XG5cblxuXG52YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHN5bWJvbCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59O1xufSk7XG5cbnZhciBfdHlwZW9mID0gdW53cmFwRXhwb3J0cyhfdHlwZW9mXzEpO1xuXG4vLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcblxudmFyIF9vYmplY3RTYXAgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xuICB2YXIgZm4gID0gKF9jb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gIF9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogX2ZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuXG4vLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcblxuXG5fb2JqZWN0U2FwKCdrZXlzJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpe1xuICAgIHJldHVybiBfb2JqZWN0S2V5cyhfdG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG52YXIga2V5cyQxID0gX2NvcmUuT2JqZWN0LmtleXM7XG5cbnZhciBrZXlzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBrZXlzJDEsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG52YXIgX09iamVjdCRrZXlzID0gdW53cmFwRXhwb3J0cyhrZXlzKTtcblxuLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgZmxvb3IkMSAgICA9IE1hdGguZmxvb3I7XG52YXIgX2lzSW50ZWdlciA9IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCl7XG4gIHJldHVybiAhX2lzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IkMShpdCkgPT09IGl0O1xufTtcblxuLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG5cblxuX2V4cG9ydChfZXhwb3J0LlMsICdOdW1iZXInLCB7aXNJbnRlZ2VyOiBfaXNJbnRlZ2VyfSk7XG5cbnZhciBpc0ludGVnZXIkMiA9IF9jb3JlLk51bWJlci5pc0ludGVnZXI7XG5cbnZhciBpc0ludGVnZXIkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogaXNJbnRlZ2VyJDIsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG52YXIgX051bWJlciRpc0ludGVnZXIgPSB1bndyYXBFeHBvcnRzKGlzSW50ZWdlciQxKTtcblxudmFyIF9zdHJpbmdXcyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG5cbnZhciBzcGFjZSAgID0gJ1snICsgX3N0cmluZ1dzICsgJ10nO1xudmFyIG5vbiAgICAgPSAnXFx1MjAwYlxcdTAwODUnO1xudmFyIGx0cmltICAgPSBSZWdFeHAoJ14nICsgc3BhY2UgKyBzcGFjZSArICcqJyk7XG52YXIgcnRyaW0gICA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7XG5cbnZhciBleHBvcnRlciA9IGZ1bmN0aW9uKEtFWSwgZXhlYywgQUxJQVMpe1xuICB2YXIgZXhwICAgPSB7fTtcbiAgdmFyIEZPUkNFID0gX2ZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICEhX3N0cmluZ1dzW0tFWV0oKSB8fCBub25bS0VZXSgpICE9IG5vbjtcbiAgfSk7XG4gIHZhciBmbiA9IGV4cFtLRVldID0gRk9SQ0UgPyBleGVjKHRyaW0pIDogX3N0cmluZ1dzW0tFWV07XG4gIGlmKEFMSUFTKWV4cFtBTElBU10gPSBmbjtcbiAgX2V4cG9ydChfZXhwb3J0LlAgKyBfZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59O1xuXG4vLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbihzdHJpbmcsIFRZUEUpe1xuICBzdHJpbmcgPSBTdHJpbmcoX2RlZmluZWQoc3RyaW5nKSk7XG4gIGlmKFRZUEUgJiAxKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmKFRZUEUgJiAyKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG52YXIgX3N0cmluZ1RyaW0gPSBleHBvcnRlcjtcblxudmFyICRwYXJzZUZsb2F0ID0gX2dsb2JhbC5wYXJzZUZsb2F0O1xudmFyICR0cmltICAgICAgID0gX3N0cmluZ1RyaW0udHJpbTtcblxudmFyIF9wYXJzZUZsb2F0JDMgPSAxIC8gJHBhcnNlRmxvYXQoX3N0cmluZ1dzICsgJy0wJykgIT09IC1JbmZpbml0eSA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyKXtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKVxuICAgICwgcmVzdWx0ID0gJHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBzdHJpbmcuY2hhckF0KDApID09ICctJyA/IC0wIDogcmVzdWx0O1xufSA6ICRwYXJzZUZsb2F0O1xuXG4vLyAyMC4xLjIuMTIgTnVtYmVyLnBhcnNlRmxvYXQoc3RyaW5nKVxuX2V4cG9ydChfZXhwb3J0LlMgKyBfZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlRmxvYXQgIT0gX3BhcnNlRmxvYXQkMyksICdOdW1iZXInLCB7cGFyc2VGbG9hdDogX3BhcnNlRmxvYXQkM30pO1xuXG52YXIgX3BhcnNlRmxvYXQkMSA9IHBhcnNlRmxvYXQ7XG5cbnZhciBfcGFyc2VGbG9hdCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogX3BhcnNlRmxvYXQkMSwgX19lc01vZHVsZTogdHJ1ZSB9O1xufSk7XG5cbnZhciBfTnVtYmVyJHBhcnNlRmxvYXQgPSB1bndyYXBFeHBvcnRzKF9wYXJzZUZsb2F0KTtcblxuLyoqXG4gKiB0b3hpYy1wcmVkaWNhdGUtZnVuY3Rpb25zIHYwLjEuMlxuICogKGMpIDIwMTcgdG94aWMtam9oYW5uXG4gKiBSZWxlYXNlZCB1bmRlciBNSVRcbiAqL1xuXG4vKipcbiAqIGlzIHZvaWQgZWxlbWVudCBvciBub3QgPyBNZWFucyBpdCB3aWxsIHJldHVybiB0cnVlIHdoZW4gdmFsIGlzIHVuZGVmaW5lZCBvciBudWxsXG4gKiBAcGFyYW0gIHtBbnl0aGluZ30gIG9ialxuICogQHJldHVybiB7Qm9vbGVhbn0gICByZXR1cm4gdHJ1ZSB3aGVuIHZhbCBpcyB1bmRlZmluZWQgb3IgbnVsbFxuICovXG5mdW5jdGlvbiBpc1ZvaWQob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGw7XG59XG4vKipcbiAqIHRvIGNoZWNrIHdoZXRoZXIgYSB2YXJpYWJsZSBpcyBhcnJheVxuICogQHBhcmFtIHtBbnl0aGluZ30gYXJyXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIHdoZW4gaXQgaXMgYSBib29sZWFuXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkoYXJyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFycik7XG59XG5cbi8qKlxuICog5Yik5pat5piv5ZCm5Li6ZnVuY3Rpb25cbiAqIEBwYXJhbSAge0FueXRoaW5nfSAgb2JqIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIOWIpOaWreaYr+WQpuaYr+WvueixoVxuICogQHBhcmFtICB7QW55dGhpbmd9ICBvYmog5Lyg5YWl5a+56LGhXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBpc09iamVjdCQxKG9iaikge1xuICAvLyBpbmNhc2Ugb2YgYXJyb3cgZnVuY3Rpb24gYW5kIGFycmF5XG4gIHJldHVybiBPYmplY3Qob2JqKSA9PT0gb2JqICYmIFN0cmluZyhvYmopID09PSAnW29iamVjdCBPYmplY3RdJyAmJiAhaXNGdW5jdGlvbihvYmopICYmICFpc0FycmF5KG9iaik7XG59XG4vKipcbiAqIHRvIHRlbGwgeW91IGlmIGl0J3MgYSByZWFsIG51bWJlclxuICogQHBhcmFtICB7QW55dGhpbmd9ICBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgcmV0dXJuIHRydWUgd2hlbiBpdCdzIGEgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ251bWJlcic7XG59XG4vKipcbiAqIHRvIHRlbGwgeW91IGlmIHRoZSB2YWwgY2FuIGJlIHRyYW5zZmVyIGludG8gZGF0YVxuICogQHBhcmFtICB7QW55dGhpbmd9ICBvYmogW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gaXNOdW1lcmljKG9iaikge1xuICByZXR1cm4gIWlzQXJyYXkob2JqKSAmJiBvYmogLSBfTnVtYmVyJHBhcnNlRmxvYXQob2JqKSArIDEgPj0gMDtcbn1cbi8qKlxuICog5Yik5pat5piv5ZCm5Li65pW05pWwXG4gKiBAcGFyYW0gIHtBbnl0aGluZ30gIG9iaiBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBpc0ludGVnZXIobnVtKSB7XG4gIHJldHVybiBfTnVtYmVyJGlzSW50ZWdlcihudW0pO1xufVxuXG4vKipcbiAqIOWIpOaWreaYr+WQpuS4uuepulxuICogQHBhcmFtICB7QW55dGhpbmd9ICBvYmogW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBleGFtcGxlXG4gKiBcIlwiLCB7fSwgW10sIDAsIG51bGwsIHVuZGVmaW5lZCwgZmFsc2Ug5Li656m6XG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgfSBlbHNlIGlmIChpc09iamVjdCQxKG9iaikpIHtcbiAgICByZXR1cm4gX09iamVjdCRrZXlzKG9iaikubGVuZ3RoID09PSAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAhb2JqO1xuICB9XG59XG4vKipcbiAqIOWIpOaWreaYr+WQpuS4uuS6i+S7tlxuICogQHBhcmFtICB7QW55dGhpbmd9ICBvYmogW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gaXNFdmVudChvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEV2ZW50IHx8IG9iai5vcmlnaW5hbEV2ZW50IGluc3RhbmNlb2YgRXZlbnQ7XG59XG4vKipcbiAqIOWIpOaWreaYr+WQpuS4umJsb2JcbiAqIEBwYXJhbSAge0FueXRoaW5nfSAgb2JqIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYihvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEJsb2I7XG59XG4vKipcbiAqIOWIpOaWreaYr+WQpuS4umZpbGXkuIrkvKDnmoTmlofku7ZcbiAqIEBwYXJhbSAge0FueXRoaW5nfSAgb2JqIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZShvYmopIHtcbiAgcmV0dXJuIGlzQmxvYihvYmopICYmIGlzU3RyaW5nKG9iai5uYW1lKTtcbn1cbi8qKlxuICog5Yik5pat5piv5ZCm5Li65pel5pyf5a+56LGhXG4gKiBAcGFyYW0gIHtBbnl0aGluZ30gIG9iaiBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBpc0RhdGUob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuLyoqXG4gKiDliKTmlq3mmK/lkKbmmK9zdHJpbmdcbiAqIEBwYXJhbSAge0FueXRoaW5nfSAgc3RyIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHN0cikge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuLyoqXG4gKiBpcyBCb29sZWFuIG9yIG5vdFxuICogQHBhcmFtICB7QW55dGhpbmd9IGJvb2xcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQm9vbGVhbihib29sKSB7XG4gIHJldHVybiB0eXBlb2YgYm9vbCA9PT0gJ2Jvb2xlYW4nO1xufVxuLyoqXG4gKiBpcyBhIHByb21pc2Ugb3Igbm90XG4gKiBAcGFyYW0ge0FueXRoaW5nfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgcmV0dXJuICEhb2JqICYmICgodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogaXMgUHJpbWl0aXZlIHR5cGUgb3Igbm90LCB3aGljayBtZWFucyBpdCB3aWxsIHJldHVybiB0cnVlIHdoZW4gZGF0YSBpcyBudW1iZXIvc3RyaW5nL2Jvb2xlYW4vdW5kZWZpbmVkL251bGxcbiAqIEBwYXJhbSAge0FueXRpbmd9ICB2YWxcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICB0cnVlIHdoZW4gdHlwZSBpcyBudW1iZXIvc3RyaW5nL2Jvb2xlYW4vdW5kZWZpbmVkL251bGxcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsKSB7XG4gIHJldHVybiBpc1ZvaWQodmFsKSB8fCBpc0Jvb2xlYW4odmFsKSB8fCBpc1N0cmluZyh2YWwpIHx8IGlzTnVtYmVyKHZhbCk7XG59XG4vKipcbiAqIOWIpOaWreaYr+WQpuS4unVybOS4lOW/hemhu+imgeW4puacieWNj+iuruWktFxuICogQHBhcmFtICB7QW55dGhpbmd9ICBzdHIgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gaXNVcmwoc3RyKSB7XG4gIHJldHVybiBpc1N0cmluZyhzdHIpICYmICEhc3RyLm1hdGNoKC9eKChodHRwcz98ZnRwfHJ0c3B8bW1zKTpcXC9cXC8pKChbMC05YS16XyF+KicoKS4mPSskJS1dKzogKT9bMC05YS16XyF+KicoKS4mPSskJS1dK0ApPygoWzAtOV17MSwzfVxcLil7M31bMC05XXsxLDN9fChbMC05YS16XyF+KicoKS1dK1xcLikqKFswLTlhLXpdWzAtOWEtei1dezAsNjF9KT9bMC05YS16XVxcLlthLXpdezIsNn18bG9jYWxob3N0KSg6WzAtOV17MSw0fSk/KChcXC8/KXwoXFwvWzAtOWEtel8hfionKCkuOz86QCY9KyQsJSMtXSspK1xcLz8pJC9pKTtcbn1cbi8qKlxuICogdG8gdGVzdCBpZiBhIEhUTUwgbm9kZVxuICogQHBhcmFtICB7QW55dGhpbmd9ICBvYmogW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKG9iaikge1xuICByZXR1cm4gISEoKHR5cGVvZiBOb2RlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihOb2RlKSkgPT09ICdvYmplY3QnID8gb2JqIGluc3RhbmNlb2YgTm9kZSA6IG9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmoubm9kZU5hbWUgPT09ICdzdHJpbmcnKTtcbn1cbi8qKlxuICogdG8gdGVzdCBpZiBhIEhUTUwgZWxlbWVudFxuICogQHBhcmFtICB7QW55dGhpbmd9ICBvYmogW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50KG9iaikge1xuICByZXR1cm4gISEoKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoSFRNTEVsZW1lbnQpKSA9PT0gJ29iamVjdCcgPyBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA6IG9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCAmJiBvYmoubm9kZVR5cGUgPT09IDEgJiYgdHlwZW9mIG9iai5ub2RlTmFtZSA9PT0gJ3N0cmluZycpO1xufVxuLyoqXG4gKiBjaGVjayBpZiBub2RlIEEgaXMgbm9kZSBCJ3MgcGFyZW50IG9yIG5vdFxuICogQHBhcmFtICB7Tm9kZX0gIHBhcmVudFxuICogQHBhcmFtICB7Tm9kZX0gIGNoaWxkXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc0NoaWxkTm9kZShwYXJlbnQsIGNoaWxkKSB7XG4gIGlmICghaXNOb2RlKHBhcmVudCkgfHwgIWlzTm9kZShjaGlsZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNoaWxkLnBhcmVudE5vZGUgPT09IHBhcmVudDtcbn1cbi8qKlxuICogY2hlY2sgaWYgbm9kZSBCIGlzIG5vZGUgQSdzIHBvc3RlcnJpdHkgb3Igbm90XG4gKiBAcGFyYW0gIHtOb2RlfSAgcGFyZW50XG4gKiBAcGFyYW0gIHtOb2RlfSAgY2hpbGRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUG9zdGVyaXR5Tm9kZShwYXJlbnQsIGNoaWxkKSB7XG4gIGlmICghaXNOb2RlKHBhcmVudCkgfHwgIWlzTm9kZShjaGlsZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgd2hpbGUgKGNoaWxkLnBhcmVudE5vZGUpIHtcbiAgICBjaGlsZCA9IGNoaWxkLnBhcmVudE5vZGU7XG4gICAgaWYgKGNoaWxkID09PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIGNoZWNrIGlmIHRoZSBzdHJpbmcgaXMgYW4gSFRNTFN0cmluZ1xuICogQHBhcmFtICB7c3RyaW5nfSAgc3RyIG9ubHkgYWNjZXB0IHN0cmluZ1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNIVE1MU3RyaW5nKHN0cikge1xuICByZXR1cm4gKC88W14+XSs/Pi8udGVzdChzdHIpXG4gICk7XG59XG4vKipcbiAqIGNoZWNrIGlmIGlzIGFuIGVycm9yXG4gKiBAcGFyYW0ge2FueXRoaW5nfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3IodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBFcnJvcjtcbn1cblxuLyoqXG4gKiB0b3hpYy11dGlscyB2MC4xLjNcbiAqIChjKSAyMDE3IHRveGljLWpvaGFublxuICogUmVsZWFzZWQgdW5kZXIgTUlUXG4gKi9cblxuLyoqXG4gKiDnlJ/miJDmt7HluqbpgY3ljoblh73mlbDnmoTlpITnkIblmajvvIzluLjnlKjkuo7nlJ/miJDmt7Hluqbmi7fotJ3nrYlcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiDpgY3ljobliLDmt7Hluqblj5jph4/nmoTml7blgJnnmoTmk43kvZxcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgICAg5Y+v55So55qE5pON5L2c5Ye95pWwXG4gKi9cbmZ1bmN0aW9uIGdlblRyYXZlcnNhbEhhbmRsZXIoZm4pIHtcbiAgZnVuY3Rpb24gcmVjdXJzaXZlRm4oc291cmNlLCB0YXJnZXQsIGtleSkge1xuICAgIGlmIChpc0FycmF5KHNvdXJjZSkgfHwgaXNPYmplY3QkMShzb3VyY2UpKSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgKGlzT2JqZWN0JDEoc291cmNlKSA/IHt9IDogW10pO1xuICAgICAgZm9yICh2YXIgX2tleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgdGFyZ2V0W19rZXldID0gcmVjdXJzaXZlRm4oc291cmNlW19rZXldLCB0YXJnZXRbX2tleV0sIF9rZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIGZuKHNvdXJjZSwgdGFyZ2V0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZWN1cnNpdmVGbjtcbn1cbnZhciBfZGVlcEFzc2lnbiA9IGdlblRyYXZlcnNhbEhhbmRsZXIoZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsO1xufSk7XG4vKipcbiAqIOWvueixoeWFi+mahlxuICogQHBhcmFtICB7QXJyYXl8T2JqZWN0fSBzb3VyY2Ug5Lyg5YW25LuW5YC85Lya55u05o6l6L+U5ZueXG4gKiBAcmV0dXJuIHtjbG9uZS10YXJnZXR9ICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGRlZXBDbG9uZShzb3VyY2UpIHtcbiAgaWYgKGlzUHJpbWl0aXZlKHNvdXJjZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkZWVwQ2xvbmUgb25seSBhY2NlcHQgbm9uIHByaW1pdGl2ZSB0eXBlJyk7XG4gIH1cbiAgcmV0dXJuIF9kZWVwQXNzaWduKHNvdXJjZSk7XG59XG4vKipcbiAqIG1lcmdlIG11bHRpcGxlIG9iamVjdHNcbiAqIEBwYXJhbSAgey4uLk9iamVjdH0gYXJncyBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHttZXJnZS1vYmplY3R9ICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBkZWVwQXNzaWduKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjsgX2tleTIrKykge1xuICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlZXBBc3NpZ24gYWNjZXB0IHR3byBhbmQgbW9yZSBhcmd1bWVudCcpO1xuICB9XG4gIGZvciAodmFyIGkgPSBhcmdzLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgaWYgKGlzUHJpbWl0aXZlKGFyZ3NbaV0pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkZWVwQXNzaWduIG9ubHkgYWNjZXB0IG5vbiBwcmltaXRpdmUgdHlwZScpO1xuICAgIH1cbiAgfVxuICB2YXIgdGFyZ2V0ID0gYXJncy5zaGlmdCgpO1xuICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIHJldHVybiBfZGVlcEFzc2lnbihzb3VyY2UsIHRhcmdldCk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIGNhbWVsaXplIGFueSBzdHJpbmcsIGUuZyBoZWxsbyB3b3JsZCAtPiBoZWxsb1dvcmxkXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0ciBvbmx5IGFjY2VwdCBzdHJpbmchXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICBjYW1lbGl6ZSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyLCBpc0JpZykge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhefFteYS16QS1aXSspKFthLXpBLVpdKS9nLCBmdW5jdGlvbiAobWF0Y2gsIHNwaWx0LCBpbml0aWFscywgaW5kZXgpIHtcbiAgICByZXR1cm4gIWlzQmlnICYmIGluZGV4ID09PSAwID8gaW5pdGlhbHMudG9Mb3dlckNhc2UoKSA6IGluaXRpYWxzLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuLyoqXG4gKiBoeXBlbmF0ZSBhbnkgc3RyaW5nIGUuZyBoZWxsbyB3b3JsZCAtPiBoZWxsby13b3JsZFxuICogQHBhcmFtICB7c3RyaW5nfSBzdHIgb25seSBhY2NlcHQgc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGVuYXRlKHN0cikge1xuICByZXR1cm4gY2FtZWxpemUoc3RyKS5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiAnLScgKyBtYXRjaC50b0xvd2VyQ2FzZSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBiaW5kIHRoZSBmdW5jdGlvbiB3aXRoIHNvbWUgY29udGV4dC4gd2UgaGF2ZSBzb21lIGZhbGxiYWNrIHN0cmF0ZWd5IGhlcmVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIHRoZSBmdW5jdGlvbiB3aGljaCB3ZSBuZWVkIHRvIGJpbmQgdGhlIGNvbnRleHQgb25cbiAqIEBwYXJhbSB7YW55fSBjb250ZXh0IHRoZSBjb250ZXh0IG9iamVjdFxuICovXG5mdW5jdGlvbiBiaW5kKGZuLCBjb250ZXh0KSB7XG4gIGlmIChmbi5iaW5kKSB7XG4gICAgcmV0dXJuIGZuLmJpbmQoY29udGV4dCk7XG4gIH0gZWxzZSBpZiAoZm4uYXBwbHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gX19hdXRvYmluZF9fKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjI7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gX19hdXRvYmluZF9fKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjMpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjM7IF9rZXk0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4uY2FsbC5hcHBseShmbiwgW2NvbnRleHRdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYXJncykpKTtcbiAgICB9O1xuICB9XG59XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKiogIOiuoeeul+exuyAgICAqKioqKioqKioqKioqKioqKioqKioqKipcbi8vIOiuoeeul+iOt+WPluafkOenjeS4nOilv+aIluiAheiuoeeul+WHuuafkOenjeS4nOilv1xuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vIOeUn+aIkHV1aWRcbmZ1bmN0aW9uIHV1aWQoKSB7XG4gIHJldHVybiBTNCgpICsgUzQoKSArICctJyArIFM0KCkgKyAnLScgKyBTNCgpICsgJy0nICsgUzQoKSArICctJyArIFM0KCkgKyBTNCgpICsgUzQoKTtcbn1cbi8vIOeUn+aIkOWbm+S4qumaj+acuuaVsFxuZnVuY3Rpb24gUzQoKSB7XG4gIHJldHVybiAoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDAgfCAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xufVxuLy8g55Sf5oiQ5Lu75oSP6ZW/5bqm55qE6ZqP5py65pWwXG5mdW5jdGlvbiByYW5kKGxlbmd0aCkge1xuICB2YXIgc3RyID0gJyc7XG4gIHdoaWxlIChzdHIubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgc3RyICs9IFM0KCk7XG4gIH1cbiAgcmV0dXJuIHN0ci5zbGljZSgwLCBsZW5ndGgpO1xufVxuXG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuX2V4cG9ydChfZXhwb3J0LlMgKyBfZXhwb3J0LkYgKiAhX2Rlc2NyaXB0b3JzLCAnT2JqZWN0Jywge2RlZmluZVByb3BlcnR5OiBfb2JqZWN0RHAuZn0pO1xuXG52YXIgJE9iamVjdCA9IF9jb3JlLk9iamVjdDtcbnZhciBkZWZpbmVQcm9wZXJ0eSQyID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcblxudmFyIGRlZmluZVByb3BlcnR5JDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IGRlZmluZVByb3BlcnR5JDIsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG52YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0eSA9IHVud3JhcEV4cG9ydHMoZGVmaW5lUHJvcGVydHkkMSk7XG5cbnZhciBfYW5JbnN0YW5jZSA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpe1xuICBpZighKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSl7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG52YXIgX2Zvck9mID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xudmFyIEJSRUFLICAgICAgID0ge31cbiAgLCBSRVRVUk4gICAgICA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1Ipe1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbigpeyByZXR1cm4gaXRlcmFibGU7IH0gOiBjb3JlX2dldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gX2N0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKVxuICAgICwgaW5kZXggID0gMFxuICAgICwgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZihfaXNBcnJheUl0ZXIoaXRlckZuKSlmb3IobGVuZ3RoID0gX3RvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihfYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyApe1xuICAgIHJlc3VsdCA9IF9pdGVyQ2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyAgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xufSk7XG5cbi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIFNQRUNJRVMgICA9IF93a3MoJ3NwZWNpZXMnKTtcbnZhciBfc3BlY2llc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24oTywgRCl7XG4gIHZhciBDID0gX2FuT2JqZWN0KE8pLmNvbnN0cnVjdG9yLCBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gX2FuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogX2FGdW5jdGlvbihTKTtcbn07XG5cbi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxudmFyIF9pbnZva2UgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxudmFyIHByb2Nlc3MkMSAgICAgICAgICAgID0gX2dsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgICAgICAgICAgICA9IF9nbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayAgICAgICAgICA9IF9nbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgTWVzc2FnZUNoYW5uZWwgICAgID0gX2dsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBjb3VudGVyICAgICAgICAgICAgPSAwO1xudmFyIHF1ZXVlICAgICAgICAgICAgICA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyO1xudmFyIGNoYW5uZWw7XG52YXIgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgaWQgPSArdGhpcztcbiAgaWYocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKXtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIF9pbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpe1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZihfY29mKHByb2Nlc3MkMSkgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhfY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gX2N0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihfZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIV9nbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBfZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBfZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZihPTlJFQURZU1RBVEVDSEFOR0UgaW4gX2RvbUNyZWF0ZSgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgX2h0bWwuYXBwZW5kQ2hpbGQoX2RvbUNyZWF0ZSgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpe1xuICAgICAgICBfaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChfY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG52YXIgX3Rhc2sgPSB7XG4gIHNldDogICBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuXG52YXIgbWFjcm90YXNrID0gX3Rhc2suc2V0O1xudmFyIE9ic2VydmVyICA9IF9nbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBfZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyQyICAgPSBfZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSAgID0gX2dsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSQyICAgID0gX2NvZihwcm9jZXNzJDIpID09ICdwcm9jZXNzJztcblxudmFyIF9taWNyb3Rhc2sgPSBmdW5jdGlvbigpe1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYoaXNOb2RlJDIgJiYgKHBhcmVudCA9IHByb2Nlc3MkMi5kb21haW4pKXBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUoaGVhZCl7XG4gICAgICBmbiAgID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgaWYoaGVhZClub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZihpc05vZGUkMil7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIHByb2Nlc3MkMi5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gIH0gZWxzZSBpZihPYnNlcnZlcil7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWVcbiAgICAgICwgbm9kZSAgID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZihQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSl7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKF9nbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZuKXtcbiAgICB2YXIgdGFzayA9IHtmbjogZm4sIG5leHQ6IHVuZGVmaW5lZH07XG4gICAgaWYobGFzdClsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmKCFoZWFkKXtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfSBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG5cbnZhciBfcmVkZWZpbmVBbGwgPSBmdW5jdGlvbih0YXJnZXQsIHNyYywgc2FmZSl7XG4gIGZvcih2YXIga2V5IGluIHNyYyl7XG4gICAgaWYoc2FmZSAmJiB0YXJnZXRba2V5XSl0YXJnZXRba2V5XSA9IHNyY1trZXldO1xuICAgIGVsc2UgX2hpZGUodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfSByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIFNQRUNJRVMkMSAgICAgPSBfd2tzKCdzcGVjaWVzJyk7XG5cbnZhciBfc2V0U3BlY2llcyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciBDID0gdHlwZW9mIF9jb3JlW0tFWV0gPT0gJ2Z1bmN0aW9uJyA/IF9jb3JlW0tFWV0gOiBfZ2xvYmFsW0tFWV07XG4gIGlmKF9kZXNjcmlwdG9ycyAmJiBDICYmICFDW1NQRUNJRVMkMV0pX29iamVjdERwLmYoQywgU1BFQ0lFUyQxLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuXG52YXIgdGFzayAgICAgICAgICAgICAgID0gX3Rhc2suc2V0O1xudmFyIG1pY3JvdGFzayAgICAgICAgICA9IF9taWNyb3Rhc2soKTtcbnZhciBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSc7XG52YXIgVHlwZUVycm9yJDEgICAgICAgICAgPSBfZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBwcm9jZXNzICAgICAgICAgICAgPSBfZ2xvYmFsLnByb2Nlc3M7XG52YXIgJFByb21pc2UgICAgICAgICAgID0gX2dsb2JhbFtQUk9NSVNFXTtcbnZhciBwcm9jZXNzICAgICAgICAgICAgPSBfZ2xvYmFsLnByb2Nlc3M7XG52YXIgaXNOb2RlJDEgICAgICAgICAgICAgPSBfY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbDtcbnZhciBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHk7XG52YXIgV3JhcHBlcjtcblxudmFyIFVTRV9OQVRJVkUkMSA9ICEhZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSAgICAgPSAkUHJvbWlzZS5yZXNvbHZlKDEpXG4gICAgICAsIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbX3drcygnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlJDEgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKSAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIHNhbWVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKGEsIGIpe1xuICAvLyB3aXRoIGxpYnJhcnkgd3JhcHBlciBzcGVjaWFsIGNhc2VcbiAgcmV0dXJuIGEgPT09IGIgfHwgYSA9PT0gJFByb21pc2UgJiYgYiA9PT0gV3JhcHBlcjtcbn07XG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBfaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IkMSgnQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCAgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IF9hRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IF9hRnVuY3Rpb24ocmVqZWN0KTtcbn07XG52YXIgcGVyZm9ybSA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIGV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4ge2Vycm9yOiBlfTtcbiAgfVxufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbihwcm9taXNlLCBpc1JlamVjdCl7XG4gIGlmKHByb21pc2UuX24pcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBvayAgICA9IHByb21pc2UuX3MgPT0gMVxuICAgICAgLCBpICAgICA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uKHJlYWN0aW9uKXtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWxcbiAgICAgICAgLCByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZVxuICAgICAgICAsIHJlamVjdCAgPSByZWFjdGlvbi5yZWplY3RcbiAgICAgICAgLCBkb21haW4gID0gcmVhY3Rpb24uZG9tYWluXG4gICAgICAgICwgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgaWYoIW9rKXtcbiAgICAgICAgICAgIGlmKHByb21pc2UuX2ggPT0gMilvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihoYW5kbGVyID09PSB0cnVlKXJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYoZG9tYWluKWRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKXtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IkMSgnUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChfZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3ZcbiAgICAgICwgYWJydXB0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmKGlzVW5oYW5kbGVkKHByb21pc2UpKXtcbiAgICAgIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoaXNOb2RlJDEpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IF9nbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pe1xuICAgICAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWV9KTtcbiAgICAgICAgfSBlbHNlIGlmKChjb25zb2xlID0gX2dsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKXtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUkMSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZihhYnJ1cHQpdGhyb3cgYWJydXB0LmVycm9yO1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgaWYocHJvbWlzZS5faCA9PSAxKXJldHVybiBmYWxzZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jXG4gICAgLCBpICAgICA9IDBcbiAgICAsIHJlYWN0aW9uO1xuICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXtcbiAgICByZWFjdGlvbiA9IGNoYWluW2krK107XG4gICAgaWYocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoX2dsb2JhbCwgZnVuY3Rpb24oKXtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZihpc05vZGUkMSl7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYoaGFuZGxlciA9IF9nbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKXtcbiAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdn0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICBwcm9taXNlLl9zID0gMjtcbiAgaWYoIXByb21pc2UuX2EpcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHByb21pc2UgPSB0aGlzXG4gICAgLCB0aGVuO1xuICBpZihwcm9taXNlLl9kKXJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmKHByb21pc2UgPT09IHZhbHVlKXRocm93IFR5cGVFcnJvciQxKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKXtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICB2YXIgd3JhcHBlciA9IHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgX2N0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIF9jdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFJDEpe1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIF9hbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBfYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihfY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgX2N0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IF9yZWRlZmluZUFsbCgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xuICAgICAgdmFyIHJlYWN0aW9uICAgID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoX3NwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgICAgID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsICAgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUkMSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX2EpdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX3Mpbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHByb21pc2UgID0gbmV3IEludGVybmFsO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gX2N0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgID0gX2N0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuX2V4cG9ydChfZXhwb3J0LkcgKyBfZXhwb3J0LlcgKyBfZXhwb3J0LkYgKiAhVVNFX05BVElWRSQxLCB7UHJvbWlzZTogJFByb21pc2V9KTtcbl9zZXRUb1N0cmluZ1RhZygkUHJvbWlzZSwgUFJPTUlTRSk7XG5fc2V0U3BlY2llcyhQUk9NSVNFKTtcbldyYXBwZXIgPSBfY29yZVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuX2V4cG9ydChfZXhwb3J0LlMgKyBfZXhwb3J0LkYgKiAhVVNFX05BVElWRSQxLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuX2V4cG9ydChfZXhwb3J0LlMgKyBfZXhwb3J0LkYgKiAoX2xpYnJhcnkgfHwgIVVTRV9OQVRJVkUkMSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbl9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogIShVU0VfTkFUSVZFJDEgJiYgX2l0ZXJEZXRlY3QoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIF9mb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICB2YXIgJGluZGV4ICAgICAgICA9IGluZGV4KytcbiAgICAgICAgICAsIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICBpZihhbHJlYWR5Q2FsbGVkKXJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkICA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgX2Zvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyIHByb21pc2UkMSA9IF9jb3JlLlByb21pc2U7XG5cbnZhciBwcm9taXNlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBwcm9taXNlJDEsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG52YXIgX1Byb21pc2UgPSB1bndyYXBFeHBvcnRzKHByb21pc2UpO1xuXG4vKipcbiAqIGNoaW1lZS1oZWxwZXItdXRpbHMgdjAuMS4yXG4gKiAoYykgMjAxNyB0b3hpYy1qb2hhbm5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVFxuICovXG5cbi8vICoqKioqKioqKioqKioqKioqKioqKiogIGp1ZGdlbWVudCAgICoqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjaGVjayBpZiB0aGUgY29kZSBydW5uaW5nIGluIGJyb3dzZXIgZW52aXJvbm1lbnQgKG5vdCBpbmNsdWRlIHdvcmtlciBlbnYpXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cpICE9PSAnW29iamVjdCBPYmplY3RdJztcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKiAg5a+56LGh5pON5L2cICAqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICog6L2s5Y+Y5LiA5Liq57G75pWw57uE5a+56LGh5Li65pWw57uEXG4gKi9cbmZ1bmN0aW9uIG1ha2VBcnJheShvYmopIHtcbiAgcmV0dXJuIF9BcnJheSRmcm9tKG9iaik7XG59XG5cbi8qKlxuICogc29ydCBPYmplY3QgYXR0cmlidXRlcyBieSBmdW5jdGlvblxuICogYW5kIHRyYW5zZmVyIHRoZW0gaW50byBhcnJheVxuICogQHBhcmFtICB7T2JqZWN0fSBvYmogT2JqZWN0IGZvcm0gZnJvbSBudW1yaWNcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiBzb3J0IGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtBcnJheX0gdGhlIHNvcnRlZCBhdHRpcmJ1dGVzIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHRyYW5zT2JqZWN0QXR0ckludG9BcnJheShvYmopIHtcbiAgdmFyIGZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiArYSAtICtiO1xuICB9O1xuXG4gIHJldHVybiBfT2JqZWN0JGtleXMob2JqKS5zb3J0KGZuKS5yZWR1Y2UoZnVuY3Rpb24gKG9yZGVyLCBrZXkpIHtcbiAgICByZXR1cm4gb3JkZXIuY29uY2F0KG9ialtrZXldKTtcbiAgfSwgW10pO1xufVxuLy8gKioqKioqKioqKioqKioqKioqKioqKiBjbGFzcyBvcGVyYXRpb24gKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyBjbGFzcyBNaXhpbkJ1aWxkZXIge1xuLy8gICBjb25zdHJ1Y3RvciAoc3VwZXJjbGFzcykge1xuLy8gICAgIHRoaXMuc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3MgfHwgY2xhc3Mge307XG4vLyAgIH1cblxuLy8gICB3aXRoICguLi5taXhpbnMpIHtcbi8vICAgICByZXR1cm4gbWl4aW5zLnJlZHVjZSgoYywgbWl4aW4pID0+IG1peGluKGMpLCB0aGlzLnN1cGVyY2xhc3MpO1xuLy8gICB9XG4vLyB9XG4vLyBleHBvcnQgY29uc3QgbWl4ID0gKHN1cGVyY2xhc3MpID0+IHtcbi8vICAgcmV0dXJuIG5ldyBNaXhpbkJ1aWxkZXIoc3VwZXJjbGFzcyk7XG4vLyB9O1xuLyoqXG4gKiBydW4gYSBxdWV1ZSBvbmUgYnkgb25lLklmIGluY2x1ZGUgZnVuY3Rpb24gcmVqZWN0IG9yIHJldHVybiBmYWxzZSBpdCB3aWxsIHN0b3BcbiAqIEBwYXJhbSAge0FycmF5fSBxdWV1ZSB0aGUgcXVldWUgd2hpY2ggd2Ugd2FudCB0byBydW4gb25lIGJ5IG9uZVxuICogQHJldHVybiB7UHJvbWlzZX0gICAgdGVsbCB1cyB3aGV0aGVyIGEgcXVldWUgcnVuIGZpbmlzaGVkXG4gKi9cbmZ1bmN0aW9uIHJ1blJlamVjdGFibGVRdWV1ZShxdWV1ZSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBuZXcgX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBzdGVwID0gZnVuY3Rpb24gc3RlcChpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID49IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uKHF1ZXVlW2luZGV4XSkgPyBxdWV1ZVtpbmRleF0uYXBwbHkocXVldWUsIF90b0NvbnN1bWFibGVBcnJheShhcmdzKSkgOiBxdWV1ZVtpbmRleF07XG4gICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgcmV0dXJuIHJlamVjdCgnc3RvcCcpO1xuICAgICAgcmV0dXJuIF9Qcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdCgnc3RvcCcpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBzdGVwKDApO1xuICB9KTtcbn1cbi8qKlxuICogcnVuIGEgcXVldWUgb25lIGJ5IG9uZS5JZiBpbmNsdWRlIGZ1bmN0aW9uIHJldHVybiBmYWxzZSBpdCB3aWxsIHN0b3BcbiAqIEBwYXJhbSAge0FycmF5fSBxdWV1ZSB0aGUgcXVldWUgd2hpY2ggd2Ugd2FudCB0byBydW4gb25lIGJ5IG9uZVxuICogQHJldHVybiB7Ym9vbGVhbn0gdGVsbCB0aGUgdXNlciBpZiB0aGUgcXVldWUgcnVuIGZpbmlzaGVkXG4gKi9cbmZ1bmN0aW9uIHJ1blN0b3BwYWJsZVF1ZXVlKHF1ZXVlKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbiBzdGVwKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uKHF1ZXVlW2luZGV4XSkgPyBxdWV1ZVtpbmRleF0uYXBwbHkocXVldWUsIF90b0NvbnN1bWFibGVBcnJheShhcmdzKSkgOiBxdWV1ZVtpbmRleF07XG4gICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gc3RlcCgrK2luZGV4KTtcbiAgfTtcbiAgcmV0dXJuIHN0ZXAoMCk7XG59XG4vKipcbiAqIHNldCBhbiBhdHRyaWJ1dGUgdG8gYW4gb2JqZWN0IHdoaWNoIGlzIGZyb3plbi5cbiAqIE1lYW5zIHlvdSBjYW4ndCByZW1vdmUgaXQsIGl0ZXJhdGUgaXQgb3IgcmV3cml0ZSBpdC5cbiAqIEBwYXJhbSB7IXByaW1pdGl2ZX0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0FueXRoaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBzZXRGcm96ZW5BdHRyKG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNQcmltaXRpdmUob2JqKSkgdGhyb3cgVHlwZUVycm9yKCdzZXRGcm96ZW5BdHRyIG9iaiBwYXJhbWV0ZXIgY2FuIG5vdCBiZSBwcmltaXRpdmUgdHlwZScpO1xuICBpZiAoIWlzU3RyaW5nKGtleSkpIHRocm93IFR5cGVFcnJvcignc2V0RnJvemVuQXR0ciBrZXkgcGFyYW1ldGVyIG11c3QgYmUgU3RyaW5nJyk7XG4gIF9PYmplY3QkZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG59XG4vKipcbiAqIHNldCBhdHRyIG9uIGFuIE9iamVjdC4gV2Ugd2lsbCBiaW5kIGdldHRlciBhbmQgc2V0dGVyIG9uIGl0IGlmIHlvdSBwcm92aWRlIHRvIHVzXG4gKiBAcGFyYW0geyFwcmltaXRpdmV9IG9ialxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5nZXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IHRoZSBvcmlnaW4gZGF0YSdzIHByZWZpeC4gV2UgZG8gbm90IHBsYW4gdG8gc2F2ZSBpdCBieSBjbG9zdXJlLlxuICovXG5mdW5jdGlvbiBzZXRBdHRyR2V0dGVyQW5kU2V0dGVyKG9iaiwga2V5KSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgIGdldCA9IF9yZWYuZ2V0LFxuICAgICAgc2V0ID0gX3JlZi5zZXQ7XG5cbiAgdmFyIHByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJ19fJztcblxuICBpZiAoaXNQcmltaXRpdmUob2JqKSkgdGhyb3cgVHlwZUVycm9yKCdzZXRGcm96ZW5BdHRyIG9iaiBwYXJhbWV0ZXIgY2FuIG5vdCBiZSBwcmltaXRpdmUgdHlwZScpO1xuICBpZiAoIWlzU3RyaW5nKGtleSkpIHRocm93IFR5cGVFcnJvcignc2V0QXR0ckdldHRlckFuZFNldHRlciBrZXkgcGFyYW1ldGVyIG11c3QgYmUgU3RyaW5nJyk7XG4gIHZhciBvcmlnaW5hbERhdGEgPSBvYmpba2V5XTtcbiAgaWYgKCFpc0Z1bmN0aW9uKGdldCkpIHtcbiAgICBfT2JqZWN0JGRlZmluZVByb3BlcnR5KG9iaiwgcHJlZml4ICsga2V5LCB7XG4gICAgICB2YWx1ZTogb3JpZ2luYWxEYXRhLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgIGdldCA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzW3ByZWZpeCArIGtleV07XG4gICAgfTtcbiAgICBpZiAoc2V0ICYmIGlzRnVuY3Rpb24oc2V0KSkge1xuICAgICAgdmFyIG9yaWdpblNldHRlciA9IHNldDtcbiAgICAgIHNldCA9IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW3ByZWZpeCArIGtleV0gPSBvcmlnaW5TZXR0ZXIuY2FsbC5hcHBseShvcmlnaW5TZXR0ZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgX09iamVjdCRkZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyBnZXQ6IGdldCwgc2V0OiBzZXQgfSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQ29udGludWF0aW9uKHVpbnQ4YXJyYXksIHN0YXJ0LCBjaGVja0xlbmd0aCkge1xuICB2YXIgYXJyYXkgPSB1aW50OGFycmF5O1xuICBpZiAoc3RhcnQgKyBjaGVja0xlbmd0aCA8IGFycmF5Lmxlbmd0aCkge1xuICAgIHdoaWxlIChjaGVja0xlbmd0aC0tKSB7XG4gICAgICBpZiAoKGFycmF5Wysrc3RhcnRdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gZGVjb2RlVVRGOFxuZnVuY3Rpb24gZGVjb2RlVVRGOCh1aW50OGFycmF5KSB7XG4gIHZhciBvdXQgPSBbXTtcbiAgdmFyIGlucHV0ID0gdWludDhhcnJheTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuZ3RoID0gdWludDhhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBpZiAoaW5wdXRbaV0gPCAweDgwKSB7XG4gICAgICBvdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGlucHV0W2ldKSk7XG4gICAgICArK2k7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGlucHV0W2ldIDwgMHhDMCkge1xuICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICB9IGVsc2UgaWYgKGlucHV0W2ldIDwgMHhFMCkge1xuICAgICAgaWYgKGNoZWNrQ29udGludWF0aW9uKGlucHV0LCBpLCAxKSkge1xuICAgICAgICB2YXIgdWNzNCA9IChpbnB1dFtpXSAmIDB4MUYpIDw8IDYgfCBpbnB1dFtpICsgMV0gJiAweDNGO1xuICAgICAgICBpZiAodWNzNCA+PSAweDgwKSB7XG4gICAgICAgICAgb3V0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSh1Y3M0ICYgMHhGRkZGKSk7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbnB1dFtpXSA8IDB4RjApIHtcbiAgICAgIGlmIChjaGVja0NvbnRpbnVhdGlvbihpbnB1dCwgaSwgMikpIHtcbiAgICAgICAgdmFyIF91Y3MgPSAoaW5wdXRbaV0gJiAweEYpIDw8IDEyIHwgKGlucHV0W2kgKyAxXSAmIDB4M0YpIDw8IDYgfCBpbnB1dFtpICsgMl0gJiAweDNGO1xuICAgICAgICBpZiAoX3VjcyA+PSAweDgwMCAmJiAoX3VjcyAmIDB4RjgwMCkgIT09IDB4RDgwMCkge1xuICAgICAgICAgIG91dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoX3VjcyAmIDB4RkZGRikpO1xuICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5wdXRbaV0gPCAweEY4KSB7XG4gICAgICBpZiAoY2hlY2tDb250aW51YXRpb24oaW5wdXQsIGksIDMpKSB7XG4gICAgICAgIHZhciBfdWNzMiA9IChpbnB1dFtpXSAmIDB4NykgPDwgMTggfCAoaW5wdXRbaSArIDFdICYgMHgzRikgPDwgMTIgfCAoaW5wdXRbaSArIDJdICYgMHgzRikgPDwgNiB8IGlucHV0W2kgKyAzXSAmIDB4M0Y7XG4gICAgICAgIGlmIChfdWNzMiA+IDB4MTAwMDAgJiYgX3VjczIgPCAweDExMDAwMCkge1xuICAgICAgICAgIF91Y3MyIC09IDB4MTAwMDA7XG4gICAgICAgICAgb3V0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShfdWNzMiA+Pj4gMTAgfCAweEQ4MDApKTtcbiAgICAgICAgICBvdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKF91Y3MyICYgMHgzRkYgfCAweERDMDApKTtcbiAgICAgICAgICBpICs9IDQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgb3V0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpKTtcbiAgICArK2k7XG4gIH1cbiAgcmV0dXJuIG91dC5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gIC8vIGltbWVkaWF0Zem7mOiupOS4umZhbHNlXG4gIHZhciB0aW1lb3V0ID0gdm9pZCAwLFxuICAgICAgYXJncyA9IHZvaWQgMCxcbiAgICAgIGNvbnRleHQgPSB2b2lkIDAsXG4gICAgICB0aW1lc3RhbXAgPSB2b2lkIDAsXG4gICAgICByZXN1bHQgPSB2b2lkIDA7XG5cbiAgdmFyIGxhdGVyID0gZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgLy8g5b2Td2FpdOaMh+WumueahOaXtumXtOmXtOmalOacn+mXtOWkmuasoeiwg+eUqF8uZGVib3VuY2Xov5Tlm57nmoTlh73mlbDvvIzliJnkvJrkuI3mlq3mm7TmlrB0aW1lc3RhbXDnmoTlgLzvvIzlr7zoh7RsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDDkuIDnm7TkuLp0cnVl77yM5LuO6ICM5LiN5pat5ZCv5Yqo5paw55qE6K6h5pe25Zmo5bu25pe25omn6KGMZnVuY1xuICAgIHZhciBsYXN0ID0gbmV3IERhdGUoKSAtIHRpbWVzdGFtcDtcblxuICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgY29udGV4dCA9IHRoaXM7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgIC8vIOesrOS4gOasoeiwg+eUqOivpeaWueazleaXtu+8jOS4lGltbWVkaWF0ZeS4unRydWXvvIzliJnosIPnlKhmdW5j5Ye95pWwXG4gICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgLy8g5Zyod2FpdOaMh+WumueahOaXtumXtOmXtOmalOWGhemmluasoeiwg+eUqOivpeaWueazle+8jOWImeWQr+WKqOiuoeaXtuWZqOWumuaXtuiwg+eUqGZ1bmPlh73mlbBcbiAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICBpZiAoY2FsbE5vdykge1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIOWHveaVsOiKgua1ge+8iOaOp+WItuWHveaVsOaJp+ihjOmikeeOh++8iVxuICogQHBhcmFtICB7RnVuY3Rpb259IGZ1bmMg6KaB6IqC5rWB5o6n5Yi255qE5Ye95pWw77yM5b+F5aGrXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgd2FpdCDnrYnlvoXml7bplb9cbiAqIEByZXR1cm4ge09iamVjdH0gICBvcHRpb25zIHtcbiAqICAgICAgICAgICAgICAgICAgICAgIGxlYWRpbmc85piv5ZCm6aaW5qyh6LCD55So56uL5Y2z5omn6KGM77yM5ZCm77ya5YiZ5oyJd2FpdOiuvuWumuetieW+heWIsOacn+WQjuiwg+eUqOaJjeaJp+ihjD46ZmFsc2UsXG4gKiAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZzzmmK/lkKblnKjosIPnlKjlubbmnKrliLDmnJ/ml7blkK/nlKjlrprml7blmajvvIzku6Xkv53or4HkuIDlrprmiafooYw+OnRydWVcbiAqICAgICAgICAgICAgICAgICAgICB9XG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgY3h0IOS4iuS4i+aWh+WvueixoVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMsIGN4dCkge1xuICAvKiBvcHRpb25z55qE6buY6K6k5YC8XG4gICAqICDooajnpLrpppbmrKHosIPnlKjov5Tlm57lgLzmlrnms5Xml7bvvIzkvJrpqazkuIrosIPnlKhmdW5j77yb5ZCm5YiZ5LuF5Lya6K6w5b2V5b2T5YmN5pe25Yi777yM5b2T56ys5LqM5qyh6LCD55So55qE5pe26Ze06Ze06ZqU6LaF6L+Hd2FpdOaXtu+8jOaJjeiwg+eUqGZ1bmPjgIJcbiAgICogIG9wdGlvbnMubGVhZGluZyA9IHRydWU7XG4gICAqIOihqOekuuW9k+iwg+eUqOaWueazleaXtu+8jOacquWIsOi+vndhaXTmjIflrprnmoTml7bpl7Tpl7TpmpTvvIzliJnlkK/liqjorqHml7blmajlu7bov5/osIPnlKhmdW5j5Ye95pWw77yM6Iul5ZCO57ut5Zyo5pei5pyq6L6+5Yiwd2FpdOaMh+WumueahOaXtumXtOmXtOmalOWSjGZ1bmPlh73mlbDlj4jmnKrooqvosIPnlKjnmoTmg4XlhrXkuIvosIPnlKjov5Tlm57lgLzmlrnms5XvvIzliJnooqvosIPnlKjor7fmsYLlsIbooqvkuKLlvIPjgIJcbiAgICogIG9wdGlvbnMudHJhaWxpbmcgPSB0cnVlO1xuICAgKiDms6jmhI/vvJrlvZNvcHRpb25zLnRyYWlsaW5nID0gZmFsc2Xml7bvvIzmlYjmnpzkuI7kuIrpnaLnmoTnroDljZXlrp7njrDmlYjmnpznm7jlkIxcbiAgICovXG4gIHZhciBjb250ZXh0ID0gdm9pZCAwLFxuICAgICAgYXJncyA9IHZvaWQgMCxcbiAgICAgIHJlc3VsdCA9IHZvaWQgMDtcbiAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICB2YXIgcHJldmlvdXMgPSAwO1xuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGxhdGVyID0gZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IG5ldyBEYXRlKCkgLSAwO1xuICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gIH07XG4gIHdhaXQgPSB3YWl0IHx8IDA7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAvLyDorqHnrpfliankvZnml7bpl7RcbiAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgaWYgKGN4dCkge1xuICAgICAgY29udGV4dCA9IGN4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgfVxuXG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAvLyDlvZPliLDovr53YWl05oyH5a6a55qE5pe26Ze06Ze06ZqU77yM5YiZ6LCD55SoZnVuY+WHveaVsFxuICAgIC8vIOeyvuW9qeS5i+WkhO+8muaMieeQhuadpeivtHJlbWFpbmluZyA8PSAw5bey57uP6Laz5aSf6K+B5piO5bey57uP5Yiw6L6+d2FpdOeahOaXtumXtOmXtOmalO+8jOS9hui/memHjOi/mOiAg+iZkeWIsOWBh+WmguWuouaIt+err+S/ruaUueS6huezu+e7n+aXtumXtOWImemprOS4iuaJp+ihjGZ1bmPlh73mlbDjgIJcbiAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgLy8g55Sx5LqOc2V0VGltZW91dOWtmOWcqOacgOWwj+aXtumXtOeyvuW6pumXrumimO+8jOWboOatpOS8muWtmOWcqOWIsOi+vndhaXTnmoTml7bpl7Tpl7TpmpTvvIzkvYbkuYvliY3orr7nva7nmoRzZXRUaW1lb3V05pON5L2c6L+Y5rKh6KKr5omn6KGM77yM5Zug5q2k5Li65L+d6Zmp6LW36KeB77yM6L+Z6YeM5YWI5riF55CGc2V0VGltZW91dOaTjeS9nFxuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgIC8vIG9wdGlvbnMudHJhaWxpbmc9dHJ1ZeaXtu+8jOW7tuaXtuaJp+ihjGZ1bmPlh73mlbBcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbnZhciByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGNiKSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGNiLCAxNyk7XG59O1xuXG4vLyBjYW5jZWxBbmltYXRpb25GcmFtZVxudmFyIGNhZiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9DYW5jZWxBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbiAoaWQpIHtcbiAgY2xlYXJUaW1lb3V0KGlkKTtcbn07XG5cbi8vIOagueaNruimgeaxgueahOS9jeaVsO+8jOWwhjnmoLzlvI/ljJbkuLogMDlcXDAwOVxcMDAwOS4uLlxuZnVuY3Rpb24gc3RyUmVwZWF0KG51bSwgYml0KSB7XG4gIHZhciBwQml0ID0gYml0O1xuICBudW0gPSAnJyArIChudW0gfHwgJycpO1xuICB2YXIgbnVtTGVuID0gbnVtLmxlbmd0aDtcbiAgYml0ID0gKGJpdCB8fCBudW1MZW4pIC0gbnVtTGVuO1xuICB2YXIgcGFkZGluZ1N0ciA9IGJpdCA+IDAgPyBudW0ucmVwZWF0ID8gJzAnLnJlcGVhdChiaXQpIDogbmV3IEFycmF5KGJpdCArIDEpLmpvaW4oJzAnKSA6ICcnO1xuICByZXR1cm4gKHBhZGRpbmdTdHIgKyBudW0pLnNsaWNlKDAsIHBCaXQpO1xufVxuXG4vLyB2aWRlbyDml7bpl7TmoLzlvI/ljJZcbmZ1bmN0aW9uIGZvcm1hdFRpbWUodGltZSkge1xuICB2YXIgaGggPSBNYXRoLmZsb29yKHRpbWUgLyAzNjAwKTtcbiAgdGltZSA9IE1hdGguZmxvb3IodGltZSAlIDM2MDApO1xuICB2YXIgbW0gPSBzdHJSZXBlYXQoTWF0aC5mbG9vcih0aW1lIC8gNjApLCAyKTtcbiAgdGltZSA9IE1hdGguZmxvb3IodGltZSAlIDYwKTtcbiAgdmFyIHNzID0gc3RyUmVwZWF0KHRpbWUsIDIpO1xuICByZXR1cm4gaGggPj0gMSA/IGhoICsgJzonICsgbW0gKyAnOicgKyBzcyA6IG1tICsgJzonICsgc3M7XG59XG5cbi8qKlxuICog57uZb2Jq5a+56LGh5omp5bGV5LiKdHJhbnPmlrnms5XvvIznlKjku6Xlrp7njrBtZXRob2ROYW1l5a+55bqU55qE5bGe5oCn5pa55rOV5YyF6KOF5Li66Z2Z5oCB5Ye95pWw5LiU5L+d5oyB5LiK5LiL5paH55qE5Yqf6IO9XG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iaiDnm67moIflr7nosaFcbiAqL1xuZnVuY3Rpb24gYWRkVHJhbnNNZXRob2Qob2JqKSB7XG4gIHNldEZyb3plbkF0dHIob2JqLCAndHJhbnMnLCBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIGlmICghb2JqLl9fZm5zKSB7XG4gICAgICBzZXRGcm96ZW5BdHRyKG9iaiwgJ19fZm5zJywge30pO1xuICAgIH1cbiAgICBpZiAoIW9iai5fX2Zuc1ttZXRob2ROYW1lXSkge1xuICAgICAgb2JqLl9fZm5zW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb24ob2JqW21ldGhvZE5hbWVdKSkgdGhyb3cgVHlwZUVycm9yKCdvYmoudHJhbnMobWV0aG9kTmFtZSkgcGFyYW1ldGVyIG11c3QgYmUgRnVuY3Rpb24nKTtcbiAgICAgICAgcmV0dXJuIG9ialttZXRob2ROYW1lXS5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gb2JqLl9fZm5zW21ldGhvZE5hbWVdO1xuICB9KTtcbn1cblxuLyoqXG4gKiDov73liqDmoLflvI/ku6PnoIHliLBoZWFk55qEc3R5bGXmoIfnrb7vvIzkuI3lrZjlnKjliJnliJvlu7pcbiAqIEBwYXJhbSB7U3RyaW5nfSBjc3NUZXh0IOagt+W8j+aWh+acrFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGFwcGVuZENTUyhjc3NUZXh0KSB7XG4gIHZhciBkb2MgPSBkb2N1bWVudDtcbiAgdmFyIHN0eWxlRWwgPSBkb2MucXVlcnlTZWxlY3Rvcignc3R5bGUnKTtcbiAgaWYgKCFzdHlsZUVsKSB7XG4gICAgc3R5bGVFbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHZhciBoZWFkZXIgPSBkb2MucXVlcnlTZWxlY3RvcignaGVhZCcpO1xuICAgIGhlYWRlciAmJiBoZWFkZXIuYXBwZW5kQ2hpbGQoc3R5bGVFbCk7XG4gIH1cbiAgc3R5bGVFbC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoY3NzVGV4dCkpO1xuICByZXR1cm4gc3R5bGVFbDtcbn1cblxuLyoqXG4gKiDmoLzlvI/ljJbml6XmnJ/lr7nosaHkuLrvvJrlubQt5pyILeaXpSDml7Y65YiGOuenki7mr6vnp5JcbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBEYXRl5pel5pyf5a+56LGhXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiDopoHovpPlh7rnmoTml6XmnJ/moLzlvI/vvIzpu5jorqTvvJpgeXl5eS1NTS1kZCBoaDptbTpzcy5pYFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBmb3JtYXREYXRlKCkge1xuICB2YXIgZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbmV3IERhdGUoKTtcbiAgdmFyIHBhdHRlcm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd5eXl5LU1NLWRkIGhoOm1tOnNzLmknO1xuXG4gIHZhciB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCk7XG4gIHZhciBmaWVsZHMgPSB7XG4gICAgTTogZGF0ZS5nZXRNb250aCgpICsgMSxcbiAgICBkOiBkYXRlLmdldERhdGUoKSxcbiAgICBoOiBkYXRlLmdldEhvdXJzKCksXG4gICAgbTogZGF0ZS5nZXRNaW51dGVzKCksXG4gICAgczogZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgaTogZGF0ZS5nZXRNaWxsaXNlY29uZHMoKVxuICB9O1xuICBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKC8oeSspL2lnLCBmdW5jdGlvbiAoXywgeWVhclBhdHRlcm4pIHtcbiAgICByZXR1cm4geWVhci5zdWJzdHIoNCAtIE1hdGgubWluKDQsIHllYXJQYXR0ZXJuLmxlbmd0aCkpO1xuICB9KTtcblxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZShuZXcgUmVnRXhwKCcoJyArIGkgKyAnKyknLCAnZycpLCBmdW5jdGlvbiAoXywgcGF0dFN0cikge1xuICAgICAgcmV0dXJuIChmaWVsZHNbaV0gPCAxMCAmJiBwYXR0U3RyLmxlbmd0aCA+IDEgPyAnMCcgOiAnJykgKyBmaWVsZHNbaV07XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSBpbiBmaWVsZHMpIHtcbiAgICBfbG9vcChpKTtcbiAgfVxuICByZXR1cm4gcGF0dGVybjtcbn1cblxuLyoqXG4gKiDor7vlj5bmnKzlnLDlrZjlgqjnmoTlgLzvvIjkuI3mlK/mjIFsb2NhbFN0b3JhZ2XliJnpmY3nuqfliLBjb29raWXvvIlcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkg55uu5qCH5pWw5o2ua2V5XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZShrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHJlZ1J0ID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefCApJyArIGtleSArICc9KFteO10qKSg7fCQpJykpO1xuICAgICAgcmV0dXJuIGlzQXJyYXkocmVnUnQpID8gdW5lc2NhcGUocmVnUnRbMl0pIDogJyc7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiDlsIbmjIflrpprZXnlr7nlupTlgLzlhpnlhaXmnKzlnLDlrZjlgqjvvIjkuI3mlK/mjIFsb2NhbFN0b3JhZ2XliJnpmY3nuqfliLBjb29raWXvvIlcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc2V0TG9jYWxTdG9yYWdlKGtleSwgdmFsKSB7XG4gIHRyeSB7XG4gICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBleHBpcmVzID0gbmV3IERhdGUoKTtcbiAgICAvLyDpu5jorqTlrZjlgqgzMDDlpKlcbiAgICBleHBpcmVzLnNldFRpbWUoZXhwaXJlcy5nZXRUaW1lKCkgKyAyNCAqIDM2MDAgKiAxMDAwICogMzAwKTtcbiAgICB0cnkge1xuICAgICAgZG9jdW1lbnQuY29va2llID0ga2V5ICsgJz0nICsgZXNjYXBlKHZhbCkgKyAnO2V4cGlyZXM9JyArIGV4cGlyZXMudG9VVENTdHJpbmcoKSArICc7cGF0aD0vOyc7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjayA9IHVud3JhcEV4cG9ydHMoY2xhc3NDYWxsQ2hlY2spO1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChkZWZpbmVQcm9wZXJ0eSQxKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IHVud3JhcEV4cG9ydHMoY3JlYXRlQ2xhc3MpO1xuXG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgJGFzc2lnbiAgPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcbnZhciBfb2JqZWN0QXNzaWduID0gISRhc3NpZ24gfHwgX2ZhaWxzKGZ1bmN0aW9uKCl7XG4gIHZhciBBID0ge31cbiAgICAsIEIgPSB7fVxuICAgICwgUyA9IFN5bWJvbCgpXG4gICAgLCBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oayl7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgICAgID0gX3RvT2JqZWN0KHRhcmdldClcbiAgICAsIGFMZW4gID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgaW5kZXggPSAxXG4gICAgLCBnZXRTeW1ib2xzID0gX29iamVjdEdvcHMuZlxuICAgICwgaXNFbnVtICAgICA9IF9vYmplY3RQaWUuZjtcbiAgd2hpbGUoYUxlbiA+IGluZGV4KXtcbiAgICB2YXIgUyAgICAgID0gX2lvYmplY3QoYXJndW1lbnRzW2luZGV4KytdKVxuICAgICAgLCBrZXlzICAgPSBnZXRTeW1ib2xzID8gX29iamVjdEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogX29iamVjdEtleXMoUylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaiAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gailpZihpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKVRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG4vLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxuXG5cbl9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GLCAnT2JqZWN0Jywge2Fzc2lnbjogX29iamVjdEFzc2lnbn0pO1xuXG52YXIgYXNzaWduJDEgPSBfY29yZS5PYmplY3QuYXNzaWduO1xuXG52YXIgYXNzaWduID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBhc3NpZ24kMSwgX19lc01vZHVsZTogdHJ1ZSB9O1xufSk7XG5cbnZhciBfT2JqZWN0JGFzc2lnbiA9IHVud3JhcEV4cG9ydHMoYXNzaWduKTtcblxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG5fZXhwb3J0KF9leHBvcnQuUywgJ09iamVjdCcsIHtjcmVhdGU6IF9vYmplY3RDcmVhdGV9KTtcblxudmFyICRPYmplY3QkMSA9IF9jb3JlLk9iamVjdDtcbnZhciBjcmVhdGUkMSA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKXtcbiAgcmV0dXJuICRPYmplY3QkMS5jcmVhdGUoUCwgRCk7XG59O1xuXG52YXIgY3JlYXRlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBjcmVhdGUkMSwgX19lc01vZHVsZTogdHJ1ZSB9O1xufSk7XG5cbnZhciBfT2JqZWN0JGNyZWF0ZSA9IHVud3JhcEV4cG9ydHMoY3JlYXRlKTtcblxuLyoqXG4gKiBjaGltZWUtaGVscGVyLWV2ZW50cyB2MC4xLjBcbiAqIChjKSAyMDE3IHRveGljLWpvaGFublxuICogUmVsZWFzZWQgdW5kZXIgTUlUXG4gKi9cblxuLyoqXG4qIEBtb2R1bGUgZXZlbnRcbiogQGF1dGhvciBodXp1bmppZVxuKiBAZGVzY3JpcHRpb24g6Ieq5a6a5LmJ5LqL5Lu25Z+656GA57G7XG4qL1xuXG4vKiDnvJPlrZjkuovku7bnm5HlkKzmlrnms5Xlj4rljIXoo4XvvIzlhoXpg6jmlbDmja7moLzlvI/vvJpcbiAqIHRhcmdldEluZGV4Xzx0eXBlOidjbGlja3xtb3VzZXVwfGRvbmUnPjogWyBbXG4gKiAgIGZ1bmN0aW9uKCl7IC4uLiBoYW5kbGVyIC4uLiB9LFxuICogICBmdW5jdGlvbigpeyAuLi4gaGFuZGxlcldyYXAgLi4uIGhhbmRsZXIuYXBwbHkodGFyZ2V0LCBhcmd1bWVudHMpIC4uLiB9LFxuICogICBpc09uY2VcbiAqIF1dXG4gKi9cbnZhciBfZXZ0TGlzdGVuZXJDYWNoZSA9IF9PYmplY3QkY3JlYXRlKG51bGwpO1xuX2V2dExpc3RlbmVyQ2FjaGUuY291bnQgPSAwO1xuXG4vKipcbiAqIOW+l+WIsOafkOWvueixoeeahOafkOS6i+S7tuexu+Wei+WvueW6lOeahOebkeWQrOmYn+WIl+aVsOe7hFxuICogQHBhcmFtICB7T2JqZWN0fSAgdGFyZ2V0IOWPkeeUn+S6i+S7tueahOWvueixoVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LKOi/memHjOeahOaXtumXtOexu+Wei+S4jeWPquaYr+WQjeensO+8jOi/mOaYr+e8k+WtmOagh+ivhu+8jOWPr+S7pemAmui/h+a3u+WKoOWQjue8gOadpeWMuuWIhilcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBnZXRFdnRUeXBlQ2FjaGUodGFyZ2V0LCB0eXBlKSB7XG5cbiAgdmFyIGV2dElkID0gdGFyZ2V0Ll9fZXZ0X2lkO1xuICBpZiAoIWV2dElkKSB7XG5cbiAgICAvKiDorr7nva5fX2V2dF9pZOS4jeWPr+aemuS4viAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdfX2V2dF9pZCcsIHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIC8qIOepuuWvueixoeWIneWni+WMlue7keWumue0ouW8lSAqL1xuICAgIGV2dElkID0gdGFyZ2V0Ll9fZXZ0X2lkID0gKytfZXZ0TGlzdGVuZXJDYWNoZS5jb3VudDtcbiAgfVxuXG4gIHZhciB0eXBlQ2FjaGVLZXkgPSBldnRJZCArICdfJyArIHR5cGU7XG4gIHZhciBldnRUeXBlQ2FjaGUgPSBfZXZ0TGlzdGVuZXJDYWNoZVt0eXBlQ2FjaGVLZXldO1xuICBpZiAoIWV2dFR5cGVDYWNoZSkge1xuICAgIGV2dFR5cGVDYWNoZSA9IF9ldnRMaXN0ZW5lckNhY2hlW3R5cGVDYWNoZUtleV0gPSBbXTtcbiAgfVxuXG4gIHJldHVybiBldnRUeXBlQ2FjaGU7XG59XG5cbi8qKlxuICog6Kem5Y+R5LqL5Lu255uR5ZCs5pa55rOVXG4gKiBAcGFyYW0gIHtPYmplY3R9ICB0YXJnZXQg5Y+R55Sf5LqL5Lu255qE5a+56LGhXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudE9iaiDop6blj5Hkuovku7bml7bopoHkvKDlm57nmoRldmVudOWvueixoVxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBlbWl0RXZlbnRDYWNoZSh0YXJnZXQsIHR5cGUsIGV2ZW50T2JqKSB7XG4gIHZhciBldnQgPSBfT2JqZWN0JGNyZWF0ZShudWxsKTtcbiAgZXZ0LnR5cGUgPSB0eXBlO1xuICBldnQudGFyZ2V0ID0gdGFyZ2V0O1xuICBpZiAoZXZlbnRPYmopIHtcbiAgICBfT2JqZWN0JGFzc2lnbihldnQsIGlzT2JqZWN0JDEoZXZlbnRPYmopID8gZXZlbnRPYmogOiB7IGRhdGE6IGV2ZW50T2JqIH0pO1xuICB9XG4gIGdldEV2dFR5cGVDYWNoZSh0YXJnZXQsIHR5cGUpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAoaXRlbVsxXSB8fCBpdGVtWzBdKS5hcHBseSh0YXJnZXQsIFtldnRdKTtcbiAgfSk7XG59XG5cbi8qKlxuICog5re75Yqg5LqL5Lu255uR5ZCs5Yiw57yT5a2YXG4gKiBAcGFyYW0gIHtPYmplY3R9ICB0YXJnZXQg5Y+R55Sf5LqL5Lu255qE5a+56LGhXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg55uR5ZCs5Ye95pWwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzT25jZSDmmK/lkKbljZXmrKHmiafooYxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJXcmFwXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50Q2FjaGUodGFyZ2V0LCB0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBpc09uY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICB2YXIgaGFuZGxlcldyYXAgPSBhcmd1bWVudHNbNF07XG5cbiAgaWYgKGlzRnVuY3Rpb24oaXNPbmNlKSAmJiAhaGFuZGxlcldyYXApIHtcbiAgICBoYW5kbGVyV3JhcCA9IGlzT25jZTtcbiAgICBpc09uY2UgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIGhhbmRsZXJzID0gW2hhbmRsZXIsIHVuZGVmaW5lZCwgaXNPbmNlXTtcbiAgaWYgKGlzT25jZSAmJiAhaGFuZGxlcldyYXApIHtcbiAgICBoYW5kbGVyV3JhcCA9IGZ1bmN0aW9uIGhhbmRsZXJXcmFwKCkge1xuICAgICAgcmVtb3ZlRXZlbnRDYWNoZSh0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIGlzT25jZSk7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZXIuYXBwbHkodGFyZ2V0LCBhcmdzKTtcbiAgICB9O1xuICB9XG4gIGlmIChoYW5kbGVyV3JhcCkge1xuICAgIGhhbmRsZXJzWzFdID0gaGFuZGxlcldyYXA7XG4gIH1cbiAgZ2V0RXZ0VHlwZUNhY2hlKHRhcmdldCwgdHlwZSkucHVzaChoYW5kbGVycyk7XG59XG5cbi8qKlxuICog56e76Zmk5LqL5Lu255uR5ZCsXG4gKiBAcGFyYW0gIHtPYmplY3R9ICB0YXJnZXQg5Y+R55Sf5LqL5Lu255qE5a+56LGhXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg55uR5ZCs5Ye95pWwXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50Q2FjaGUodGFyZ2V0LCB0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBpc09uY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gIHZhciB0eXBlQ2FjaGUgPSBnZXRFdnRUeXBlQ2FjaGUodGFyZ2V0LCB0eXBlKTtcblxuICBpZiAoaGFuZGxlciB8fCBpc09uY2UpIHtcbiAgICAvKiDmnInmjIflrpogaGFuZGxlciDliJnmuIXpmaTlr7nlupTnm5HlkKwgKi9cbiAgICB2YXIgaGFuZGxlcklkID0gLTE7XG4gICAgdmFyIGhhbmRsZXJXcmFwID0gdm9pZCAwO1xuICAgIHR5cGVDYWNoZS5maW5kKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICBpZiAoKCFoYW5kbGVyIHx8IGl0ZW1bMF0gPT09IGhhbmRsZXIpICYmICghaXNPbmNlIHx8IGl0ZW1bMl0pKSB7XG4gICAgICAgIGhhbmRsZXJJZCA9IGk7XG4gICAgICAgIGhhbmRsZXJXcmFwID0gaXRlbVsxXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGhhbmRsZXJJZCAhPT0gLTEpIHtcbiAgICAgIHR5cGVDYWNoZS5zcGxpY2UoaGFuZGxlcklkLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXJXcmFwO1xuICB9IGVsc2Uge1xuICAgIC8qIOacquaMh+WumiBoYW5kbGVyIOWImea4hemZpHR5cGXlr7nlupTnmoTmiYDmnInnm5HlkKwgKi9cbiAgICB0eXBlQ2FjaGUubGVuZ3RoID0gMDtcbiAgfVxufVxuXG4vKipcbiAqIEBjbGFzcyBDdXN0RXZlbnRcbiAqIEBkZXNjcmlwdGlvblxuICogRXZlbnQg6Ieq5a6a5LmJ5LqL5Lu257G7XG4gKiAxLiDlj6/ku6Xkvb/nlKjkuI3kvKDlj4LlvpfliLDnmoTlrp7kvovkvZzkuLpldmVudEJ1c+S9v+eUqFxuICogMi4g5Y+v5Lul6YCa6L+H5oyH5a6adGFyZ2V077yM55So5aSa5Liq5a6e5L6L5pON5L2c5ZCM5LiAdGFyZ2V05a+56LGh55qE5LqL5Lu2566h55CGXG4gKiAzLiDlvZPorr7lrpp0YXJnZXTml7bvvIzlj6/ku6XpgJrov4forr7nva5hc3NpZ27kuLp0cnVl77yM5p2l57uZdGFyZ2V05a6e546wXCJvblxcb25jZVxcb2ZmXFxlbWl0XCLmlrnms5VcbiAqIEBwYXJhbSAge09iamVjdH0gIHRhcmdldCDlj5HnlJ/kuovku7bnmoTlr7nosaHvvIjnqbrliJnpu5jorqTkuLpldmVudOWunuS+i++8iVxuICogQHBhcmFtICB7Qm9vbGVhbn0gIGFzc2lnbiDmmK/lkKblsIZcIm9uXFxvbmNlXFxvZmZcXGVtaXRcIuaWueazleWunueOsOWIsHRhcmdldOWvueixoeS4ilxuICogQHJldHVybiB7ZXZlbnR9XG4gKi9cbnZhciBDdXN0RXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEN1c3RFdmVudCh0YXJnZXQsIGFzc2lnbiQkMSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3VzdEV2ZW50KTtcblxuICAgIC8qIOiuvue9rl9fdGFyZ2V05LiN5Y+v5p6a5Li+ICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfX3RhcmdldCcsIHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9fdGFyZ2V0ID0gdGhpcztcblxuICAgIGlmICh0YXJnZXQpIHtcblxuICAgICAgaWYgKCh0eXBlb2YgdGFyZ2V0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0YXJnZXQpKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXNFdmVudCB0YXJnZXQgYXJlIG5vdCBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX190YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgIC8qIOS4unRhcmdldOWunueOsG9uXFxvbmNlXFxvZmZcXGVtaXQgKi9cbiAgICAgIGlmIChhc3NpZ24kJDEpIHtcbiAgICAgICAgWydvbicsICdvbmNlJywgJ29mZicsICdlbWl0J10uZm9yRWFjaChmdW5jdGlvbiAobXRoKSB7XG4gICAgICAgICAgdGFyZ2V0W210aF0gPSBfdGhpc1ttdGhdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICog5re75Yqg5LqL5Lu255uR5ZCsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOebkeWQrOWHveaVsFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzT25jZSDljZXmrKHnm5HlkKznsbvlnotcbiAgICogQHJldHVybiB7ZXZlbnR9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEN1c3RFdmVudCwgW3tcbiAgICBrZXk6ICdvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIHZhciBpc09uY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICBhZGRFdmVudENhY2hlKHRoaXMuX190YXJnZXQsIHR5cGUsIGhhbmRsZXIsIGlzT25jZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmt7vliqDkuovku7bnm5HlkKws5bm25LiU5Y+q5omn6KGM5LiA5qyhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDnm5HlkKzlh73mlbBcbiAgICAgKiBAcmV0dXJuIHtldmVudH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25jZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uY2UodHlwZSwgaGFuZGxlcikge1xuICAgICAgcmV0dXJuIHRoaXMub24odHlwZSwgaGFuZGxlciwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog56e76Zmk5LqL5Lu255uR5ZCsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDnm5HlkKzlh73mlbAo5LiN5oyH5a6aaGFuZGxlcuWImea4hemZpHR5cGXlr7nlupTnmoTmiYDmnInkuovku7bnm5HlkKwpXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc09uY2Ug5Y2V5qyh55uR5ZCs57G75Z6LXG4gICAgICogQHJldHVybiB7ZXZlbnR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29mZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZih0eXBlLCBoYW5kbGVyKSB7XG4gICAgICB2YXIgaXNPbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgcmVtb3ZlRXZlbnRDYWNoZSh0aGlzLl9fdGFyZ2V0LCB0eXBlLCBoYW5kbGVyLCBpc09uY2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6Kem5Y+R5LqL5Lu255uR5ZCs5Ye95pWwXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gICAgICogQHJldHVybiB7ZXZlbnR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2VtaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KHR5cGUsIGRhdGEpIHtcbiAgICAgIGVtaXRFdmVudENhY2hlKHRoaXMuX190YXJnZXQsIHR5cGUsIHsgZGF0YTogZGF0YSB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDdXN0RXZlbnQ7XG59KCk7XG5cbi8qKlxuICogY2hpbWVlLWhlbHBlci1kb20gdjAuMS4wXG4gKiAoYykgMjAxNyB0b3hpYy1qb2hhbm5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVFxuICovXG5cbi8qKlxuICogY2hpbWVlLWhlbHBlci1ldmVudHMgdjAuMS4wXG4gKiAoYykgMjAxNyB0b3hpYy1qb2hhbm5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVFxuICovXG5cbi8qKlxuKiBAbW9kdWxlIGV2ZW50XG4qIEBhdXRob3IgaHV6dW5qaWVcbiogQGRlc2NyaXB0aW9uIOiHquWumuS5ieS6i+S7tuWfuuehgOexu1xuKi9cblxuLyog57yT5a2Y5LqL5Lu255uR5ZCs5pa55rOV5Y+K5YyF6KOF77yM5YaF6YOo5pWw5o2u5qC85byP77yaXG4gKiB0YXJnZXRJbmRleF88dHlwZTonY2xpY2t8bW91c2V1cHxkb25lJz46IFsgW1xuICogICBmdW5jdGlvbigpeyAuLi4gaGFuZGxlciAuLi4gfSxcbiAqICAgZnVuY3Rpb24oKXsgLi4uIGhhbmRsZXJXcmFwIC4uLiBoYW5kbGVyLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKSAuLi4gfSxcbiAqICAgaXNPbmNlXG4gKiBdXVxuICovXG52YXIgX2V2dExpc3RlbmVyQ2FjaGUkMSA9IF9PYmplY3QkY3JlYXRlKG51bGwpO1xuX2V2dExpc3RlbmVyQ2FjaGUkMS5jb3VudCA9IDA7XG5cbi8qKlxuICog5b6X5Yiw5p+Q5a+56LGh55qE5p+Q5LqL5Lu257G75Z6L5a+55bqU55qE55uR5ZCs6Zif5YiX5pWw57uEXG4gKiBAcGFyYW0gIHtPYmplY3R9ICB0YXJnZXQg5Y+R55Sf5LqL5Lu255qE5a+56LGhXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDkuovku7bnsbvlnoso6L+Z6YeM55qE5pe26Ze057G75Z6L5LiN5Y+q5piv5ZCN56ew77yM6L+Y5piv57yT5a2Y5qCH6K+G77yM5Y+v5Lul6YCa6L+H5re75Yqg5ZCO57yA5p2l5Yy65YiGKVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGdldEV2dFR5cGVDYWNoZSQxKHRhcmdldCwgdHlwZSkge1xuXG4gIHZhciBldnRJZCA9IHRhcmdldC5fX2V2dF9pZDtcbiAgaWYgKCFldnRJZCkge1xuXG4gICAgLyog6K6+572uX19ldnRfaWTkuI3lj6/mnprkuL4gKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCAnX19ldnRfaWQnLCB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvKiDnqbrlr7nosaHliJ3lp4vljJbnu5HlrprntKLlvJUgKi9cbiAgICBldnRJZCA9IHRhcmdldC5fX2V2dF9pZCA9ICsrX2V2dExpc3RlbmVyQ2FjaGUkMS5jb3VudDtcbiAgfVxuXG4gIHZhciB0eXBlQ2FjaGVLZXkgPSBldnRJZCArICdfJyArIHR5cGU7XG4gIHZhciBldnRUeXBlQ2FjaGUgPSBfZXZ0TGlzdGVuZXJDYWNoZSQxW3R5cGVDYWNoZUtleV07XG4gIGlmICghZXZ0VHlwZUNhY2hlKSB7XG4gICAgZXZ0VHlwZUNhY2hlID0gX2V2dExpc3RlbmVyQ2FjaGUkMVt0eXBlQ2FjaGVLZXldID0gW107XG4gIH1cblxuICByZXR1cm4gZXZ0VHlwZUNhY2hlO1xufVxuXG4vKipcbiAqIOinpuWPkeS6i+S7tuebkeWQrOaWueazlVxuICogQHBhcmFtICB7T2JqZWN0fSAgdGFyZ2V0IOWPkeeUn+S6i+S7tueahOWvueixoVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRPYmog6Kem5Y+R5LqL5Lu25pe26KaB5Lyg5Zue55qEZXZlbnTlr7nosaFcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZW1pdEV2ZW50Q2FjaGUkMSh0YXJnZXQsIHR5cGUsIGV2ZW50T2JqKSB7XG4gIHZhciBldnQgPSBfT2JqZWN0JGNyZWF0ZShudWxsKTtcbiAgZXZ0LnR5cGUgPSB0eXBlO1xuICBldnQudGFyZ2V0ID0gdGFyZ2V0O1xuICBpZiAoZXZlbnRPYmopIHtcbiAgICBfT2JqZWN0JGFzc2lnbihldnQsIGlzT2JqZWN0JDEoZXZlbnRPYmopID8gZXZlbnRPYmogOiB7IGRhdGE6IGV2ZW50T2JqIH0pO1xuICB9XG4gIGdldEV2dFR5cGVDYWNoZSQxKHRhcmdldCwgdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIChpdGVtWzFdIHx8IGl0ZW1bMF0pLmFwcGx5KHRhcmdldCwgW2V2dF0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiDmt7vliqDkuovku7bnm5HlkKzliLDnvJPlrZhcbiAqIEBwYXJhbSAge09iamVjdH0gIHRhcmdldCDlj5HnlJ/kuovku7bnmoTlr7nosaFcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDnm5HlkKzlh73mlbBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPbmNlIOaYr+WQpuWNleasoeaJp+ihjFxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlcldyYXBcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gYWRkRXZlbnRDYWNoZSQxKHRhcmdldCwgdHlwZSwgaGFuZGxlcikge1xuICB2YXIgaXNPbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgdmFyIGhhbmRsZXJXcmFwID0gYXJndW1lbnRzWzRdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGlzT25jZSkgJiYgIWhhbmRsZXJXcmFwKSB7XG4gICAgaGFuZGxlcldyYXAgPSBpc09uY2U7XG4gICAgaXNPbmNlID0gdW5kZWZpbmVkO1xuICB9XG4gIHZhciBoYW5kbGVycyA9IFtoYW5kbGVyLCB1bmRlZmluZWQsIGlzT25jZV07XG4gIGlmIChpc09uY2UgJiYgIWhhbmRsZXJXcmFwKSB7XG4gICAgaGFuZGxlcldyYXAgPSBmdW5jdGlvbiBoYW5kbGVyV3JhcCgpIHtcbiAgICAgIHJlbW92ZUV2ZW50Q2FjaGUkMSh0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIGlzT25jZSk7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZXIuYXBwbHkodGFyZ2V0LCBhcmdzKTtcbiAgICB9O1xuICB9XG4gIGlmIChoYW5kbGVyV3JhcCkge1xuICAgIGhhbmRsZXJzWzFdID0gaGFuZGxlcldyYXA7XG4gIH1cbiAgZ2V0RXZ0VHlwZUNhY2hlJDEodGFyZ2V0LCB0eXBlKS5wdXNoKGhhbmRsZXJzKTtcbn1cblxuLyoqXG4gKiDnp7vpmaTkuovku7bnm5HlkKxcbiAqIEBwYXJhbSAge09iamVjdH0gIHRhcmdldCDlj5HnlJ/kuovku7bnmoTlr7nosaFcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDnm5HlkKzlh73mlbBcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRDYWNoZSQxKHRhcmdldCwgdHlwZSwgaGFuZGxlcikge1xuICB2YXIgaXNPbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICB2YXIgdHlwZUNhY2hlID0gZ2V0RXZ0VHlwZUNhY2hlJDEodGFyZ2V0LCB0eXBlKTtcblxuICBpZiAoaGFuZGxlciB8fCBpc09uY2UpIHtcbiAgICAvKiDmnInmjIflrpogaGFuZGxlciDliJnmuIXpmaTlr7nlupTnm5HlkKwgKi9cbiAgICB2YXIgaGFuZGxlcklkID0gLTE7XG4gICAgdmFyIGhhbmRsZXJXcmFwID0gdm9pZCAwO1xuICAgIHR5cGVDYWNoZS5maW5kKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICBpZiAoKCFoYW5kbGVyIHx8IGl0ZW1bMF0gPT09IGhhbmRsZXIpICYmICghaXNPbmNlIHx8IGl0ZW1bMl0pKSB7XG4gICAgICAgIGhhbmRsZXJJZCA9IGk7XG4gICAgICAgIGhhbmRsZXJXcmFwID0gaXRlbVsxXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGhhbmRsZXJJZCAhPT0gLTEpIHtcbiAgICAgIHR5cGVDYWNoZS5zcGxpY2UoaGFuZGxlcklkLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXJXcmFwO1xuICB9IGVsc2Uge1xuICAgIC8qIOacquaMh+WumiBoYW5kbGVyIOWImea4hemZpHR5cGXlr7nlupTnmoTmiYDmnInnm5HlkKwgKi9cbiAgICB0eXBlQ2FjaGUubGVuZ3RoID0gMDtcbiAgfVxufVxuXG4vKipcbiAqIEBjbGFzcyBDdXN0RXZlbnRcbiAqIEBkZXNjcmlwdGlvblxuICogRXZlbnQg6Ieq5a6a5LmJ5LqL5Lu257G7XG4gKiAxLiDlj6/ku6Xkvb/nlKjkuI3kvKDlj4LlvpfliLDnmoTlrp7kvovkvZzkuLpldmVudEJ1c+S9v+eUqFxuICogMi4g5Y+v5Lul6YCa6L+H5oyH5a6adGFyZ2V077yM55So5aSa5Liq5a6e5L6L5pON5L2c5ZCM5LiAdGFyZ2V05a+56LGh55qE5LqL5Lu2566h55CGXG4gKiAzLiDlvZPorr7lrpp0YXJnZXTml7bvvIzlj6/ku6XpgJrov4forr7nva5hc3NpZ27kuLp0cnVl77yM5p2l57uZdGFyZ2V05a6e546wXCJvblxcb25jZVxcb2ZmXFxlbWl0XCLmlrnms5VcbiAqIEBwYXJhbSAge09iamVjdH0gIHRhcmdldCDlj5HnlJ/kuovku7bnmoTlr7nosaHvvIjnqbrliJnpu5jorqTkuLpldmVudOWunuS+i++8iVxuICogQHBhcmFtICB7Qm9vbGVhbn0gIGFzc2lnbiDmmK/lkKblsIZcIm9uXFxvbmNlXFxvZmZcXGVtaXRcIuaWueazleWunueOsOWIsHRhcmdldOWvueixoeS4ilxuICogQHJldHVybiB7ZXZlbnR9XG4gKi9cbnZhciBDdXN0RXZlbnQkMSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3VzdEV2ZW50KHRhcmdldCwgYXNzaWduJCQxKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdXN0RXZlbnQpO1xuXG4gICAgLyog6K6+572uX190YXJnZXTkuI3lj6/mnprkuL4gKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19fdGFyZ2V0Jywge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuX190YXJnZXQgPSB0aGlzO1xuXG4gICAgaWYgKHRhcmdldCkge1xuXG4gICAgICBpZiAoKHR5cGVvZiB0YXJnZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRhcmdldCkpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1c0V2ZW50IHRhcmdldCBhcmUgbm90IG9iamVjdCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3RhcmdldCA9IHRhcmdldDtcblxuICAgICAgLyog5Li6dGFyZ2V05a6e546wb25cXG9uY2VcXG9mZlxcZW1pdCAqL1xuICAgICAgaWYgKGFzc2lnbiQkMSkge1xuICAgICAgICBbJ29uJywgJ29uY2UnLCAnb2ZmJywgJ2VtaXQnXS5mb3JFYWNoKGZ1bmN0aW9uIChtdGgpIHtcbiAgICAgICAgICB0YXJnZXRbbXRoXSA9IF90aGlzW210aF07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiDmt7vliqDkuovku7bnm5HlkKxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg55uR5ZCs5Ye95pWwXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPbmNlIOWNleasoeebkeWQrOexu+Wei1xuICAgKiBAcmV0dXJuIHtldmVudH1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ3VzdEV2ZW50LCBbe1xuICAgIGtleTogJ29uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24odHlwZSwgaGFuZGxlcikge1xuICAgICAgdmFyIGlzT25jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIGFkZEV2ZW50Q2FjaGUkMSh0aGlzLl9fdGFyZ2V0LCB0eXBlLCBoYW5kbGVyLCBpc09uY2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5re75Yqg5LqL5Lu255uR5ZCsLOW5tuS4lOWPquaJp+ihjOS4gOasoVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg55uR5ZCs5Ye95pWwXG4gICAgICogQHJldHVybiB7ZXZlbnR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbmNlKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLm9uKHR5cGUsIGhhbmRsZXIsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOenu+mZpOS6i+S7tuebkeWQrFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg55uR5ZCs5Ye95pWwKOS4jeaMh+WummhhbmRsZXLliJnmuIXpmaR0eXBl5a+55bqU55qE5omA5pyJ5LqL5Lu255uR5ZCsKVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPbmNlIOWNleasoeebkeWQrOexu+Wei1xuICAgICAqIEByZXR1cm4ge2V2ZW50fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvZmYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYodHlwZSwgaGFuZGxlcikge1xuICAgICAgdmFyIGlzT25jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIHJlbW92ZUV2ZW50Q2FjaGUkMSh0aGlzLl9fdGFyZ2V0LCB0eXBlLCBoYW5kbGVyLCBpc09uY2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6Kem5Y+R5LqL5Lu255uR5ZCs5Ye95pWwXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gICAgICogQHJldHVybiB7ZXZlbnR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2VtaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KHR5cGUsIGRhdGEpIHtcbiAgICAgIGVtaXRFdmVudENhY2hlJDEodGhpcy5fX3RhcmdldCwgdHlwZSwgeyBkYXRhOiBkYXRhIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1c3RFdmVudDtcbn0oKTtcblxuLyoqXG4gKiBjaGltZWUtaGVscGVyLXV0aWxzIHYwLjEuMVxuICogKGMpIDIwMTcgdG94aWMtam9oYW5uXG4gKiBSZWxlYXNlZCB1bmRlciBNSVRcbiAqL1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqICBqdWRnZW1lbnQgICAqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2hlY2sgaWYgdGhlIGNvZGUgcnVubmluZyBpbiBicm93c2VyIGVudmlyb25tZW50IChub3QgaW5jbHVkZSB3b3JrZXIgZW52KVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbnZhciBpbkJyb3dzZXIkMSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cpICE9PSAnW29iamVjdCBPYmplY3RdJztcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKiAg5a+56LGh5pON5L2cICAqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICog6L2s5Y+Y5LiA5Liq57G75pWw57uE5a+56LGh5Li65pWw57uEXG4gKi9cbmZ1bmN0aW9uIG1ha2VBcnJheSQxKG9iaikge1xuICByZXR1cm4gX0FycmF5JGZyb20ob2JqKTtcbn1cblxuLyoqXG4qIEBtb2R1bGUgZG9tXG4qIEBhdXRob3IgaHV6dW5qaWVcbiogQGRlc2NyaXB0aW9uIOS4gOS6m+W4uOeUqOeahERPTeWIpOaWreWPiuaTjeS9nOaWueazle+8jOWPr+S7peS9v+eUqGRvbS4kKCcqJynljIXoo4VET03vvIzlrp7njrDnsbtqUXVlcnnnmoTpk77lvI/mk43kvZzvvJvlvZPnhLbov5nph4znmoTpnZnmgIHmlrnms5XkuZ/lj6/ku6Xnm7TmjqXkvb/nlKjjgIJcbiovXG5cbnZhciBfZGl2RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbnZhciBfdGV4dEF0dHJOYW1lID0gJ2lubmVyVGV4dCc7XG4ndGV4dENvbnRlbnQnIGluIF9kaXZFbCAmJiAoX3RleHRBdHRyTmFtZSA9ICd0ZXh0Q29udGVudCcpO1xudmFyIF9hcnJQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKlxuICog6K+75Y+WSFRNTOWFg+e0oOWxnuaAp+WAvFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwg55uu5qCH5YWD57SgXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0ck5hbWUg55uu5qCH5bGe5oCn5ZCN56ewXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldEF0dHIoZWwsIGF0dHJOYW1lKSB7XG4gIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xufVxuXG4vKipcbiAqIOiuvue9rkhUTUzlhYPntKDlsZ7mgKflgLxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIOebruagh+WFg+e0oFxuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJOYW1lIOebruagh+WxnuaAp+WQjeensFxuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJWYWwg55uu5qCH5bGe5oCn5YC8XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHIoZWwsIGF0dHJOYW1lLCBhdHRyVmFsKSB7XG4gIGlmIChhdHRyVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICB9IGVsc2Uge1xuICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbCk7XG4gIH1cbn1cblxuLyoqXG4gKiDkuLpIVE1M5YWD57Sg5re75YqgY2xhc3NOYW1lXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCDnm67moIflhYPntKBcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbHMg6KaB5re75Yqg55qEY2xhc3NOYW1l77yI5aSa5Liq5Lul56m65qC85YiG5Ymy77yJXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzTmFtZShlbCwgY2xzKSB7XG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNsc0FyciA9IGNscy5zcGxpdCgvXFxzKy8pO1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgY2xzQXJyLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXJDbHMgPSAnICcgKyAoZWwuY2xhc3NOYW1lIHx8ICcnKSArICcgJztcbiAgICBjbHNBcnIuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgY3VyQ2xzLmluZGV4T2YoJyAnICsgYyArICcgJykgPT09IC0xICYmIChjdXJDbHMgKz0gJyAnICsgYyk7XG4gICAgfSk7XG4gICAgZWwuY2xhc3NOYW1lID0gY3VyQ2xzLnRyaW0oKTtcbiAgfVxufVxuXG4vKipcbiAqIOS4ukhUTUzlhYPntKDnp7vpmaRjbGFzc05hbWVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIOebruagh+WFg+e0oFxuICogQHBhcmFtIHtTdHJpbmd9IGNscyDopoHnp7vpmaTnmoRjbGFzc05hbWXvvIjlpJrkuKrku6XnqbrmoLzliIblibLvvIlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NOYW1lKGVsLCBjbHMpIHtcbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjbHNBcnIgPSBjbHMuc3BsaXQoL1xccysvKTtcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGNsc0Fyci5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyQ2xzID0gJyAnICsgZWwuY2xhc3NOYW1lICsgJyAnO1xuICAgIGNsc0Fyci5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICB2YXIgdGFyID0gJyAnICsgYyArICcgJztcbiAgICAgIHdoaWxlIChjdXJDbHMuaW5kZXhPZih0YXIpICE9PSAtMSkge1xuICAgICAgICBjdXJDbHMgPSBjdXJDbHMucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZWwuY2xhc3NOYW1lID0gY3VyQ2xzLnRyaW0oKTtcbiAgfVxufVxuXG4vKipcbiAqIOajgOafpUhUTUzlhYPntKDmmK/lkKblt7Lorr7nva5jbGFzc05hbWVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIOebruagh+WFg+e0oFxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSDopoHmo4Dmn6XnmoRjbGFzc05hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc0NsYXNzTmFtZShlbCwgY2xhc3NOYW1lKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefFxcXFxzKScgKyBjbGFzc05hbWUgKyAnKD89XFxcXHN8JCknKS50ZXN0KGVsLmNsYXNzTmFtZSk7XG59XG5cbi8qKlxuICog5Li6SFRNTOWFg+e0oOenu+mZpOS6i+S7tuebkeWQrFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwg55uu5qCH5YWD57SgXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDkuovku7blkI3np7BcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5aSE55CG5Ye95pWwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2Ug5piv5ZCm5Y+q55uR5ZCs5LiA5qyhXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmUg5piv5ZCm5Zyo5o2V6I636Zi25q6155qE55uR5ZCsXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50KGVsLCB0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBvbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgdmFyIGNhcHR1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gIGlmIChvbmNlKSB7XG4gICAgLyog5bCd6K+V5LuO57yT5a2Y5Lit6K+75Y+W5YyF6KOF5ZCO55qE5pa55rOVICovXG4gICAgdmFyIGhhbmRsZXJXcmFwID0gcmVtb3ZlRXZlbnRDYWNoZSQxKGVsLCB0eXBlICsgJ19vbmNlJywgaGFuZGxlcik7XG4gICAgaWYgKGhhbmRsZXJXcmFwKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcldyYXA7XG4gICAgfVxuICB9XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbi8qKlxuICog5Li6SFRNTOWFg+e0oOa3u+WKoOS6i+S7tuebkeWQrFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwg55uu5qCH5YWD57SgXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDkuovku7blkI3np7BcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5aSE55CG5Ye95pWwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2Ug5piv5ZCm5Y+q55uR5ZCs5LiA5qyhXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmUg5piv5ZCm5Zyo5o2V6I636Zi25q6155uR5ZCsXG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50KGVsLCB0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBvbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgdmFyIGNhcHR1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gIGlmIChvbmNlKSB7XG4gICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBvbGRIYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZW1vdmVFdmVudChlbCwgdHlwZSwgaGFuZGxlciwgb25jZSwgY2FwdHVyZSk7XG4gICAgICB9O1xuICAgIH0oKTtcbiAgICAvKiDlsIbljIXoo4XlkI7nmoTmlrnms5XorrDlvZXliLDnvJPlrZjkuK0gKi9cbiAgICBhZGRFdmVudENhY2hlJDEoZWwsIHR5cGUgKyAnX29uY2UnLCBvbGRIYW5kbGVyLCBoYW5kbGVyKTtcbiAgfVxuXG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbi8qKlxuICog5Li6SFRNTOWFg+e0oOa3u+WKoOS6i+S7tuS7o+eQhlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwg55uu5qCH5YWD57SgXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3Ig6KaB6KKr5Luj55CG55qE5YWD57SgXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDkuovku7blkI3np7BcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5aSE55CG5Ye95pWwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmUg5piv5ZCm5Zyo5o2V6I636Zi25q6155uR5ZCsXG4gKi9cbmZ1bmN0aW9uIGFkZERlbGVnYXRlKGVsLCBzZWxlY3RvciwgdHlwZSwgaGFuZGxlcikge1xuICB2YXIgY2FwdHVyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cblxuICB2YXIgaGFuZGxlcldyYXAgPSBmdW5jdGlvbiBoYW5kbGVyV3JhcChlKSB7XG4gICAgdmFyIHRhcmdldEVscyA9IGZpbmRQYXJlbnRzKGUuc3JjRWxlbWVudCwgZWwsIHRydWUpO1xuICAgIHZhciB0YXJnZXRFbCA9IHF1ZXJ5KHNlbGVjdG9yLCBlbCwgdHJ1ZSkuZmluZChmdW5jdGlvbiAoc2VFbCkge1xuICAgICAgcmV0dXJuIHRhcmdldEVscy5maW5kKGZ1bmN0aW9uICh0Z0VsKSB7XG4gICAgICAgIHJldHVybiBzZUVsID09PSB0Z0VsO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGFyZ2V0RWwgJiYgaGFuZGxlci5hcHBseSh0YXJnZXRFbCwgYXJndW1lbnRzKTtcbiAgfTtcbiAgLyog5bCG5YyF6KOF5ZCO55qE5pa55rOV6K6w5b2V5Yiw57yT5a2Y5LitICovXG4gIGFkZEV2ZW50Q2FjaGUkMShlbCwgdHlwZSArICdfZGVsZWdhdGVfJyArIHNlbGVjdG9yLCBoYW5kbGVyLCBoYW5kbGVyV3JhcCk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcldyYXAsIGNhcHR1cmUpO1xufVxuXG4vKipcbiAqIOS4ukhUTUzlhYPntKDnp7vpmaTkuovku7bku6PnkIZcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIOebruagh+WFg+e0oFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIOimgeiiq+S7o+eQhueahOWFg+e0oFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu25ZCN56ewXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOWkhOeQhuWHveaVsFxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlIOaYr+WQpuWcqOaNleiOt+mYtuauteebkeWQrFxuICovXG5mdW5jdGlvbiByZW1vdmVEZWxlZ2F0ZShlbCwgc2VsZWN0b3IsIHR5cGUsIGhhbmRsZXIpIHtcbiAgdmFyIGNhcHR1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gIC8qIOWwneivleS7jue8k+WtmOS4reivu+WPluWMheijheWQjueahOaWueazlSAqL1xuICB2YXIgaGFuZGxlcldyYXAgPSByZW1vdmVFdmVudENhY2hlJDEoZWwsIHR5cGUgKyAnX2RlbGVnYXRlXycgKyBzZWxlY3RvciwgaGFuZGxlcik7XG4gIGhhbmRsZXJXcmFwICYmIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcldyYXAsIGNhcHR1cmUpO1xufVxuXG4vKipcbiAqIOivu+WPlkhUTUzlhYPntKDmoLflvI/lgLxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIOebruagh+WFg+e0oFxuICogQHBhcmFtIHtTdHJpbmd9IGtleSDmoLflvI9rZXlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUoZWwsIGtleSkge1xuICByZXR1cm4gKGVsLmN1cnJlbnRTdHlsZSB8fCBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKSlba2V5XSB8fCBlbC5zdHlsZVtrZXldO1xufVxuXG4vKipcbiAqIOiuvue9rkhUTUzlhYPntKDmoLflvI/lgLxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIOebruagh+WFg+e0oFxuICogQHBhcmFtIHtTdHJpbmd9IGtleSDmoLflvI9rZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWwg5qC35byP5YC8XG4gKi9cbmZ1bmN0aW9uIHNldFN0eWxlKGVsLCBrZXksIHZhbCkge1xuICBpZiAoaXNPYmplY3QkMShrZXkpKSB7XG4gICAgZm9yICh2YXIgayBpbiBrZXkpIHtcbiAgICAgIHNldFN0eWxlKGVsLCBrLCBrZXlba10pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlbC5zdHlsZVtrZXldID0gdmFsO1xuICB9XG59XG5cbi8qKlxuICog5qC55o2u6YCJ5oup5Zmo5p+l6K+i55uu5qCH5YWD57SgXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3Ig6YCJ5oup5ZmoLOeUqOS6jiBxdWVyeVNlbGVjdG9yQWxsXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIg54i25a655ZmoXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRvQXJyYXkg5by65Yi26L6T5Ye65Li65pWw57uEXG4gKiBAcmV0dXJuIHtOb2RlTGlzdHxBcnJheX1cbiAqL1xuZnVuY3Rpb24gcXVlcnkoc2VsZWN0b3IpIHtcbiAgdmFyIGNvbnRhaW5lciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZG9jdW1lbnQ7XG4gIHZhciB0b0FycmF5ID0gYXJndW1lbnRzWzJdO1xuXG4gIHZhciByZXROb2RlTGlzdCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgcmV0dXJuIHRvQXJyYXkgPyBfQXJyYXkkZnJvbShyZXROb2RlTGlzdCkgOiByZXROb2RlTGlzdDtcbn1cblxuLyoqXG4gKiDku45ET03moJHkuK3np7vpmaRlbFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwg55uu5qCH5YWD57SgXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUVsKGVsKSB7XG4gIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xufVxuXG4vKipcbiAqIOafpeaJvuWFg+e0oOeahOeItuiKgueCueS7rFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwg55uu5qCH5YWD57SgXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbmRFbCDmnIDlpKfniLblrrnlmajvvIjkuI3mjIflrprliJnmib7liLBodG1s77yJXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGhhdmVFbCDljIXlkKvlvZPliY3lhYPntKBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaGF2ZUVuZEVsIOWMheWQq+iuvuWumueahOacgOWkp+eItuWuueWZqFxuICovXG5mdW5jdGlvbiBmaW5kUGFyZW50cyhlbCkge1xuICB2YXIgZW5kRWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gIHZhciBoYXZlRWwgPSBhcmd1bWVudHNbMl07XG4gIHZhciBoYXZlRW5kRWwgPSBhcmd1bWVudHNbM107XG5cbiAgdmFyIHJldEVscyA9IFtdO1xuICBpZiAoaGF2ZUVsKSB7XG4gICAgcmV0RWxzLnB1c2goZWwpO1xuICB9XG4gIHdoaWxlIChlbCAmJiBlbC5wYXJlbnROb2RlICE9PSBlbmRFbCkge1xuICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICBlbCAmJiByZXRFbHMucHVzaChlbCk7XG4gIH1cbiAgaWYgKGhhdmVFbmRFbCkge1xuICAgIHJldEVscy5wdXNoKGVuZEVsKTtcbiAgfVxuICByZXR1cm4gcmV0RWxzO1xufVxuXG4vKipcbiAqIOagueaNrumAieaLqeWZqOafpeivouW5tuW+l+WIsOebruagh+WFg+e0oOeahHdyYXDljIXoo4XlmahcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciDpgInmi6nlmags5Y+m5aSW5pSv5oyBIEhUTUxTdHJpbmd8fE5vZGVMaXN0fHxOb2RlQXJyYXl8fEhUTUxFbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIg54i25a655ZmoXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uICQoc2VsZWN0b3IsIGNvbnRhaW5lcikge1xuICByZXR1cm4gc2VsZWN0b3IuY29uc3RydWN0b3IgPT09IE5vZGVXcmFwID8gc2VsZWN0b3IgOiBuZXcgTm9kZVdyYXAoc2VsZWN0b3IsIGNvbnRhaW5lcik7XG59XG5cbi8qKlxuICogQGNsYXNzIE5vZGVXcmFwXG4gKiBAZGVzY3JpcHRpb25cbiAqIE5vZGVXcmFwIERPTeWMheijheWZqO+8jOeUqOS7peWunueOsOWfuuacrOeahOmTvuW8j+aTjeS9nFxuICogbmV3IGRvbS5Ob2RlV3JhcCgnKicpIOebuOW9k+S6jiBkb20uJCgnKicpXG4gKiDov5nph4zpnaLnlKjkuo5ET03mk43kvZznmoTlsZ7mgKfmlrnms5Xpg73mmK/ln7rkuo7kuIrpnaLpnZnmgIHmlrnms5Xlrp7njrDvvIzmnInpnIDopoHlj6/ku6Xpmo/ml7bkv67mlLnooaXlhYVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciDpgInmi6nlmago5YW85a65IFN0cmluZ3x8SFRNTFN0cmluZ3x8Tm9kZUxpc3R8fE5vZGVBcnJheXx8SFRNTEVsZW1lbnQpXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIg54i25a655Zmo77yI6buY6K6k5Li6ZG9jdW1lbnTvvIlcbiAqL1xuXG52YXIgTm9kZVdyYXAgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vZGVXcmFwKHNlbGVjdG9yKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZG9jdW1lbnQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZVdyYXApO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBfdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXG4gICAgLyogU3RyaW5nfHxOb2RlTGlzdHx8SFRNTEVsZW1lbnQg6K+G5Yir5aSE55CGICovXG4gICAgdmFyIGVsc0FyciA9IHZvaWQgMDtcbiAgICBpZiAoc2VsZWN0b3IgJiYgc2VsZWN0b3IuY29uc3RydWN0b3IgPT09IE5vZGVMaXN0KSB7XG4gICAgICAvKiDmlK/mjIHnm7TmjqXkvKDlhaVOb2RlTGlzdOadpeaehOW7uuWMheijheWZqCAqL1xuICAgICAgZWxzQXJyID0gbWFrZUFycmF5JDEoc2VsZWN0b3IpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShzZWxlY3RvcikpIHtcbiAgICAgIC8qIOaUr+aMgeebtOaOpeS8oOWFpU5vZGXmlbDnu4TmnaXmnoTlu7rljIXoo4XlmaggKi9cbiAgICAgIGVsc0FyciA9IHNlbGVjdG9yO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgICBpZiAoc2VsZWN0b3IuaW5kZXhPZignPCcpID09PSAwKSB7XG4gICAgICAgIC8qIOaUr+aMgeebtOaOpeS8oOWFpUhUTUzlrZfnrKbkuLLmnaXmlrDlu7pET03lubbmnoTlu7rljIXoo4XlmaggKi9cbiAgICAgICAgX2RpdkVsLmlubmVySFRNTCA9IHNlbGVjdG9yO1xuICAgICAgICBlbHNBcnIgPSBxdWVyeSgnKicsIF9kaXZFbCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiDmlK/mjIHnm7TmjqXkvKDlhaXlrZfnrKbkuLLpgInmi6nlmajmnaXmn6Xmib5ET03lubbmnoTlu7rljIXoo4XlmaggKi9cbiAgICAgICAgZWxzQXJyID0gcXVlcnkoc2VsZWN0b3IsIGNvbnRhaW5lciwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIOWFtuS7luS7u+aEj+WvueixoeebtOaOpeaehOW7uuWMheijheWZqCAqL1xuICAgICAgZWxzQXJyID0gW3NlbGVjdG9yXTtcbiAgICB9XG4gICAgX09iamVjdCRhc3NpZ24oX3RoaXMsIGVsc0Fycik7XG5cbiAgICAvKiBOb2RlV3JhcOacrOaEj+WPr+S7pSBleHRlbmRzIEFycmF555yB55Wl5p6E6YCg5pa55rOV5Lit5LiL6Z2i6L+Z6YOo5YiG5Luj56CB77yM5L2G55uu5YmN57yW6K+R5LiN5pSv5oyBICovXG4gICAgX3RoaXMubGVuZ3RoID0gZWxzQXJyLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiDlvqrnjq/pgY3ljoZET03pm4blkIhcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4g6YGN5Y6G5Ye95pWwIGZuKGl0ZW0sIGkpXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTm9kZVdyYXAsIFt7XG4gICAga2V5OiAnZWFjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVhY2goKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIF9hcnJQcm90b3R5cGUuZm9yRWFjaC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3B1c2gnLFxuXG5cbiAgICAvKipcbiAgICAgKiDmt7vliqDlhYPntKDliLBET03pm4blkIhcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCDopoHliqDlhaXnmoTlhYPntKBcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICBfYXJyUHJvdG90eXBlLnB1c2guYXBwbHkodGhpcywgYXJncyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzcGxpY2UnLFxuXG5cbiAgICAvKipcbiAgICAgKiDmiKrlj5ZET03pm4blkIjniYfmrrXvvIzlubblvpfliLDmlrDnmoTljIXoo4XlmahzcGxpY2VcbiAgICAgKiBAcGFyYW0ge051Ym1lcn0gc3RhcnRcbiAgICAgKiBAcGFyYW0ge051Ym1lcn0gY291bnRcbiAgICAgKiBAcmV0dXJuIHtOb2RlV3JhcH0g5paw55qERE9N6ZuG5ZCI5YyF6KOF5ZmoXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGljZSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICQoX2FyclByb3RvdHlwZS5zcGxpY2UuYXBwbHkodGhpcywgYXJncykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZpbmQnLFxuXG5cbiAgICAvKipcbiAgICAgKiDmn6Xmib7lrZDlhYPntKBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3Ig6YCJ5oup5ZmoXG4gICAgICogQHJldHVybiB7Tm9kZVdyYXB9IOaWsOeahERPTembhuWQiOWMheijheWZqFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgY2hpbGRzID0gW107XG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGNoaWxkcyA9IGNoaWxkcy5jb25jYXQocXVlcnkoc2VsZWN0b3IsIGVsLCB0cnVlKSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBjaGlsZHNXcmFwID0gJChjaGlsZHMpO1xuICAgICAgY2hpbGRzV3JhcC5wYXJlbnQgPSB0aGlzO1xuICAgICAgY2hpbGRzV3JhcC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgcmV0dXJuIGNoaWxkc1dyYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5re75Yqg5a2Q5YWD57SgXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2hpbGRFbHMg6KaB5re75Yqg55qESFRNTOWFg+e0oFxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FwcGVuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZChjaGlsZEVscykge1xuICAgICAgdmFyIGNoaWxkc1dyYXAgPSAkKGNoaWxkRWxzKTtcbiAgICAgIHZhciBmaXJzdEVsID0gdGhpc1swXTtcbiAgICAgIGNoaWxkc1dyYXAuZWFjaChmdW5jdGlvbiAobmV3RWwpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0RWwuYXBwZW5kQ2hpbGQobmV3RWwpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlsIblhYPntKDpm4blkIjmt7vliqDliLDmjIflrprlrrnlmahcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRFbCDopoHmt7vliqDliLDniLblrrnlmahcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhcHBlbmRUbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZFRvKHBhcmVudEVsKSB7XG4gICAgICAkKHBhcmVudEVsKS5hcHBlbmQodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBET03pm4blkIh0ZXh05YaF5a656K+75YaZ5pON5L2cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbCDmlofmnKzlhoXlrrnvvIjlpoLmnpzmnInorr7nva7or6Xlj4LmlbDliJnmiafooYzlhpnmk43kvZzvvIzlkKbliJnmiafooYzor7vmk43kvZzvvIlcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0ZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dCh2YWwpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzBdW190ZXh0QXR0ck5hbWVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWxbX3RleHRBdHRyTmFtZV0gPSB2YWw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBET03pm4blkIhIVE1M5YaF5a656K+75YaZ5pON5L2cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGh0bWwgaHRtbOWGheWuue+8iOWmguaenOacieiuvue9ruivpeWPguaVsOWImeaJp+ihjOWGmeaTjeS9nO+8jOWQpuWImeaJp+ihjOivu+aTjeS9nO+8iVxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2h0bWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBodG1sKF9odG1sKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpc1swXS5pbm5lckhUTUw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5pbm5lckhUTUwgPSBfaHRtbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERPTembhuWQiOWxnuaAp+ivu+WGmeaTjeS9nFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIOWxnuaAp+WQjeensFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwg5bGe5oCn5YC877yI5aaC5p6c5pyJ6K6+572u6K+l5Y+C5pWw5YiZ5omn6KGM5YaZ5pON5L2c77yM5ZCm5YiZ5omn6KGM6K+75pON5L2c77yJXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXR0cicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHIobmFtZSwgdmFsKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZ2V0QXR0cih0aGlzWzBdLCBuYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBzZXRBdHRyKGVsLCBuYW1lLCB2YWwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRE9N6ZuG5ZCIZGF0YXNldOivu+WGmeaTjeS9nFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkg6ZSu5ZCNXG4gICAgICogQHBhcmFtIHtBbnl9IHZhbCDplK7lgLzvvIjlpoLmnpzmnInorr7nva7or6Xlj4LmlbDliJnmiafooYzlhpnmk43kvZzvvIzlkKbliJnmiafooYzor7vmk43kvZzvvIlcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkYXRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0YShrZXksIHZhbCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0uZGF0YXNldCB8fCB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiAodGhpc1swXS5kYXRhc2V0IHx8IHt9KVtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgKGVsLmRhdGFzZXQgfHwgKGVsLmRhdGFzZXQgPSB7fSkpW2tleV0gPSB2YWw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBET03pm4blkIjmoLflvI/or7vlhpnmk43kvZxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IOagt+W8j2tleVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwg5qC35byP5YC877yI5aaC5p6c5pyJ6K6+572u6K+l5Y+C5pWw5YiZ5omn6KGM5YaZ5pON5L2c77yM5ZCm5YiZ5omn6KGM6K+75pON5L2c77yJXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3NzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3NzKGtleSwgdmFsKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAhaXNPYmplY3QkMShrZXkpKSB7XG4gICAgICAgIHJldHVybiBnZXRTdHlsZSh0aGlzWzBdLCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIHNldFN0eWxlKGVsLCBrZXksIHZhbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDkuLpET03pm4blkIjlop7liqBjbGFzc05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzIOimgeWinuWKoOeahGNsYXNzTmFtZVxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZENsYXNzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ2xhc3MoY2xzKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gYWRkQ2xhc3NOYW1lKGVsLCBjbHMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog56e76Zmk5b2T5YmNRE9N6ZuG5ZCI55qEY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNscyDopoHnp7vpmaTnmoRjbGFzc05hbWVcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmVDbGFzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNscykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUNsYXNzTmFtZShlbCwgY2xzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOajgOafpee0ouW8lTDnmoRET03mmK/lkKbmnIljbGFzc05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzIOimgeajgOafpeeahGNsYXNzTmFtZVxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2hhc0NsYXNzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQ2xhc3MoY2xzKSB7XG4gICAgICByZXR1cm4gaGFzQ2xhc3NOYW1lKHRoaXNbMF0sIGNscyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Li6RE9N6ZuG5ZCI5re75Yqg5LqL5Lu255uR5ZCsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu25ZCN56ewXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDlpITnkIblh73mlbBcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2Ug5piv5ZCm5Y+q55uR5ZCs5LiA5qyhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlIOaYr+WQpuWcqOaNleiOt+mYtuauteebkeWQrFxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24odHlwZSwgaGFuZGxlcikge1xuICAgICAgdmFyIG9uY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIGNhcHR1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gYWRkRXZlbnQoZWwsIHR5cGUsIGhhbmRsZXIsIG9uY2UsIGNhcHR1cmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Li6RE9N6ZuG5ZCI6Kej6Zmk5LqL5Lu255uR5ZCsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu25ZCN56ewXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDlpITnkIblh73mlbBcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2Ug5piv5ZCm5Y+q55uR5ZCs5LiA5qyhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlIOaYr+WQpuWcqOaNleiOt+mYtuauteebkeWQrFxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29mZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZih0eXBlLCBoYW5kbGVyKSB7XG4gICAgICB2YXIgb25jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgY2FwdHVyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVFdmVudChlbCwgdHlwZSwgaGFuZGxlciwgb25jZSwgY2FwdHVyZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDkuLpET03pm4blkIjnu5Hlrprkuovku7bku6PnkIZcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3Ig55uu5qCH5a2Q5YWD57Sg6YCJ5oup5ZmoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu25ZCN56ewXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDlpITnkIblh73mlbBcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmUg5piv5ZCm5Zyo5o2V6I636Zi25q6155uR5ZCsXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVsZWdhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxlZ2F0ZShzZWxlY3RvciwgdHlwZSwgaGFuZGxlcikge1xuICAgICAgdmFyIGNhcHR1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gYWRkRGVsZWdhdGUoZWwsIHNlbGVjdG9yLCB0eXBlLCBoYW5kbGVyLCBjYXB0dXJlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOS4ukRPTembhuWQiOino+e7keS6i+S7tuS7o+eQhlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciDnm67moIflrZDlhYPntKDpgInmi6nlmahcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDkuovku7blkI3np7BcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOWkhOeQhuWHveaVsFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZSDmmK/lkKblnKjmjZXojrfpmLbmrrXnm5HlkKxcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bmRlbGVnYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5kZWxlZ2F0ZShzZWxlY3RvciwgdHlwZSwgaGFuZGxlcikge1xuICAgICAgdmFyIGNhcHR1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRGVsZWdhdGUoZWwsIHNlbGVjdG9yLCB0eXBlLCBoYW5kbGVyLCBjYXB0dXJlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOS7jkRPTeagkeS4reenu+mZpFxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVFbChlbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9kZVdyYXA7XG59KCk7XG5cbi8qKlxuICogY2hpbWVlLWhlbHBlci1sb2cgdjAuMS4wXG4gKiAoYykgMjAxNyBzb25nZ3Vhbmd5dVxuICogUmVsZWFzZWQgdW5kZXIgTUlUXG4gKi9cblxudmFyIExvZyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTG9nKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb2cpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExvZywgbnVsbCwgW3tcbiAgICBrZXk6ICdlcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVycm9yKHRhZywgbXNnKSB7XG4gICAgICBpZiAoIUxvZy5FTkFCTEVfRVJST1IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRhZyB8fCBMb2cuRk9SQ0VfR0xPQkFMX1RBRykge1xuICAgICAgICB0YWcgPSBMb2cuR0xPQkFMX1RBRztcbiAgICAgIH1cbiAgICAgIHZhciBzdHIgPSAnWycgKyB0YWcgKyAnXSA+ICcgKyBtc2c7XG5cbiAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3Ioc3RyKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uc29sZS53YXJuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihzdHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coc3RyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbmZvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5mbyh0YWcsIG1zZykge1xuICAgICAgaWYgKCFMb2cuRU5BQkxFX0lORk8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRhZyB8fCBMb2cuRk9SQ0VfR0xPQkFMX1RBRykge1xuICAgICAgICB0YWcgPSBMb2cuR0xPQkFMX1RBRztcbiAgICAgIH1cblxuICAgICAgdmFyIHN0ciA9ICdbJyArIHRhZyArICddID4gJyArIG1zZztcblxuICAgICAgaWYgKGNvbnNvbGUuaW5mbykge1xuICAgICAgICBjb25zb2xlLmluZm8oc3RyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHN0cik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnd2FybicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdhcm4odGFnLCBtc2cpIHtcbiAgICAgIGlmICghTG9nLkVOQUJMRV9XQVJOKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0YWcgfHwgTG9nLkZPUkNFX0dMT0JBTF9UQUcpIHtcbiAgICAgICAgdGFnID0gTG9nLkdMT0JBTF9UQUc7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHIgPSAnWycgKyB0YWcgKyAnXSA+ICcgKyBtc2c7XG5cbiAgICAgIGlmIChjb25zb2xlLndhcm4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKHN0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhzdHIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlYnVnJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVidWcodGFnLCBtc2cpIHtcbiAgICAgIGlmICghTG9nLkVOQUJMRV9ERUJVRykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGFnIHx8IExvZy5GT1JDRV9HTE9CQUxfVEFHKSB7XG4gICAgICAgIHRhZyA9IExvZy5HTE9CQUxfVEFHO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RyID0gJ1snICsgdGFnICsgJ10gPiAnICsgbXNnO1xuXG4gICAgICBpZiAoY29uc29sZS5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmRlYnVnKHN0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhzdHIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ZlcmJvc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJib3NlKHRhZywgbXNnKSB7XG4gICAgICBpZiAoIUxvZy5FTkFCTEVfVkVSQk9TRSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGFnIHx8IExvZy5GT1JDRV9HTE9CQUxfVEFHKSB7XG4gICAgICAgIHRhZyA9IExvZy5HTE9CQUxfVEFHO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnWycgKyB0YWcgKyAnXSA+ICcgKyBtc2cpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMb2c7XG59KCk7XG5cbkxvZy5HTE9CQUxfVEFHID0gJ2NoaW1lZSc7XG5Mb2cuRk9SQ0VfR0xPQkFMX1RBRyA9IGZhbHNlO1xuTG9nLkVOQUJMRV9FUlJPUiA9IHRydWU7XG5Mb2cuRU5BQkxFX0lORk8gPSB0cnVlO1xuTG9nLkVOQUJMRV9XQVJOID0gdHJ1ZTtcbkxvZy5FTkFCTEVfREVCVUcgPSB0cnVlO1xuTG9nLkVOQUJMRV9WRVJCT1NFID0gdHJ1ZTtcblxuZXhwb3J0cy5Mb2cgPSBMb2c7XG5leHBvcnRzLmdlblRyYXZlcnNhbEhhbmRsZXIgPSBnZW5UcmF2ZXJzYWxIYW5kbGVyO1xuZXhwb3J0cy5kZWVwQ2xvbmUgPSBkZWVwQ2xvbmU7XG5leHBvcnRzLmRlZXBBc3NpZ24gPSBkZWVwQXNzaWduO1xuZXhwb3J0cy5jYW1lbGl6ZSA9IGNhbWVsaXplO1xuZXhwb3J0cy5oeXBlbmF0ZSA9IGh5cGVuYXRlO1xuZXhwb3J0cy5iaW5kID0gYmluZDtcbmV4cG9ydHMudXVpZCA9IHV1aWQ7XG5leHBvcnRzLlM0ID0gUzQ7XG5leHBvcnRzLnJhbmQgPSByYW5kO1xuZXhwb3J0cy5pc1ZvaWQgPSBpc1ZvaWQ7XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdCQxO1xuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuZXhwb3J0cy5pc051bWVyaWMgPSBpc051bWVyaWM7XG5leHBvcnRzLmlzSW50ZWdlciA9IGlzSW50ZWdlcjtcbmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XG5leHBvcnRzLmlzRXZlbnQgPSBpc0V2ZW50O1xuZXhwb3J0cy5pc0Jsb2IgPSBpc0Jsb2I7XG5leHBvcnRzLmlzRmlsZSA9IGlzRmlsZTtcbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcbmV4cG9ydHMuaXNVcmwgPSBpc1VybDtcbmV4cG9ydHMuaXNOb2RlID0gaXNOb2RlO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzQ2hpbGROb2RlID0gaXNDaGlsZE5vZGU7XG5leHBvcnRzLmlzUG9zdGVyaXR5Tm9kZSA9IGlzUG9zdGVyaXR5Tm9kZTtcbmV4cG9ydHMuaXNIVE1MU3RyaW5nID0gaXNIVE1MU3RyaW5nO1xuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcbmV4cG9ydHMuaW5Ccm93c2VyID0gaW5Ccm93c2VyO1xuZXhwb3J0cy5tYWtlQXJyYXkgPSBtYWtlQXJyYXk7XG5leHBvcnRzLnRyYW5zT2JqZWN0QXR0ckludG9BcnJheSA9IHRyYW5zT2JqZWN0QXR0ckludG9BcnJheTtcbmV4cG9ydHMucnVuUmVqZWN0YWJsZVF1ZXVlID0gcnVuUmVqZWN0YWJsZVF1ZXVlO1xuZXhwb3J0cy5ydW5TdG9wcGFibGVRdWV1ZSA9IHJ1blN0b3BwYWJsZVF1ZXVlO1xuZXhwb3J0cy5zZXRGcm96ZW5BdHRyID0gc2V0RnJvemVuQXR0cjtcbmV4cG9ydHMuc2V0QXR0ckdldHRlckFuZFNldHRlciA9IHNldEF0dHJHZXR0ZXJBbmRTZXR0ZXI7XG5leHBvcnRzLmRlY29kZVVURjggPSBkZWNvZGVVVEY4O1xuZXhwb3J0cy5kZWJvdW5jZSA9IGRlYm91bmNlO1xuZXhwb3J0cy50aHJvdHRsZSA9IHRocm90dGxlO1xuZXhwb3J0cy5yYWYgPSByYWY7XG5leHBvcnRzLmNhZiA9IGNhZjtcbmV4cG9ydHMuc3RyUmVwZWF0ID0gc3RyUmVwZWF0O1xuZXhwb3J0cy5mb3JtYXRUaW1lID0gZm9ybWF0VGltZTtcbmV4cG9ydHMuYWRkVHJhbnNNZXRob2QgPSBhZGRUcmFuc01ldGhvZDtcbmV4cG9ydHMuYXBwZW5kQ1NTID0gYXBwZW5kQ1NTO1xuZXhwb3J0cy5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcbmV4cG9ydHMuZ2V0TG9jYWxTdG9yYWdlID0gZ2V0TG9jYWxTdG9yYWdlO1xuZXhwb3J0cy5zZXRMb2NhbFN0b3JhZ2UgPSBzZXRMb2NhbFN0b3JhZ2U7XG5leHBvcnRzLmVtaXRFdmVudENhY2hlID0gZW1pdEV2ZW50Q2FjaGU7XG5leHBvcnRzLmFkZEV2ZW50Q2FjaGUgPSBhZGRFdmVudENhY2hlO1xuZXhwb3J0cy5yZW1vdmVFdmVudENhY2hlID0gcmVtb3ZlRXZlbnRDYWNoZTtcbmV4cG9ydHMuQ3VzdEV2ZW50ID0gQ3VzdEV2ZW50O1xuZXhwb3J0cy5nZXRBdHRyID0gZ2V0QXR0cjtcbmV4cG9ydHMuc2V0QXR0ciA9IHNldEF0dHI7XG5leHBvcnRzLmFkZENsYXNzTmFtZSA9IGFkZENsYXNzTmFtZTtcbmV4cG9ydHMucmVtb3ZlQ2xhc3NOYW1lID0gcmVtb3ZlQ2xhc3NOYW1lO1xuZXhwb3J0cy5oYXNDbGFzc05hbWUgPSBoYXNDbGFzc05hbWU7XG5leHBvcnRzLnJlbW92ZUV2ZW50ID0gcmVtb3ZlRXZlbnQ7XG5leHBvcnRzLmFkZEV2ZW50ID0gYWRkRXZlbnQ7XG5leHBvcnRzLmFkZERlbGVnYXRlID0gYWRkRGVsZWdhdGU7XG5leHBvcnRzLnJlbW92ZURlbGVnYXRlID0gcmVtb3ZlRGVsZWdhdGU7XG5leHBvcnRzLmdldFN0eWxlID0gZ2V0U3R5bGU7XG5leHBvcnRzLnNldFN0eWxlID0gc2V0U3R5bGU7XG5leHBvcnRzLnF1ZXJ5ID0gcXVlcnk7XG5leHBvcnRzLnJlbW92ZUVsID0gcmVtb3ZlRWw7XG5leHBvcnRzLmZpbmRQYXJlbnRzID0gZmluZFBhcmVudHM7XG5leHBvcnRzLiQgPSAkO1xuZXhwb3J0cy5Ob2RlV3JhcCA9IE5vZGVXcmFwO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NoaW1lZS1oZWxwZXIvbGliL2luZGV4LmJyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(0);


/***/ })
/******/ ]);