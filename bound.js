/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 19);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("class Error {\n    constructor (type) {\n        this.type = type;\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = Error;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvdXRpbHMvZXJyb3IuanM/OWQ2MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yICh0eXBlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvdXRpbHMvZXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exp_golomb_js__ = __webpack_require__(7);\n/**\n * reference flv.js\n */\n/* eslint-disable */\n\n\nclass SPSParser {\n\n    static _ebsp2rbsp(uint8array) {\n        const src = uint8array;\n        const src_length = src.byteLength;\n        const dst = new Uint8Array(src_length);\n        let dst_idx = 0;\n\n        for (let i = 0; i < src_length; i++) {\n            if (i >= 2) {\n                // Unescape: Skip 0x03 after 00 00\n                if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {\n                    continue;\n                }\n            }\n            dst[dst_idx] = src[i];\n            dst_idx++;\n        }\n\n        return new Uint8Array(dst.buffer, 0, dst_idx);\n    }\n\n    static parseSPS(uint8array) {\n        const rbsp = SPSParser._ebsp2rbsp(uint8array);\n        let gb = new __WEBPACK_IMPORTED_MODULE_0__exp_golomb_js__[\"a\" /* default */](rbsp);\n\n        gb.readByte();\n        const profile_idc = gb.readByte(); // profile_idc\n        gb.readByte(); // constraint_set_flags[5] + reserved_zero[3]\n        const level_idc = gb.readByte(); // level_idc\n        gb.readUEG(); // seq_parameter_set_id\n\n        const profile_string = SPSParser.getProfileString(profile_idc);\n        const level_string = SPSParser.getLevelString(level_idc);\n        let chroma_format_idc = 1;\n        let chroma_format = 420;\n        const chroma_format_table = [0, 420, 422, 444];\n        let bit_depth = 8;\n\n        if (profile_idc === 100 || profile_idc === 110 || profile_idc === 122 ||\n            profile_idc === 244 || profile_idc === 44 || profile_idc === 83 ||\n            profile_idc === 86 || profile_idc === 118 || profile_idc === 128 ||\n            profile_idc === 138 || profile_idc === 144) {\n\n            chroma_format_idc = gb.readUEG();\n            if (chroma_format_idc === 3) {\n                gb.readBits(1); // separate_colour_plane_flag\n            }\n            if (chroma_format_idc <= 3) {\n                chroma_format = chroma_format_table[chroma_format_idc];\n            }\n\n            bit_depth = gb.readUEG() + 8; // bit_depth_luma_minus8\n            gb.readUEG(); // bit_depth_chroma_minus8\n            gb.readBits(1); // qpprime_y_zero_transform_bypass_flag\n            if (gb.readBool()) { // seq_scaling_matrix_present_flag\n                const scaling_list_count = (chroma_format_idc !== 3) ? 8 : 12;\n                for (let i = 0; i < scaling_list_count; i++) {\n                    if (gb.readBool()) { // seq_scaling_list_present_flag\n                        if (i < 6) {\n                            SPSParser._skipScalingList(gb, 16);\n                        } else {\n                            SPSParser._skipScalingList(gb, 64);\n                        }\n                    }\n                }\n            }\n        }\n        gb.readUEG(); // log2_max_frame_num_minus4\n        const pic_order_cnt_type = gb.readUEG();\n        if (pic_order_cnt_type === 0) {\n            gb.readUEG(); // log2_max_pic_order_cnt_lsb_minus_4\n        } else if (pic_order_cnt_type === 1) {\n            gb.readBits(1); // delta_pic_order_always_zero_flag\n            gb.readSEG(); // offset_for_non_ref_pic\n            gb.readSEG(); // offset_for_top_to_bottom_field\n            const num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();\n            for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {\n                gb.readSEG(); // offset_for_ref_frame\n            }\n        }\n        gb.readUEG(); // max_num_ref_frames\n        gb.readBits(1); // gaps_in_frame_num_value_allowed_flag\n\n        const pic_width_in_mbs_minus1 = gb.readUEG();\n        const pic_height_in_map_units_minus1 = gb.readUEG();\n\n        const frame_mbs_only_flag = gb.readBits(1);\n        if (frame_mbs_only_flag === 0) {\n            gb.readBits(1); // mb_adaptive_frame_field_flag\n        }\n        gb.readBits(1); // direct_8x8_inference_flag\n\n        let frame_crop_left_offset = 0;\n        let frame_crop_right_offset = 0;\n        let frame_crop_top_offset = 0;\n        let frame_crop_bottom_offset = 0;\n\n        const frame_cropping_flag = gb.readBool();\n        if (frame_cropping_flag) {\n            frame_crop_left_offset = gb.readUEG();\n            frame_crop_right_offset = gb.readUEG();\n            frame_crop_top_offset = gb.readUEG();\n            frame_crop_bottom_offset = gb.readUEG();\n        }\n\n        let sar_width = 1,\n            sar_height = 1;\n        let fps = 0,\n            fps_fixed = true,\n            fps_num = 0,\n            fps_den = 0;\n\n        const vui_parameters_present_flag = gb.readBool();\n        if (vui_parameters_present_flag) {\n            if (gb.readBool()) { // aspect_ratio_info_present_flag\n                const aspect_ratio_idc = gb.readByte();\n                const sar_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\n                const sar_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];\n\n                if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n                    sar_width = sar_w_table[aspect_ratio_idc - 1];\n                    sar_height = sar_h_table[aspect_ratio_idc - 1];\n                } else if (aspect_ratio_idc === 255) {\n                    sar_width = gb.readByte() << 8 | gb.readByte();\n                    sar_height = gb.readByte() << 8 | gb.readByte();\n                }\n            }\n\n            if (gb.readBool()) { // overscan_info_present_flag\n                gb.readBool(); // overscan_appropriate_flag\n            }\n            if (gb.readBool()) { // video_signal_type_present_flag\n                gb.readBits(4); // video_format & video_full_range_flag\n                if (gb.readBool()) { // colour_description_present_flag\n                    gb.readBits(24); // colour_primaries & transfer_characteristics & matrix_coefficients\n                }\n            }\n            if (gb.readBool()) { // chroma_loc_info_present_flag\n                gb.readUEG(); // chroma_sample_loc_type_top_field\n                gb.readUEG(); // chroma_sample_loc_type_bottom_field\n            }\n            if (gb.readBool()) { // timing_info_present_flag\n                const num_units_in_tick = gb.readBits(32);\n                const time_scale = gb.readBits(32);\n                fps_fixed = gb.readBool(); // fixed_frame_rate_flag\n\n                fps_num = time_scale;\n                fps_den = num_units_in_tick * 2;\n                fps = fps_num / fps_den;\n            }\n        }\n\n        let sarScale = 1;\n        if (sar_width !== 1 || sar_height !== 1) {\n            sarScale = sar_width / sar_height;\n        }\n\n        let crop_unit_x = 0,\n            crop_unit_y = 0;\n        if (chroma_format_idc === 0) {\n            crop_unit_x = 1;\n            crop_unit_y = 2 - frame_mbs_only_flag;\n        } else {\n            const sub_wc = (chroma_format_idc === 3) ? 1 : 2;\n            const sub_hc = (chroma_format_idc === 1) ? 2 : 1;\n            crop_unit_x = sub_wc;\n            crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);\n        }\n\n        let codec_width = (pic_width_in_mbs_minus1 + 1) * 16;\n        let codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);\n\n        codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;\n        codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;\n\n        const present_width = Math.ceil(codec_width * sarScale);\n\n        gb.destroy();\n        gb = null;\n\n        return {\n            profile_string, // baseline, high, high10, ...\n            level_string, // 3, 3.1, 4, 4.1, 5, 5.1, ...\n            bit_depth, // 8bit, 10bit, ...\n            chroma_format, // 4:2:0, 4:2:2, ...\n            chroma_format_string: SPSParser.getChromaFormatString(chroma_format),\n\n            frame_rate: {\n                fixed: fps_fixed,\n                fps,\n                fps_den,\n                fps_num\n            },\n\n            sar_ratio: {\n                width: sar_width,\n                height: sar_height\n            },\n\n            codec_size: {\n                width: codec_width,\n                height: codec_height\n            },\n\n            present_size: {\n                width: present_width,\n                height: codec_height\n            }\n        };\n    }\n\n    static _skipScalingList(gb, count) {\n        let last_scale = 8,\n            next_scale = 8;\n        let delta_scale = 0;\n        for (let i = 0; i < count; i++) {\n            if (next_scale !== 0) {\n                delta_scale = gb.readSEG();\n                next_scale = (last_scale + delta_scale + 256) % 256;\n            }\n            last_scale = (next_scale === 0) ? last_scale : next_scale;\n        }\n    }\n\n    static getProfileString(profile_idc) {\n        switch (profile_idc) {\n            case 66:\n                return 'Baseline';\n            case 77:\n                return 'Main';\n            case 88:\n                return 'Extended';\n            case 100:\n                return 'High';\n            case 110:\n                return 'High10';\n            case 122:\n                return 'High422';\n            case 244:\n                return 'High444';\n            default:\n                return 'Unknown';\n        }\n    }\n\n    static getLevelString(level_idc) {\n        return (level_idc / 10).toFixed(1);\n    }\n\n    static getChromaFormatString(chroma) {\n        switch (chroma) {\n            case 420:\n                return '4:2:0';\n            case 422:\n                return '4:2:2';\n            case 444:\n                return '4:4:4';\n            default:\n                return 'Unknown';\n        }\n    }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (SPSParser);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvZmx2L3Nwcy1wYXJzZXIuanM/MjUwNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQyxzQkFBc0I7QUFDdEIsd0NBQXdDO0FBQ3hDLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDLHlCQUF5QjtBQUN6QiwyQkFBMkI7QUFDM0IsZ0NBQWdDO0FBQ2hDO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RCx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7QUFDQSwyQkFBMkIsMkNBQTJDO0FBQ3RFLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHVCQUF1Qjs7QUFFdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUI7QUFDQSxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHJlZmVyZW5jZSBmbHYuanNcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBFeHBHb2xvbWIgZnJvbSAnLi9leHAtZ29sb21iLmpzJztcblxuY2xhc3MgU1BTUGFyc2VyIHtcblxuICAgIHN0YXRpYyBfZWJzcDJyYnNwKHVpbnQ4YXJyYXkpIHtcbiAgICAgICAgY29uc3Qgc3JjID0gdWludDhhcnJheTtcbiAgICAgICAgY29uc3Qgc3JjX2xlbmd0aCA9IHNyYy5ieXRlTGVuZ3RoO1xuICAgICAgICBjb25zdCBkc3QgPSBuZXcgVWludDhBcnJheShzcmNfbGVuZ3RoKTtcbiAgICAgICAgbGV0IGRzdF9pZHggPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gVW5lc2NhcGU6IFNraXAgMHgwMyBhZnRlciAwMCAwMFxuICAgICAgICAgICAgICAgIGlmIChzcmNbaV0gPT09IDB4MDMgJiYgc3JjW2kgLSAxXSA9PT0gMHgwMCAmJiBzcmNbaSAtIDJdID09PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRzdFtkc3RfaWR4XSA9IHNyY1tpXTtcbiAgICAgICAgICAgIGRzdF9pZHgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkc3QuYnVmZmVyLCAwLCBkc3RfaWR4KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2VTUFModWludDhhcnJheSkge1xuICAgICAgICBjb25zdCByYnNwID0gU1BTUGFyc2VyLl9lYnNwMnJic3AodWludDhhcnJheSk7XG4gICAgICAgIGxldCBnYiA9IG5ldyBFeHBHb2xvbWIocmJzcCk7XG5cbiAgICAgICAgZ2IucmVhZEJ5dGUoKTtcbiAgICAgICAgY29uc3QgcHJvZmlsZV9pZGMgPSBnYi5yZWFkQnl0ZSgpOyAvLyBwcm9maWxlX2lkY1xuICAgICAgICBnYi5yZWFkQnl0ZSgpOyAvLyBjb25zdHJhaW50X3NldF9mbGFnc1s1XSArIHJlc2VydmVkX3plcm9bM11cbiAgICAgICAgY29uc3QgbGV2ZWxfaWRjID0gZ2IucmVhZEJ5dGUoKTsgLy8gbGV2ZWxfaWRjXG4gICAgICAgIGdiLnJlYWRVRUcoKTsgLy8gc2VxX3BhcmFtZXRlcl9zZXRfaWRcblxuICAgICAgICBjb25zdCBwcm9maWxlX3N0cmluZyA9IFNQU1BhcnNlci5nZXRQcm9maWxlU3RyaW5nKHByb2ZpbGVfaWRjKTtcbiAgICAgICAgY29uc3QgbGV2ZWxfc3RyaW5nID0gU1BTUGFyc2VyLmdldExldmVsU3RyaW5nKGxldmVsX2lkYyk7XG4gICAgICAgIGxldCBjaHJvbWFfZm9ybWF0X2lkYyA9IDE7XG4gICAgICAgIGxldCBjaHJvbWFfZm9ybWF0ID0gNDIwO1xuICAgICAgICBjb25zdCBjaHJvbWFfZm9ybWF0X3RhYmxlID0gWzAsIDQyMCwgNDIyLCA0NDRdO1xuICAgICAgICBsZXQgYml0X2RlcHRoID0gODtcblxuICAgICAgICBpZiAocHJvZmlsZV9pZGMgPT09IDEwMCB8fCBwcm9maWxlX2lkYyA9PT0gMTEwIHx8IHByb2ZpbGVfaWRjID09PSAxMjIgfHxcbiAgICAgICAgICAgIHByb2ZpbGVfaWRjID09PSAyNDQgfHwgcHJvZmlsZV9pZGMgPT09IDQ0IHx8IHByb2ZpbGVfaWRjID09PSA4MyB8fFxuICAgICAgICAgICAgcHJvZmlsZV9pZGMgPT09IDg2IHx8IHByb2ZpbGVfaWRjID09PSAxMTggfHwgcHJvZmlsZV9pZGMgPT09IDEyOCB8fFxuICAgICAgICAgICAgcHJvZmlsZV9pZGMgPT09IDEzOCB8fCBwcm9maWxlX2lkYyA9PT0gMTQ0KSB7XG5cbiAgICAgICAgICAgIGNocm9tYV9mb3JtYXRfaWRjID0gZ2IucmVhZFVFRygpO1xuICAgICAgICAgICAgaWYgKGNocm9tYV9mb3JtYXRfaWRjID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZ2IucmVhZEJpdHMoMSk7IC8vIHNlcGFyYXRlX2NvbG91cl9wbGFuZV9mbGFnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hyb21hX2Zvcm1hdF9pZGMgPD0gMykge1xuICAgICAgICAgICAgICAgIGNocm9tYV9mb3JtYXQgPSBjaHJvbWFfZm9ybWF0X3RhYmxlW2Nocm9tYV9mb3JtYXRfaWRjXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYml0X2RlcHRoID0gZ2IucmVhZFVFRygpICsgODsgLy8gYml0X2RlcHRoX2x1bWFfbWludXM4XG4gICAgICAgICAgICBnYi5yZWFkVUVHKCk7IC8vIGJpdF9kZXB0aF9jaHJvbWFfbWludXM4XG4gICAgICAgICAgICBnYi5yZWFkQml0cygxKTsgLy8gcXBwcmltZV95X3plcm9fdHJhbnNmb3JtX2J5cGFzc19mbGFnXG4gICAgICAgICAgICBpZiAoZ2IucmVhZEJvb2woKSkgeyAvLyBzZXFfc2NhbGluZ19tYXRyaXhfcHJlc2VudF9mbGFnXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGluZ19saXN0X2NvdW50ID0gKGNocm9tYV9mb3JtYXRfaWRjICE9PSAzKSA/IDggOiAxMjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjYWxpbmdfbGlzdF9jb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnYi5yZWFkQm9vbCgpKSB7IC8vIHNlcV9zY2FsaW5nX2xpc3RfcHJlc2VudF9mbGFnXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTUFNQYXJzZXIuX3NraXBTY2FsaW5nTGlzdChnYiwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTUFNQYXJzZXIuX3NraXBTY2FsaW5nTGlzdChnYiwgNjQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdiLnJlYWRVRUcoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuICAgICAgICBjb25zdCBwaWNfb3JkZXJfY250X3R5cGUgPSBnYi5yZWFkVUVHKCk7XG4gICAgICAgIGlmIChwaWNfb3JkZXJfY250X3R5cGUgPT09IDApIHtcbiAgICAgICAgICAgIGdiLnJlYWRVRUcoKTsgLy8gbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXNfNFxuICAgICAgICB9IGVsc2UgaWYgKHBpY19vcmRlcl9jbnRfdHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgZ2IucmVhZEJpdHMoMSk7IC8vIGRlbHRhX3BpY19vcmRlcl9hbHdheXNfemVyb19mbGFnXG4gICAgICAgICAgICBnYi5yZWFkU0VHKCk7IC8vIG9mZnNldF9mb3Jfbm9uX3JlZl9waWNcbiAgICAgICAgICAgIGdiLnJlYWRTRUcoKTsgLy8gb2Zmc2V0X2Zvcl90b3BfdG9fYm90dG9tX2ZpZWxkXG4gICAgICAgICAgICBjb25zdCBudW1fcmVmX2ZyYW1lc19pbl9waWNfb3JkZXJfY250X2N5Y2xlID0gZ2IucmVhZFVFRygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1fcmVmX2ZyYW1lc19pbl9waWNfb3JkZXJfY250X2N5Y2xlOyBpKyspIHtcbiAgICAgICAgICAgICAgICBnYi5yZWFkU0VHKCk7IC8vIG9mZnNldF9mb3JfcmVmX2ZyYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2IucmVhZFVFRygpOyAvLyBtYXhfbnVtX3JlZl9mcmFtZXNcbiAgICAgICAgZ2IucmVhZEJpdHMoMSk7IC8vIGdhcHNfaW5fZnJhbWVfbnVtX3ZhbHVlX2FsbG93ZWRfZmxhZ1xuXG4gICAgICAgIGNvbnN0IHBpY193aWR0aF9pbl9tYnNfbWludXMxID0gZ2IucmVhZFVFRygpO1xuICAgICAgICBjb25zdCBwaWNfaGVpZ2h0X2luX21hcF91bml0c19taW51czEgPSBnYi5yZWFkVUVHKCk7XG5cbiAgICAgICAgY29uc3QgZnJhbWVfbWJzX29ubHlfZmxhZyA9IGdiLnJlYWRCaXRzKDEpO1xuICAgICAgICBpZiAoZnJhbWVfbWJzX29ubHlfZmxhZyA9PT0gMCkge1xuICAgICAgICAgICAgZ2IucmVhZEJpdHMoMSk7IC8vIG1iX2FkYXB0aXZlX2ZyYW1lX2ZpZWxkX2ZsYWdcbiAgICAgICAgfVxuICAgICAgICBnYi5yZWFkQml0cygxKTsgLy8gZGlyZWN0Xzh4OF9pbmZlcmVuY2VfZmxhZ1xuXG4gICAgICAgIGxldCBmcmFtZV9jcm9wX2xlZnRfb2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGZyYW1lX2Nyb3BfcmlnaHRfb2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGZyYW1lX2Nyb3BfdG9wX29mZnNldCA9IDA7XG4gICAgICAgIGxldCBmcmFtZV9jcm9wX2JvdHRvbV9vZmZzZXQgPSAwO1xuXG4gICAgICAgIGNvbnN0IGZyYW1lX2Nyb3BwaW5nX2ZsYWcgPSBnYi5yZWFkQm9vbCgpO1xuICAgICAgICBpZiAoZnJhbWVfY3JvcHBpbmdfZmxhZykge1xuICAgICAgICAgICAgZnJhbWVfY3JvcF9sZWZ0X29mZnNldCA9IGdiLnJlYWRVRUcoKTtcbiAgICAgICAgICAgIGZyYW1lX2Nyb3BfcmlnaHRfb2Zmc2V0ID0gZ2IucmVhZFVFRygpO1xuICAgICAgICAgICAgZnJhbWVfY3JvcF90b3Bfb2Zmc2V0ID0gZ2IucmVhZFVFRygpO1xuICAgICAgICAgICAgZnJhbWVfY3JvcF9ib3R0b21fb2Zmc2V0ID0gZ2IucmVhZFVFRygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNhcl93aWR0aCA9IDEsXG4gICAgICAgICAgICBzYXJfaGVpZ2h0ID0gMTtcbiAgICAgICAgbGV0IGZwcyA9IDAsXG4gICAgICAgICAgICBmcHNfZml4ZWQgPSB0cnVlLFxuICAgICAgICAgICAgZnBzX251bSA9IDAsXG4gICAgICAgICAgICBmcHNfZGVuID0gMDtcblxuICAgICAgICBjb25zdCB2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcgPSBnYi5yZWFkQm9vbCgpO1xuICAgICAgICBpZiAodnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnKSB7XG4gICAgICAgICAgICBpZiAoZ2IucmVhZEJvb2woKSkgeyAvLyBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWdcbiAgICAgICAgICAgICAgICBjb25zdCBhc3BlY3RfcmF0aW9faWRjID0gZ2IucmVhZEJ5dGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzYXJfd190YWJsZSA9IFsxLCAxMiwgMTAsIDE2LCA0MCwgMjQsIDIwLCAzMiwgODAsIDE4LCAxNSwgNjQsIDE2MCwgNCwgMywgMl07XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FyX2hfdGFibGUgPSBbMSwgMTEsIDExLCAxMSwgMzMsIDExLCAxMSwgMTEsIDMzLCAxMSwgMTEsIDMzLCA5OSwgMywgMiwgMV07XG5cbiAgICAgICAgICAgICAgICBpZiAoYXNwZWN0X3JhdGlvX2lkYyA+IDAgJiYgYXNwZWN0X3JhdGlvX2lkYyA8IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgIHNhcl93aWR0aCA9IHNhcl93X3RhYmxlW2FzcGVjdF9yYXRpb19pZGMgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgc2FyX2hlaWdodCA9IHNhcl9oX3RhYmxlW2FzcGVjdF9yYXRpb19pZGMgLSAxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFzcGVjdF9yYXRpb19pZGMgPT09IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICBzYXJfd2lkdGggPSBnYi5yZWFkQnl0ZSgpIDw8IDggfCBnYi5yZWFkQnl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBzYXJfaGVpZ2h0ID0gZ2IucmVhZEJ5dGUoKSA8PCA4IHwgZ2IucmVhZEJ5dGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnYi5yZWFkQm9vbCgpKSB7IC8vIG92ZXJzY2FuX2luZm9fcHJlc2VudF9mbGFnXG4gICAgICAgICAgICAgICAgZ2IucmVhZEJvb2woKTsgLy8gb3ZlcnNjYW5fYXBwcm9wcmlhdGVfZmxhZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdiLnJlYWRCb29sKCkpIHsgLy8gdmlkZW9fc2lnbmFsX3R5cGVfcHJlc2VudF9mbGFnXG4gICAgICAgICAgICAgICAgZ2IucmVhZEJpdHMoNCk7IC8vIHZpZGVvX2Zvcm1hdCAmIHZpZGVvX2Z1bGxfcmFuZ2VfZmxhZ1xuICAgICAgICAgICAgICAgIGlmIChnYi5yZWFkQm9vbCgpKSB7IC8vIGNvbG91cl9kZXNjcmlwdGlvbl9wcmVzZW50X2ZsYWdcbiAgICAgICAgICAgICAgICAgICAgZ2IucmVhZEJpdHMoMjQpOyAvLyBjb2xvdXJfcHJpbWFyaWVzICYgdHJhbnNmZXJfY2hhcmFjdGVyaXN0aWNzICYgbWF0cml4X2NvZWZmaWNpZW50c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnYi5yZWFkQm9vbCgpKSB7IC8vIGNocm9tYV9sb2NfaW5mb19wcmVzZW50X2ZsYWdcbiAgICAgICAgICAgICAgICBnYi5yZWFkVUVHKCk7IC8vIGNocm9tYV9zYW1wbGVfbG9jX3R5cGVfdG9wX2ZpZWxkXG4gICAgICAgICAgICAgICAgZ2IucmVhZFVFRygpOyAvLyBjaHJvbWFfc2FtcGxlX2xvY190eXBlX2JvdHRvbV9maWVsZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdiLnJlYWRCb29sKCkpIHsgLy8gdGltaW5nX2luZm9fcHJlc2VudF9mbGFnXG4gICAgICAgICAgICAgICAgY29uc3QgbnVtX3VuaXRzX2luX3RpY2sgPSBnYi5yZWFkQml0cygzMik7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZV9zY2FsZSA9IGdiLnJlYWRCaXRzKDMyKTtcbiAgICAgICAgICAgICAgICBmcHNfZml4ZWQgPSBnYi5yZWFkQm9vbCgpOyAvLyBmaXhlZF9mcmFtZV9yYXRlX2ZsYWdcblxuICAgICAgICAgICAgICAgIGZwc19udW0gPSB0aW1lX3NjYWxlO1xuICAgICAgICAgICAgICAgIGZwc19kZW4gPSBudW1fdW5pdHNfaW5fdGljayAqIDI7XG4gICAgICAgICAgICAgICAgZnBzID0gZnBzX251bSAvIGZwc19kZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2FyU2NhbGUgPSAxO1xuICAgICAgICBpZiAoc2FyX3dpZHRoICE9PSAxIHx8IHNhcl9oZWlnaHQgIT09IDEpIHtcbiAgICAgICAgICAgIHNhclNjYWxlID0gc2FyX3dpZHRoIC8gc2FyX2hlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjcm9wX3VuaXRfeCA9IDAsXG4gICAgICAgICAgICBjcm9wX3VuaXRfeSA9IDA7XG4gICAgICAgIGlmIChjaHJvbWFfZm9ybWF0X2lkYyA9PT0gMCkge1xuICAgICAgICAgICAgY3JvcF91bml0X3ggPSAxO1xuICAgICAgICAgICAgY3JvcF91bml0X3kgPSAyIC0gZnJhbWVfbWJzX29ubHlfZmxhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Yl93YyA9IChjaHJvbWFfZm9ybWF0X2lkYyA9PT0gMykgPyAxIDogMjtcbiAgICAgICAgICAgIGNvbnN0IHN1Yl9oYyA9IChjaHJvbWFfZm9ybWF0X2lkYyA9PT0gMSkgPyAyIDogMTtcbiAgICAgICAgICAgIGNyb3BfdW5pdF94ID0gc3ViX3djO1xuICAgICAgICAgICAgY3JvcF91bml0X3kgPSBzdWJfaGMgKiAoMiAtIGZyYW1lX21ic19vbmx5X2ZsYWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGVjX3dpZHRoID0gKHBpY193aWR0aF9pbl9tYnNfbWludXMxICsgMSkgKiAxNjtcbiAgICAgICAgbGV0IGNvZGVjX2hlaWdodCA9ICgyIC0gZnJhbWVfbWJzX29ubHlfZmxhZykgKiAoKHBpY19oZWlnaHRfaW5fbWFwX3VuaXRzX21pbnVzMSArIDEpICogMTYpO1xuXG4gICAgICAgIGNvZGVjX3dpZHRoIC09IChmcmFtZV9jcm9wX2xlZnRfb2Zmc2V0ICsgZnJhbWVfY3JvcF9yaWdodF9vZmZzZXQpICogY3JvcF91bml0X3g7XG4gICAgICAgIGNvZGVjX2hlaWdodCAtPSAoZnJhbWVfY3JvcF90b3Bfb2Zmc2V0ICsgZnJhbWVfY3JvcF9ib3R0b21fb2Zmc2V0KSAqIGNyb3BfdW5pdF95O1xuXG4gICAgICAgIGNvbnN0IHByZXNlbnRfd2lkdGggPSBNYXRoLmNlaWwoY29kZWNfd2lkdGggKiBzYXJTY2FsZSk7XG5cbiAgICAgICAgZ2IuZGVzdHJveSgpO1xuICAgICAgICBnYiA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb2ZpbGVfc3RyaW5nLCAvLyBiYXNlbGluZSwgaGlnaCwgaGlnaDEwLCAuLi5cbiAgICAgICAgICAgIGxldmVsX3N0cmluZywgLy8gMywgMy4xLCA0LCA0LjEsIDUsIDUuMSwgLi4uXG4gICAgICAgICAgICBiaXRfZGVwdGgsIC8vIDhiaXQsIDEwYml0LCAuLi5cbiAgICAgICAgICAgIGNocm9tYV9mb3JtYXQsIC8vIDQ6MjowLCA0OjI6MiwgLi4uXG4gICAgICAgICAgICBjaHJvbWFfZm9ybWF0X3N0cmluZzogU1BTUGFyc2VyLmdldENocm9tYUZvcm1hdFN0cmluZyhjaHJvbWFfZm9ybWF0KSxcblxuICAgICAgICAgICAgZnJhbWVfcmF0ZToge1xuICAgICAgICAgICAgICAgIGZpeGVkOiBmcHNfZml4ZWQsXG4gICAgICAgICAgICAgICAgZnBzLFxuICAgICAgICAgICAgICAgIGZwc19kZW4sXG4gICAgICAgICAgICAgICAgZnBzX251bVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2FyX3JhdGlvOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHNhcl93aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNhcl9oZWlnaHRcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNvZGVjX3NpemU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogY29kZWNfd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBjb2RlY19oZWlnaHRcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHByZXNlbnRfc2l6ZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBwcmVzZW50X3dpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogY29kZWNfaGVpZ2h0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc3RhdGljIF9za2lwU2NhbGluZ0xpc3QoZ2IsIGNvdW50KSB7XG4gICAgICAgIGxldCBsYXN0X3NjYWxlID0gOCxcbiAgICAgICAgICAgIG5leHRfc2NhbGUgPSA4O1xuICAgICAgICBsZXQgZGVsdGFfc2NhbGUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZXh0X3NjYWxlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsdGFfc2NhbGUgPSBnYi5yZWFkU0VHKCk7XG4gICAgICAgICAgICAgICAgbmV4dF9zY2FsZSA9IChsYXN0X3NjYWxlICsgZGVsdGFfc2NhbGUgKyAyNTYpICUgMjU2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdF9zY2FsZSA9IChuZXh0X3NjYWxlID09PSAwKSA/IGxhc3Rfc2NhbGUgOiBuZXh0X3NjYWxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFByb2ZpbGVTdHJpbmcocHJvZmlsZV9pZGMpIHtcbiAgICAgICAgc3dpdGNoIChwcm9maWxlX2lkYykge1xuICAgICAgICAgICAgY2FzZSA2NjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0Jhc2VsaW5lJztcbiAgICAgICAgICAgIGNhc2UgNzc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdNYWluJztcbiAgICAgICAgICAgIGNhc2UgODg6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdFeHRlbmRlZCc7XG4gICAgICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0hpZ2gnO1xuICAgICAgICAgICAgY2FzZSAxMTA6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdIaWdoMTAnO1xuICAgICAgICAgICAgY2FzZSAxMjI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdIaWdoNDIyJztcbiAgICAgICAgICAgIGNhc2UgMjQ0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnSGlnaDQ0NCc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0TGV2ZWxTdHJpbmcobGV2ZWxfaWRjKSB7XG4gICAgICAgIHJldHVybiAobGV2ZWxfaWRjIC8gMTApLnRvRml4ZWQoMSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldENocm9tYUZvcm1hdFN0cmluZyhjaHJvbWEpIHtcbiAgICAgICAgc3dpdGNoIChjaHJvbWEpIHtcbiAgICAgICAgICAgIGNhc2UgNDIwOlxuICAgICAgICAgICAgICAgIHJldHVybiAnNDoyOjAnO1xuICAgICAgICAgICAgY2FzZSA0MjI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICc0OjI6Mic7XG4gICAgICAgICAgICBjYXNlIDQ0NDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJzQ6NDo0JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTUFNQYXJzZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvZmx2L3Nwcy1wYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flvdemux__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__media_info__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__sps_parser__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_error__ = __webpack_require__(0);\n/* eslint-disable */\n\n\n\n\nclass tagDemux {\n    constructor() {\n        this.TAG = this.constructor.name;\n\n        this._config = {};\n\n        this._onError = null;\n        this._onMediaInfo = null;\n        this._onTrackMetadata = null;\n        this._onDataAvailable = null;\n\n        this._dataOffset = 0;\n        this._firstParse = true;\n        this._dispatch = false;\n\n        this._hasAudio = false;\n        this._hasVideo = false;\n\n        this._audioInitialMetadataDispatched = false;\n        this._videoInitialMetadataDispatched = false;\n\n        this._mediaInfo = new __WEBPACK_IMPORTED_MODULE_1__media_info__[\"a\" /* default */]();\n        this._mediaInfo.hasAudio = this._hasAudio;\n        this._mediaInfo.hasVideo = this._hasVideo;\n        this._metadata = null;\n        this._audioMetadata = null;\n        this._videoMetadata = null;\n\n        this._naluLengthSize = 4;\n        this._timestampBase = 0; // int32, in milliseconds\n        this._timescale = 1000;\n        this._duration = 0; // int32, in milliseconds\n        this._durationOverrided = false;\n        this._referenceFrameRate = {\n            fixed: true,\n            fps: 23.976,\n            fps_num: 23976,\n            fps_den: 1000\n        };\n\n        this._videoTrack = { type: 'video', id: 1, sequenceNumber: 0, addcoefficient: 2, samples: [], length: 0 };\n        this._audioTrack = { type: 'audio', id: 2, sequenceNumber: 1, addcoefficient: 2, samples: [], length: 0 };\n\n        this._littleEndian = (function() {\n            const buf = new ArrayBuffer(2);\n            (new DataView(buf)).setInt16(0, 256, true); // little-endian write\n            return (new Int16Array(buf))[0] === 256; // platform-spec read, if equal then LE\n        })();\n    }\n    onMediaInfo(callback) {\n        this._onMediaInfo = callback;\n    }\n    parseMetadata(arr) {\n        const data = __WEBPACK_IMPORTED_MODULE_0__flvdemux__[\"a\" /* default */].parseMetadata(arr);\n        this._parseScriptData(data);\n    }\n    _parseScriptData(obj) {\n        const scriptData = obj;\n\n        if (scriptData.hasOwnProperty('onMetaData')) {\n            if (this._metadata) {\n                console.log(this.TAG, 'Found another onMetaData tag!');\n            }\n            this._metadata = scriptData;\n            const onMetaData = this._metadata.onMetaData;\n\n            if (typeof onMetaData.hasAudio === 'boolean') { // hasAudio\n                this._hasAudio = onMetaData.hasAudio;\n                this._mediaInfo.hasAudio = this._hasAudio;\n            }\n            if (typeof onMetaData.hasVideo === 'boolean') { // hasVideo\n                this._hasVideo = onMetaData.hasVideo;\n                this._mediaInfo.hasVideo = this._hasVideo;\n            }\n            if (typeof onMetaData.audiodatarate === 'number') { // audiodatarate\n                this._mediaInfo.audioDataRate = onMetaData.audiodatarate;\n            }\n            if (typeof onMetaData.videodatarate === 'number') { // videodatarate\n                this._mediaInfo.videoDataRate = onMetaData.videodatarate;\n            }\n            if (typeof onMetaData.width === 'number') { // width\n                this._mediaInfo.width = onMetaData.width;\n            }\n            if (typeof onMetaData.height === 'number') { // height\n                this._mediaInfo.height = onMetaData.height;\n            }\n            if (typeof onMetaData.duration === 'number') { // duration\n                if (!this._durationOverrided) {\n                    const duration = Math.floor(onMetaData.duration * this._timescale);\n                    this._duration = duration;\n                    this._mediaInfo.duration = duration;\n                }\n            } else {\n                this._mediaInfo.duration = 0;\n            }\n            if (typeof onMetaData.framerate === 'number') { // framerate\n                const fps_num = Math.floor(onMetaData.framerate * 1000);\n                if (fps_num > 0) {\n                    const fps = fps_num / 1000;\n                    this._referenceFrameRate.fixed = true;\n                    this._referenceFrameRate.fps = fps;\n                    this._referenceFrameRate.fps_num = fps_num;\n                    this._referenceFrameRate.fps_den = 1000;\n                    this._mediaInfo.fps = fps;\n                }\n            }\n            if (typeof onMetaData.keyframes === 'object') { // keyframes\n                this._mediaInfo.hasKeyframesIndex = true;\n                const keyframes = onMetaData.keyframes;\n                keyframes.times = onMetaData.times;\n                keyframes.filepositions = onMetaData.filepositions;\n                this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(keyframes);\n                onMetaData.keyframes = null; // keyframes has been extracted, remove it\n            } else {\n                this._mediaInfo.hasKeyframesIndex = false;\n            }\n            this._dispatch = false;\n            this._mediaInfo.metadata = onMetaData;\n            console.log(this.TAG, 'Parsed onMetaData');\n            // if (this._mediaInfo.isComplete()) {\n            // this._onMediaInfo(this._mediaInfo);\n            // }\n            return this._mediaInfo;\n        }\n    }\n\n    _parseKeyframesIndex(keyframes) {\n        const times = [];\n        const filepositions = [];\n\n        // ignore first keyframe which is actually AVC Sequence Header (AVCDecoderConfigurationRecord)\n        for (let i = 1; i < keyframes.times.length; i++) {\n            const time = this._timestampBase + Math.floor(keyframes.times[i] * 1000);\n            times.push(time);\n            filepositions.push(keyframes.filepositions[i]);\n        }\n\n        return {\n            times,\n            filepositions\n        };\n    }\n\n    /**\n     * 传入tags输出moof和mdat\n     *\n     * @param {any} tags\n     *\n     * @memberof tagDemux\n     */\n    moofTag(tags) {\n\n        for (let i = 0; i < tags.length; i++) {\n            this._dispatch = true;\n            this.parseChunks(tags[i]);\n            // console.log(\"tagTimestamp\", tags[i].getTime(), tags[i]);\n        }\n        if (this._isInitialMetadataDispatched()) {\n            if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n                this._onDataAvailable(this._audioTrack, this._videoTrack);\n            }\n        }\n    }\n\n    parseChunks(flvtag) {\n\n        switch (flvtag.tagType) {\n            case 8: // Audio\n                this._parseAudioData(flvtag.body.buffer, 0, flvtag.body.length, flvtag.getTime());\n                break;\n            case 9: // Video\n                this._parseVideoData(flvtag.body.buffer, 0, flvtag.body.length, flvtag.getTime(), 0);\n                break;\n            case 18: // ScriptDataObject\n                this.parseMetadata(flvtag.body);\n                break;\n        }\n    }\n\n    _parseVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition) {\n        if (tagTimestamp == this._timestampBase && this._timestampBase != 0) {\n            throw new __WEBPACK_IMPORTED_MODULE_3__utils_error__[\"a\" /* default */](tagTimestamp+ this._timestampBase+'夭寿啦这个视频不是从0开始');\n            // this.timestampBase(0);\n        }\n        if (dataSize <= 1) {\n            console.log(this.TAG, 'Flv: Invalid video packet, missing VideoData payload!');\n            return;\n        }\n        // 获取 video tag body 第一字节\n        const spec = (new Uint8Array(arrayBuffer, dataOffset, dataSize))[0];\n        // 获取是否是关键帧\n        const frameType = (spec & 240) >>> 4;\n        // 获取编码格式\n        const codecId = spec & 15;\n\n        if (codecId !== 7) {\n            throw new __WEBPACK_IMPORTED_MODULE_3__utils_error__[\"a\" /* default */](`Flv: Unsupported codec in video frame: ${codecId}`);\n            // return;\n        }\n\n        this._parseAVCVideoPacket(arrayBuffer, dataOffset + 1, dataSize - 1, tagTimestamp, tagPosition, frameType);\n    }\n\n    _parseAVCVideoPacket(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType) {\n\n        if (dataSize < 4) {\n            console.log(this.TAG, 'Flv: Invalid AVC packet, missing AVCPacketType or/and CompositionTime');\n            return;\n        }\n\n        const le = this._littleEndian;\n        // 获取 video tag body 第2字节到结尾\n        const v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        // IF CodecID == 7  AVCPacketType\n        // 0 = AVC sequence header\n        // 1 = AVC NALU\n        // 2 = AVC end of sequence (lower level NALU sequence ender is not required or supported)\n        const packetType = v.getUint8(0);\n        // 3字节\n        // IF AVCPacketType == 1\n        //  Composition time offset\n        // ELSE\n        //  0\n        const cts = v.getUint32(0, !le) & 0x00FFFFFF;\n\n        // IF AVCPacketType == 0 AVCDecoderConfigurationRecord（AVC sequence header）\n        // IF AVCPacketType == 1 One or more NALUs (Full frames are required)\n\n        /**\n         *AVCDecoderConfigurationRecord.包含着是H.264解码相关比较重要的sps和pps信息，\n         *再给AVC解码器送数据 流之前一定要把sps和pps信息送出，否则的话解码器不能正常解码。\n         *而且在解码器stop之后再次start之前，如seek、快进快退状态切换等，\n         *都 需要重新送一遍sps和pps的信息.AVCDecoderConfigurationRecord在FLV文件中一般情况也是出现1次，\n         *也就是第一个 video tag.\n         */\n        if (packetType === 0) { // AVCDecoderConfigurationRecord\n            this._parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset + 4, dataSize - 4);\n        } else if (packetType === 1) { // One or more Nalus\n            this._parseAVCVideoData(arrayBuffer, dataOffset + 4, dataSize - 4, tagTimestamp, tagPosition, frameType, cts);\n        } else if (packetType === 2) {\n            // empty, AVC end of sequence\n        } else {\n            throw new __WEBPACK_IMPORTED_MODULE_3__utils_error__[\"a\" /* default */](`Flv: Invalid video packet type ${packetType}`);\n            \n        }\n    }\n\n    /**\n     * AVC 初始化\n     */\n    _parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize < 7) {\n            console.log(this.TAG, 'Flv: Invalid AVCDecoderConfigurationRecord, lack of data!');\n            return;\n        }\n\n        let meta = this._videoMetadata;\n        const track = this._videoTrack;\n        const le = this._littleEndian;\n        const v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        if (!meta) {\n            meta = this._videoMetadata = {};\n            meta.type = 'video';\n            meta.id = track.id;\n            meta.timescale = this._timescale;\n            meta.duration = this._duration;\n        } else {\n            if (typeof meta.avcc !== 'undefined') {\n                console.log(this.TAG, 'Found another AVCDecoderConfigurationRecord!');\n            }\n        }\n\n        const version = v.getUint8(0); // configurationVersion\n        const avcProfile = v.getUint8(1); // avcProfileIndication\n        const profileCompatibility = v.getUint8(2); // profile_compatibility\n        const avcLevel = v.getUint8(3); // AVCLevelIndication\n\n        if (version !== 1 || avcProfile === 0) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord');\n            return;\n        }\n\n        this._naluLengthSize = (v.getUint8(4) & 3) + 1; // lengthSizeMinusOne\n        if (this._naluLengthSize !== 3 && this._naluLengthSize !== 4) { // holy shit!!!\n            this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Strange NaluLengthSizeMinusOne: ${this._naluLengthSize - 1}`);\n            return;\n        }\n\n        const spsCount = v.getUint8(5) & 31; // numOfSequenceParameterSets\n        if (spsCount === 0 || spsCount > 1) {\n            this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Invalid H264 SPS count: ${spsCount}`);\n            return;\n        }\n\n        let offset = 6;\n\n        for (let i = 0; i < spsCount; i++) {\n            const len = v.getUint16(offset, !le); // sequenceParameterSetLength\n            offset += 2;\n\n            if (len === 0) {\n                continue;\n            }\n\n            // Notice: Nalu without startcode header (00 00 00 01)\n            const sps = new Uint8Array(arrayBuffer, dataOffset + offset, len);\n            offset += len;\n\n            const config = __WEBPACK_IMPORTED_MODULE_2__sps_parser__[\"a\" /* default */].parseSPS(sps);\n            meta.codecWidth = config.codec_size.width;\n            meta.codecHeight = config.codec_size.height;\n            meta.presentWidth = config.present_size.width;\n            meta.presentHeight = config.present_size.height;\n\n            meta.profile = config.profile_string;\n            meta.level = config.level_string;\n            meta.bitDepth = config.bit_depth;\n            meta.chromaFormat = config.chroma_format;\n            meta.sarRatio = config.sar_ratio;\n            meta.frameRate = config.frame_rate;\n\n            if (config.frame_rate.fixed === false ||\n                config.frame_rate.fps_num === 0 ||\n                config.frame_rate.fps_den === 0) {\n                meta.frameRate = this._referenceFrameRate;\n            }\n\n            const fps_den = meta.frameRate.fps_den;\n            const fps_num = meta.frameRate.fps_num;\n            meta.refSampleDuration = Math.floor(meta.timescale * (fps_den / fps_num));\n\n            const codecArray = sps.subarray(1, 4);\n            let codecString = 'avc1.';\n            for (let j = 0; j < 3; j++) {\n                let h = codecArray[j].toString(16);\n                if (h.length < 2) {\n                    h = '0' + h;\n                }\n                codecString += h;\n            }\n            meta.codec = codecString;\n\n            const mi = this._mediaInfo;\n            mi.width = meta.codecWidth;\n            mi.height = meta.codecHeight;\n            mi.fps = meta.frameRate.fps;\n            mi.profile = meta.profile;\n            mi.level = meta.level;\n            mi.chromaFormat = config.chroma_format_string;\n            mi.sarNum = meta.sarRatio.width;\n            mi.sarDen = meta.sarRatio.height;\n            mi.videoCodec = codecString;\n\n            if (mi.hasAudio) {\n                if (mi.audioCodec != null) {\n                    mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n                }\n            } else {\n                mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + '\"';\n            }\n            if (mi.isComplete()) {\n                this._onMediaInfo(mi);\n            }\n        }\n\n        const ppsCount = v.getUint8(offset); // numOfPictureParameterSets\n        if (ppsCount === 0 || ppsCount > 1) {\n            this._onError(DemuxErrors.FORMAT_ERROR, `Flv: Invalid H264 PPS count: ${ppsCount}`);\n            return;\n        }\n\n        offset++;\n\n        for (let i = 0; i < ppsCount; i++) {\n            const len = v.getUint16(offset, !le); // pictureParameterSetLength\n            offset += 2;\n\n            if (len === 0) {\n                continue;\n            }\n\n            // pps is useless for extracting video information\n            offset += len;\n        }\n\n        meta.avcc = new Uint8Array(dataSize);\n        meta.avcc.set(new Uint8Array(arrayBuffer, dataOffset, dataSize), 0);\n        console.log(this.TAG, 'Parsed AVCDecoderConfigurationRecord');\n\n        if (this._isInitialMetadataDispatched()) {\n            // flush parsed frames\n            if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n                this._onDataAvailable(this._audioTrack, this._videoTrack);\n            }\n        } else {\n            this._videoInitialMetadataDispatched = true;\n        }\n        // notify new metadata\n        this._dispatch = false;\n        // if (this._onTrackMetadata) {\n        //     this._onTrackMetadata.call(null, meta);\n        // }\n\n        this._onTrackMetadata('video', meta);\n    }\n\n    timestampBase(i) {\n        this._timestampBase = i;\n    }\n\n    /**\n     * 普通的AVC 片段\n     */\n    _parseAVCVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType, cts) {\n\n        const le = this._littleEndian;\n        const v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        let units = [],\n            length = 0;\n\n        let offset = 0;\n        const lengthSize = this._naluLengthSize;\n        const dts = this._timestampBase + tagTimestamp;\n        let keyframe = (frameType === 1); // from FLV Frame Type constants\n\n        while (offset < dataSize) {\n            if (offset + 4 >= dataSize) {\n                console.log(this.TAG, `Malformed Nalu near timestamp ${dts}, offset = ${offset}, dataSize = ${dataSize}`);\n                break; // data not enough for next Nalu\n            }\n            // Nalu with length-header (AVC1)\n            let naluSize = v.getUint32(offset, !le); // Big-Endian read\n            if (lengthSize === 3) {\n                naluSize >>>= 8;\n            }\n            if (naluSize > dataSize - lengthSize) {\n                console.log(this.TAG, `Malformed Nalus near timestamp ${dts}, NaluSize > DataSize!`);\n                return;\n            }\n\n            const unitType = v.getUint8(offset + lengthSize) & 0x1F;\n\n            if (unitType === 5) { // IDR\n                keyframe = true;\n            }\n\n            const data = new Uint8Array(arrayBuffer, dataOffset + offset, lengthSize + naluSize);\n            const unit = { type: unitType, data };\n            units.push(unit);\n            length += data.byteLength;\n\n            offset += lengthSize + naluSize;\n        }\n\n        if (units.length) {\n            const track = this._videoTrack;\n            const avcSample = {\n                units,\n                length,\n                isKeyframe: keyframe,\n                dts,\n                cts,\n                pts: (dts + cts)\n            };\n            if (keyframe) {\n                avcSample.fileposition = tagPosition;\n            }\n            track.samples.push(avcSample);\n            track.length += length;\n        }\n    }\n    _parseAudioData(arrayBuffer, dataOffset, dataSize, tagTimestamp) {\n        if (tagTimestamp == this._timestampBase && this._timestampBase != 0) {\n            console.log(tagTimestamp, this._timestampBase, '夭寿啦这个视频不是从0开始');\n            // timestampBase(0);\n        }\n\n        if (dataSize <= 1) {\n            console.log(this.TAG, 'Flv: Invalid audio packet, missing SoundData payload!');\n            return;\n        }\n\n        let meta = this._audioMetadata;\n        const track = this._audioTrack;\n\n        if (!meta || !meta.codec) {\n            // initial metadata\n            meta = this._audioMetadata = {};\n            meta.type = 'audio';\n            meta.id = track.id;\n            meta.timescale = this._timescale;\n            meta.duration = this._duration;\n\n            const le = this._littleEndian;\n            const v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n            const soundSpec = v.getUint8(0);\n\n            const soundFormat = soundSpec >>> 4;\n            if (soundFormat !== 10) { // AAC\n                // TODO: support MP3 audio codec\n                this._onError(DemuxErrors.CODEC_UNSUPPORTED, 'Flv: Unsupported audio codec idx: ' + soundFormat);\n                return;\n            }\n\n            let soundRate = 0;\n            const soundRateIndex = (soundSpec & 12) >>> 2;\n\n            const soundRateTable = [5500, 11025, 22050, 44100, 48000];\n\n            if (soundRateIndex < soundRateTable.length) {\n                soundRate = soundRateTable[soundRateIndex];\n            } else {\n                this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid audio sample rate idx: ' + soundRateIndex);\n                return;\n            }\n\n            const soundSize = (soundSpec & 2) >>> 1; // unused\n            const soundType = (soundSpec & 1);\n\n            meta.audioSampleRate = soundRate;\n            meta.channelCount = (soundType === 0 ? 1 : 2);\n            meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);\n            meta.codec = 'mp4a.40.5';\n        }\n\n        const aacData = this._parseAACAudioData(arrayBuffer, dataOffset + 1, dataSize - 1);\n        if (aacData == undefined) {\n            return;\n        }\n\n        if (aacData.packetType === 0) { // AAC sequence header (AudioSpecificConfig)\n            if (meta.config) {\n                console.log(this.TAG, 'Found another AudioSpecificConfig!');\n            }\n            const misc = aacData.data;\n            meta.audioSampleRate = misc.samplingRate;\n            meta.channelCount = misc.channelCount;\n            meta.codec = misc.codec;\n            meta.config = misc.config;\n            // The decode result of an aac sample is 1024 PCM samples\n            meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);\n            console.log(this.TAG, 'Parsed AudioSpecificConfig');\n\n            if (this._isInitialMetadataDispatched()) {\n                // Non-initial metadata, force dispatch (or flush) parsed frames to remuxer\n                if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n                    this._onDataAvailable(this._audioTrack, this._videoTrack);\n                }\n            } else {\n                this._audioInitialMetadataDispatched = true;\n            }\n            // then notify new metadata\n            this._dispatch = false;\n            this._onTrackMetadata('audio', meta);\n\n            const mi = this._mediaInfo;\n            mi.audioCodec = 'mp4a.40.' + misc.originalAudioObjectType;\n            mi.audioSampleRate = meta.audioSampleRate;\n            mi.audioChannelCount = meta.channelCount;\n            if (mi.hasVideo) {\n                if (mi.videoCodec != null) {\n                    mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n                }\n            } else {\n                mi.mimeType = 'video/x-flv; codecs=\"' + mi.audioCodec + '\"';\n            }\n            if (mi.isComplete()) {\n                this._onMediaInfo(mi);\n            }\n            return;\n        } else if (aacData.packetType === 1) { // AAC raw frame data\n            const dts = this._timestampBase + tagTimestamp;\n            const aacSample = { unit: aacData.data, dts, pts: dts };\n            track.samples.push(aacSample);\n            track.length += aacData.data.length;\n        } else {\n            console.log(this.TAG, `Flv: Unsupported AAC data type ${aacData.packetType}`);\n        }\n    }\n\n    _parseAACAudioData(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize <= 1) {\n            console.log(this.TAG, 'Flv: Invalid AAC packet, missing AACPacketType or/and Data!');\n            return;\n        }\n\n        const result = {};\n        const array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n\n        result.packetType = array[0];\n\n        if (array[0] === 0) {\n            result.data = this._parseAACAudioSpecificConfig(arrayBuffer, dataOffset + 1, dataSize - 1);\n        } else {\n            result.data = array.subarray(1);\n        }\n\n        return result;\n    }\n\n    _parseAACAudioSpecificConfig(arrayBuffer, dataOffset, dataSize) {\n        const array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n        let config = null;\n\n        const mpegSamplingRates = [\n            96000, 88200, 64000, 48000, 44100, 32000,\n            24000, 22050, 16000, 12000, 11025, 8000, 7350\n        ];\n\n        /* Audio Object Type:\n           0: Null\n           1: AAC Main\n           2: AAC LC\n           3: AAC SSR (Scalable Sample Rate)\n           4: AAC LTP (Long Term Prediction)\n           5: HE-AAC / SBR (Spectral Band Replication)\n           6: AAC Scalable\n        */\n\n        let audioObjectType = 0;\n        let originalAudioObjectType = 0;\n        let audioExtensionObjectType = null;\n        let samplingIndex = 0;\n        let extensionSamplingIndex = null;\n        // debugger;\n        // 5 bits\n        audioObjectType = originalAudioObjectType = array[0] >>> 3;\n        // 4 bits\n        samplingIndex = ((array[0] & 0x07) << 1) | (array[1] >>> 7);\n        if (samplingIndex < 0 || samplingIndex >= mpegSamplingRates.length) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid sampling frequency index!');\n            return;\n        }\n\n        const samplingFrequence = mpegSamplingRates[samplingIndex];\n\n        // 4 bits\n        const channelConfig = (array[1] & 0x78) >>> 3;\n        if (channelConfig < 0 || channelConfig >= 8) {\n            this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid channel configuration');\n            return;\n        }\n\n        if (audioObjectType === 5) { // HE-AAC?\n            // 4 bits\n            extensionSamplingIndex = ((array[1] & 0x07) << 1) | (array[2] >>> 7);\n            // 5 bits\n            audioExtensionObjectType = (array[2] & 0x7C) >>> 2;\n        }\n\n        // workarounds for various browsers\n        const userAgent = self.navigator.userAgent.toLowerCase();\n\n        if (userAgent.indexOf('firefox') !== -1) {\n            // firefox: use SBR (HE-AAC) if freq less than 24kHz\n            if (samplingIndex >= 6) {\n                audioObjectType = 5;\n                config = new Array(4);\n                extensionSamplingIndex = samplingIndex - 3;\n            } else { // use LC-AAC\n                audioObjectType = 2;\n                config = new Array(2);\n                extensionSamplingIndex = samplingIndex;\n            }\n        } else if (userAgent.indexOf('android') !== -1) {\n            // android: always use LC-AAC\n            audioObjectType = 2;\n            config = new Array(2);\n            extensionSamplingIndex = samplingIndex;\n        } else {\n            // for other browsers, e.g. chrome...\n            // Always use HE-AAC to make it easier to switch aac codec profile\n            audioObjectType = 5;\n            extensionSamplingIndex = samplingIndex;\n            config = new Array(4);\n\n            if (samplingIndex >= 6) {\n                extensionSamplingIndex = samplingIndex - 3;\n            } else if (channelConfig === 1) { // Mono channel\n                audioObjectType = 2;\n                config = new Array(2);\n                extensionSamplingIndex = samplingIndex;\n            }\n        }\n\n        config[0] = audioObjectType << 3;\n        config[0] |= (samplingIndex & 0x0F) >>> 1;\n        config[1] = (samplingIndex & 0x0F) << 7;\n        config[1] |= (channelConfig & 0x0F) << 3;\n        if (audioObjectType === 5) {\n            config[1] |= ((extensionSamplingIndex & 0x0F) >>> 1);\n            config[2] = (extensionSamplingIndex & 0x01) << 7;\n            // extended audio object type: force to 2 (LC-AAC)\n            config[2] |= (2 << 2);\n            config[3] = 0;\n        }\n\n        return {\n            config,\n            samplingRate: samplingFrequence,\n            channelCount: channelConfig,\n            codec: 'mp4a.40.' + audioObjectType,\n            originalAudioObjectType\n        };\n    }\n    _isInitialMetadataDispatched() {\n        if (this._hasAudio && this._hasVideo) { // both audio & video\n            return this._audioInitialMetadataDispatched && this._videoInitialMetadataDispatched;\n        }\n        if (this._hasAudio && !this._hasVideo) { // audio only\n            return this._audioInitialMetadataDispatched;\n        }\n        if (!this._hasAudio && this._hasVideo) { // video only\n            return this._videoInitialMetadataDispatched;\n        }\n    }\n}\n/* harmony default export */ __webpack_exports__[\"a\"] = (new tagDemux());//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvZmx2L3RhZ2RlbXV4LmpzPzVlNGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsb0RBQW9EO0FBQ3BELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhIQUFzRSxRQUFRO0FBQzlFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsU0FBUyw2QkFBNkI7QUFDdEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Qsc0hBQThELFdBQVc7O0FBRXpFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDLHlDQUF5QztBQUN6QyxtREFBbUQ7QUFDbkQsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQsdUVBQXVFO0FBQ3ZFLDRGQUE0Rix5QkFBeUI7QUFDckg7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQSxvRkFBb0YsU0FBUztBQUM3RjtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixjQUFjO0FBQ3JDLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsYUFBYTtBQUNiLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBLG9GQUFvRixTQUFTO0FBQzdGO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLGNBQWM7QUFDckMsaURBQWlEO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBLHVFQUF1RSxJQUFJLGFBQWEsT0FBTyxlQUFlLFNBQVM7QUFDdkgsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsSUFBSTtBQUM1RTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsYUFBYTtBQUNiLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxQ0FBcUM7QUFDOUM7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLFNBQVM7QUFDVCxvRUFBb0UsbUJBQW1CO0FBQ3ZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBmbHZEZW11eCBmcm9tICcuL2ZsdmRlbXV4JztcbmltcG9ydCBtZWRpYWluZm8gZnJvbSAnLi9tZWRpYS1pbmZvJztcbmltcG9ydCBTUFNQYXJzZXIgZnJvbSAnLi9zcHMtcGFyc2VyJztcbmltcG9ydCBlcnJvciBmcm9tICcuLy4uL3V0aWxzL2Vycm9yJ1xuY2xhc3MgdGFnRGVtdXgge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLlRBRyA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcblxuICAgICAgICB0aGlzLl9jb25maWcgPSB7fTtcblxuICAgICAgICB0aGlzLl9vbkVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb25NZWRpYUluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLl9vblRyYWNrTWV0YWRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLl9vbkRhdGFBdmFpbGFibGUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2RhdGFPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLl9maXJzdFBhcnNlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2ggPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9oYXNBdWRpbyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9oYXNWaWRlbyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2F1ZGlvSW5pdGlhbE1ldGFkYXRhRGlzcGF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl92aWRlb0luaXRpYWxNZXRhZGF0YURpc3BhdGNoZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9tZWRpYUluZm8gPSBuZXcgbWVkaWFpbmZvKCk7XG4gICAgICAgIHRoaXMuX21lZGlhSW5mby5oYXNBdWRpbyA9IHRoaXMuX2hhc0F1ZGlvO1xuICAgICAgICB0aGlzLl9tZWRpYUluZm8uaGFzVmlkZW8gPSB0aGlzLl9oYXNWaWRlbztcbiAgICAgICAgdGhpcy5fbWV0YWRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLl9hdWRpb01ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdmlkZW9NZXRhZGF0YSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fbmFsdUxlbmd0aFNpemUgPSA0O1xuICAgICAgICB0aGlzLl90aW1lc3RhbXBCYXNlID0gMDsgLy8gaW50MzIsIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICB0aGlzLl90aW1lc2NhbGUgPSAxMDAwO1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IDA7IC8vIGludDMyLCBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgdGhpcy5fZHVyYXRpb25PdmVycmlkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVmZXJlbmNlRnJhbWVSYXRlID0ge1xuICAgICAgICAgICAgZml4ZWQ6IHRydWUsXG4gICAgICAgICAgICBmcHM6IDIzLjk3NixcbiAgICAgICAgICAgIGZwc19udW06IDIzOTc2LFxuICAgICAgICAgICAgZnBzX2RlbjogMTAwMFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3ZpZGVvVHJhY2sgPSB7IHR5cGU6ICd2aWRlbycsIGlkOiAxLCBzZXF1ZW5jZU51bWJlcjogMCwgYWRkY29lZmZpY2llbnQ6IDIsIHNhbXBsZXM6IFtdLCBsZW5ndGg6IDAgfTtcbiAgICAgICAgdGhpcy5fYXVkaW9UcmFjayA9IHsgdHlwZTogJ2F1ZGlvJywgaWQ6IDIsIHNlcXVlbmNlTnVtYmVyOiAxLCBhZGRjb2VmZmljaWVudDogMiwgc2FtcGxlczogW10sIGxlbmd0aDogMCB9O1xuXG4gICAgICAgIHRoaXMuX2xpdHRsZUVuZGlhbiA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigyKTtcbiAgICAgICAgICAgIChuZXcgRGF0YVZpZXcoYnVmKSkuc2V0SW50MTYoMCwgMjU2LCB0cnVlKTsgLy8gbGl0dGxlLWVuZGlhbiB3cml0ZVxuICAgICAgICAgICAgcmV0dXJuIChuZXcgSW50MTZBcnJheShidWYpKVswXSA9PT0gMjU2OyAvLyBwbGF0Zm9ybS1zcGVjIHJlYWQsIGlmIGVxdWFsIHRoZW4gTEVcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgb25NZWRpYUluZm8oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb25NZWRpYUluZm8gPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcGFyc2VNZXRhZGF0YShhcnIpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGZsdkRlbXV4LnBhcnNlTWV0YWRhdGEoYXJyKTtcbiAgICAgICAgdGhpcy5fcGFyc2VTY3JpcHREYXRhKGRhdGEpO1xuICAgIH1cbiAgICBfcGFyc2VTY3JpcHREYXRhKG9iaikge1xuICAgICAgICBjb25zdCBzY3JpcHREYXRhID0gb2JqO1xuXG4gICAgICAgIGlmIChzY3JpcHREYXRhLmhhc093blByb3BlcnR5KCdvbk1ldGFEYXRhJykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuVEFHLCAnRm91bmQgYW5vdGhlciBvbk1ldGFEYXRhIHRhZyEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhID0gc2NyaXB0RGF0YTtcbiAgICAgICAgICAgIGNvbnN0IG9uTWV0YURhdGEgPSB0aGlzLl9tZXRhZGF0YS5vbk1ldGFEYXRhO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uTWV0YURhdGEuaGFzQXVkaW8gPT09ICdib29sZWFuJykgeyAvLyBoYXNBdWRpb1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc0F1ZGlvID0gb25NZXRhRGF0YS5oYXNBdWRpbztcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYUluZm8uaGFzQXVkaW8gPSB0aGlzLl9oYXNBdWRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25NZXRhRGF0YS5oYXNWaWRlbyA9PT0gJ2Jvb2xlYW4nKSB7IC8vIGhhc1ZpZGVvXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVmlkZW8gPSBvbk1ldGFEYXRhLmhhc1ZpZGVvO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhSW5mby5oYXNWaWRlbyA9IHRoaXMuX2hhc1ZpZGVvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbk1ldGFEYXRhLmF1ZGlvZGF0YXJhdGUgPT09ICdudW1iZXInKSB7IC8vIGF1ZGlvZGF0YXJhdGVcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYUluZm8uYXVkaW9EYXRhUmF0ZSA9IG9uTWV0YURhdGEuYXVkaW9kYXRhcmF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25NZXRhRGF0YS52aWRlb2RhdGFyYXRlID09PSAnbnVtYmVyJykgeyAvLyB2aWRlb2RhdGFyYXRlXG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFJbmZvLnZpZGVvRGF0YVJhdGUgPSBvbk1ldGFEYXRhLnZpZGVvZGF0YXJhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uTWV0YURhdGEud2lkdGggPT09ICdudW1iZXInKSB7IC8vIHdpZHRoXG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFJbmZvLndpZHRoID0gb25NZXRhRGF0YS53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25NZXRhRGF0YS5oZWlnaHQgPT09ICdudW1iZXInKSB7IC8vIGhlaWdodFxuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhSW5mby5oZWlnaHQgPSBvbk1ldGFEYXRhLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25NZXRhRGF0YS5kdXJhdGlvbiA9PT0gJ251bWJlcicpIHsgLy8gZHVyYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2R1cmF0aW9uT3ZlcnJpZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gTWF0aC5mbG9vcihvbk1ldGFEYXRhLmR1cmF0aW9uICogdGhpcy5fdGltZXNjYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFJbmZvLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYUluZm8uZHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbk1ldGFEYXRhLmZyYW1lcmF0ZSA9PT0gJ251bWJlcicpIHsgLy8gZnJhbWVyYXRlXG4gICAgICAgICAgICAgICAgY29uc3QgZnBzX251bSA9IE1hdGguZmxvb3Iob25NZXRhRGF0YS5mcmFtZXJhdGUgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZnBzX251bSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnBzID0gZnBzX251bSAvIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZmVyZW5jZUZyYW1lUmF0ZS5maXhlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZmVyZW5jZUZyYW1lUmF0ZS5mcHMgPSBmcHM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZmVyZW5jZUZyYW1lUmF0ZS5mcHNfbnVtID0gZnBzX251bTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVmZXJlbmNlRnJhbWVSYXRlLmZwc19kZW4gPSAxMDAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYUluZm8uZnBzID0gZnBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25NZXRhRGF0YS5rZXlmcmFtZXMgPT09ICdvYmplY3QnKSB7IC8vIGtleWZyYW1lc1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhSW5mby5oYXNLZXlmcmFtZXNJbmRleCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ZnJhbWVzID0gb25NZXRhRGF0YS5rZXlmcmFtZXM7XG4gICAgICAgICAgICAgICAga2V5ZnJhbWVzLnRpbWVzID0gb25NZXRhRGF0YS50aW1lcztcbiAgICAgICAgICAgICAgICBrZXlmcmFtZXMuZmlsZXBvc2l0aW9ucyA9IG9uTWV0YURhdGEuZmlsZXBvc2l0aW9ucztcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYUluZm8ua2V5ZnJhbWVzSW5kZXggPSB0aGlzLl9wYXJzZUtleWZyYW1lc0luZGV4KGtleWZyYW1lcyk7XG4gICAgICAgICAgICAgICAgb25NZXRhRGF0YS5rZXlmcmFtZXMgPSBudWxsOyAvLyBrZXlmcmFtZXMgaGFzIGJlZW4gZXh0cmFjdGVkLCByZW1vdmUgaXRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFJbmZvLmhhc0tleWZyYW1lc0luZGV4ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFJbmZvLm1ldGFkYXRhID0gb25NZXRhRGF0YTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuVEFHLCAnUGFyc2VkIG9uTWV0YURhdGEnKTtcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLl9tZWRpYUluZm8uaXNDb21wbGV0ZSgpKSB7XG4gICAgICAgICAgICAvLyB0aGlzLl9vbk1lZGlhSW5mbyh0aGlzLl9tZWRpYUluZm8pO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhSW5mbztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9wYXJzZUtleWZyYW1lc0luZGV4KGtleWZyYW1lcykge1xuICAgICAgICBjb25zdCB0aW1lcyA9IFtdO1xuICAgICAgICBjb25zdCBmaWxlcG9zaXRpb25zID0gW107XG5cbiAgICAgICAgLy8gaWdub3JlIGZpcnN0IGtleWZyYW1lIHdoaWNoIGlzIGFjdHVhbGx5IEFWQyBTZXF1ZW5jZSBIZWFkZXIgKEFWQ0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkKVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGtleWZyYW1lcy50aW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGltZSA9IHRoaXMuX3RpbWVzdGFtcEJhc2UgKyBNYXRoLmZsb29yKGtleWZyYW1lcy50aW1lc1tpXSAqIDEwMDApO1xuICAgICAgICAgICAgdGltZXMucHVzaCh0aW1lKTtcbiAgICAgICAgICAgIGZpbGVwb3NpdGlvbnMucHVzaChrZXlmcmFtZXMuZmlsZXBvc2l0aW9uc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGltZXMsXG4gICAgICAgICAgICBmaWxlcG9zaXRpb25zXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Lyg5YWldGFnc+i+k+WHum1vb2blkoxtZGF0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gdGFnc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIHRhZ0RlbXV4XG4gICAgICovXG4gICAgbW9vZlRhZyh0YWdzKSB7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnBhcnNlQ2h1bmtzKHRhZ3NbaV0pO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJ0YWdUaW1lc3RhbXBcIiwgdGFnc1tpXS5nZXRUaW1lKCksIHRhZ3NbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc0luaXRpYWxNZXRhZGF0YURpc3BhdGNoZWQoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc3BhdGNoICYmICh0aGlzLl9hdWRpb1RyYWNrLmxlbmd0aCB8fCB0aGlzLl92aWRlb1RyYWNrLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRhdGFBdmFpbGFibGUodGhpcy5fYXVkaW9UcmFjaywgdGhpcy5fdmlkZW9UcmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZUNodW5rcyhmbHZ0YWcpIHtcblxuICAgICAgICBzd2l0Y2ggKGZsdnRhZy50YWdUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIDg6IC8vIEF1ZGlvXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBdWRpb0RhdGEoZmx2dGFnLmJvZHkuYnVmZmVyLCAwLCBmbHZ0YWcuYm9keS5sZW5ndGgsIGZsdnRhZy5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA5OiAvLyBWaWRlb1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlVmlkZW9EYXRhKGZsdnRhZy5ib2R5LmJ1ZmZlciwgMCwgZmx2dGFnLmJvZHkubGVuZ3RoLCBmbHZ0YWcuZ2V0VGltZSgpLCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTg6IC8vIFNjcmlwdERhdGFPYmplY3RcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlTWV0YWRhdGEoZmx2dGFnLmJvZHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3BhcnNlVmlkZW9EYXRhKGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0LCBkYXRhU2l6ZSwgdGFnVGltZXN0YW1wLCB0YWdQb3NpdGlvbikge1xuICAgICAgICBpZiAodGFnVGltZXN0YW1wID09IHRoaXMuX3RpbWVzdGFtcEJhc2UgJiYgdGhpcy5fdGltZXN0YW1wQmFzZSAhPSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3IodGFnVGltZXN0YW1wKyB0aGlzLl90aW1lc3RhbXBCYXNlKyflpK3lr7/llabov5nkuKrop4bpopHkuI3mmK/ku44w5byA5aeLJyk7XG4gICAgICAgICAgICAvLyB0aGlzLnRpbWVzdGFtcEJhc2UoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFTaXplIDw9IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuVEFHLCAnRmx2OiBJbnZhbGlkIHZpZGVvIHBhY2tldCwgbWlzc2luZyBWaWRlb0RhdGEgcGF5bG9hZCEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyDojrflj5YgdmlkZW8gdGFnIGJvZHkg56ys5LiA5a2X6IqCXG4gICAgICAgIGNvbnN0IHNwZWMgPSAobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKSlbMF07XG4gICAgICAgIC8vIOiOt+WPluaYr+WQpuaYr+WFs+mUruW4p1xuICAgICAgICBjb25zdCBmcmFtZVR5cGUgPSAoc3BlYyAmIDI0MCkgPj4+IDQ7XG4gICAgICAgIC8vIOiOt+WPlue8lueggeagvOW8j1xuICAgICAgICBjb25zdCBjb2RlY0lkID0gc3BlYyAmIDE1O1xuXG4gICAgICAgIGlmIChjb2RlY0lkICE9PSA3KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3IoYEZsdjogVW5zdXBwb3J0ZWQgY29kZWMgaW4gdmlkZW8gZnJhbWU6ICR7Y29kZWNJZH1gKTtcbiAgICAgICAgICAgIC8vIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BhcnNlQVZDVmlkZW9QYWNrZXQoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQgKyAxLCBkYXRhU2l6ZSAtIDEsIHRhZ1RpbWVzdGFtcCwgdGFnUG9zaXRpb24sIGZyYW1lVHlwZSk7XG4gICAgfVxuXG4gICAgX3BhcnNlQVZDVmlkZW9QYWNrZXQoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplLCB0YWdUaW1lc3RhbXAsIHRhZ1Bvc2l0aW9uLCBmcmFtZVR5cGUpIHtcblxuICAgICAgICBpZiAoZGF0YVNpemUgPCA0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLlRBRywgJ0ZsdjogSW52YWxpZCBBVkMgcGFja2V0LCBtaXNzaW5nIEFWQ1BhY2tldFR5cGUgb3IvYW5kIENvbXBvc2l0aW9uVGltZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGUgPSB0aGlzLl9saXR0bGVFbmRpYW47XG4gICAgICAgIC8vIOiOt+WPliB2aWRlbyB0YWcgYm9keSDnrKwy5a2X6IqC5Yiw57uT5bC+XG4gICAgICAgIGNvbnN0IHYgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKTtcblxuICAgICAgICAvLyBJRiBDb2RlY0lEID09IDcgIEFWQ1BhY2tldFR5cGVcbiAgICAgICAgLy8gMCA9IEFWQyBzZXF1ZW5jZSBoZWFkZXJcbiAgICAgICAgLy8gMSA9IEFWQyBOQUxVXG4gICAgICAgIC8vIDIgPSBBVkMgZW5kIG9mIHNlcXVlbmNlIChsb3dlciBsZXZlbCBOQUxVIHNlcXVlbmNlIGVuZGVyIGlzIG5vdCByZXF1aXJlZCBvciBzdXBwb3J0ZWQpXG4gICAgICAgIGNvbnN0IHBhY2tldFR5cGUgPSB2LmdldFVpbnQ4KDApO1xuICAgICAgICAvLyAz5a2X6IqCXG4gICAgICAgIC8vIElGIEFWQ1BhY2tldFR5cGUgPT0gMVxuICAgICAgICAvLyAgQ29tcG9zaXRpb24gdGltZSBvZmZzZXRcbiAgICAgICAgLy8gRUxTRVxuICAgICAgICAvLyAgMFxuICAgICAgICBjb25zdCBjdHMgPSB2LmdldFVpbnQzMigwLCAhbGUpICYgMHgwMEZGRkZGRjtcblxuICAgICAgICAvLyBJRiBBVkNQYWNrZXRUeXBlID09IDAgQVZDRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmTvvIhBVkMgc2VxdWVuY2UgaGVhZGVy77yJXG4gICAgICAgIC8vIElGIEFWQ1BhY2tldFR5cGUgPT0gMSBPbmUgb3IgbW9yZSBOQUxVcyAoRnVsbCBmcmFtZXMgYXJlIHJlcXVpcmVkKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKkFWQ0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkLuWMheWQq+edgOaYr0guMjY06Kej56CB55u45YWz5q+U6L6D6YeN6KaB55qEc3Bz5ZKMcHBz5L+h5oGv77yMXG4gICAgICAgICAq5YaN57uZQVZD6Kej56CB5Zmo6YCB5pWw5o2uIOa1geS5i+WJjeS4gOWumuimgeaKinNwc+WSjHBwc+S/oeaBr+mAgeWHuu+8jOWQpuWImeeahOivneino+eggeWZqOS4jeiDveato+W4uOino+eggeOAglxuICAgICAgICAgKuiAjOS4lOWcqOino+eggeWZqHN0b3DkuYvlkI7lho3mrKFzdGFydOS5i+WJje+8jOWmgnNlZWvjgIHlv6vov5vlv6vpgIDnirbmgIHliIfmjaLnrYnvvIxcbiAgICAgICAgICrpg70g6ZyA6KaB6YeN5paw6YCB5LiA6YGNc3Bz5ZKMcHBz55qE5L+h5oGvLkFWQ0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3Jk5ZyoRkxW5paH5Lu25Lit5LiA6Iis5oOF5Ya15Lmf5piv5Ye6546wMeasoe+8jFxuICAgICAgICAgKuS5n+WwseaYr+esrOS4gOS4qiB2aWRlbyB0YWcuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocGFja2V0VHlwZSA9PT0gMCkgeyAvLyBBVkNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZFxuICAgICAgICAgICAgdGhpcy5fcGFyc2VBVkNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZChhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCArIDQsIGRhdGFTaXplIC0gNCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFja2V0VHlwZSA9PT0gMSkgeyAvLyBPbmUgb3IgbW9yZSBOYWx1c1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VBVkNWaWRlb0RhdGEoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQgKyA0LCBkYXRhU2l6ZSAtIDQsIHRhZ1RpbWVzdGFtcCwgdGFnUG9zaXRpb24sIGZyYW1lVHlwZSwgY3RzKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYWNrZXRUeXBlID09PSAyKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSwgQVZDIGVuZCBvZiBzZXF1ZW5jZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yKGBGbHY6IEludmFsaWQgdmlkZW8gcGFja2V0IHR5cGUgJHtwYWNrZXRUeXBlfWApO1xuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBVkMg5Yid5aeL5YyWXG4gICAgICovXG4gICAgX3BhcnNlQVZDRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmQoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKSB7XG4gICAgICAgIGlmIChkYXRhU2l6ZSA8IDcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuVEFHLCAnRmx2OiBJbnZhbGlkIEFWQ0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkLCBsYWNrIG9mIGRhdGEhJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWV0YSA9IHRoaXMuX3ZpZGVvTWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy5fdmlkZW9UcmFjaztcbiAgICAgICAgY29uc3QgbGUgPSB0aGlzLl9saXR0bGVFbmRpYW47XG4gICAgICAgIGNvbnN0IHYgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKTtcblxuICAgICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgICAgIG1ldGEgPSB0aGlzLl92aWRlb01ldGFkYXRhID0ge307XG4gICAgICAgICAgICBtZXRhLnR5cGUgPSAndmlkZW8nO1xuICAgICAgICAgICAgbWV0YS5pZCA9IHRyYWNrLmlkO1xuICAgICAgICAgICAgbWV0YS50aW1lc2NhbGUgPSB0aGlzLl90aW1lc2NhbGU7XG4gICAgICAgICAgICBtZXRhLmR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGEuYXZjYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLlRBRywgJ0ZvdW5kIGFub3RoZXIgQVZDRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmQhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdi5nZXRVaW50OCgwKTsgLy8gY29uZmlndXJhdGlvblZlcnNpb25cbiAgICAgICAgY29uc3QgYXZjUHJvZmlsZSA9IHYuZ2V0VWludDgoMSk7IC8vIGF2Y1Byb2ZpbGVJbmRpY2F0aW9uXG4gICAgICAgIGNvbnN0IHByb2ZpbGVDb21wYXRpYmlsaXR5ID0gdi5nZXRVaW50OCgyKTsgLy8gcHJvZmlsZV9jb21wYXRpYmlsaXR5XG4gICAgICAgIGNvbnN0IGF2Y0xldmVsID0gdi5nZXRVaW50OCgzKTsgLy8gQVZDTGV2ZWxJbmRpY2F0aW9uXG5cbiAgICAgICAgaWYgKHZlcnNpb24gIT09IDEgfHwgYXZjUHJvZmlsZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fb25FcnJvcihEZW11eEVycm9ycy5GT1JNQVRfRVJST1IsICdGbHY6IEludmFsaWQgQVZDRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX25hbHVMZW5ndGhTaXplID0gKHYuZ2V0VWludDgoNCkgJiAzKSArIDE7IC8vIGxlbmd0aFNpemVNaW51c09uZVxuICAgICAgICBpZiAodGhpcy5fbmFsdUxlbmd0aFNpemUgIT09IDMgJiYgdGhpcy5fbmFsdUxlbmd0aFNpemUgIT09IDQpIHsgLy8gaG9seSBzaGl0ISEhXG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKERlbXV4RXJyb3JzLkZPUk1BVF9FUlJPUiwgYEZsdjogU3RyYW5nZSBOYWx1TGVuZ3RoU2l6ZU1pbnVzT25lOiAke3RoaXMuX25hbHVMZW5ndGhTaXplIC0gMX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNwc0NvdW50ID0gdi5nZXRVaW50OCg1KSAmIDMxOyAvLyBudW1PZlNlcXVlbmNlUGFyYW1ldGVyU2V0c1xuICAgICAgICBpZiAoc3BzQ291bnQgPT09IDAgfHwgc3BzQ291bnQgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKERlbXV4RXJyb3JzLkZPUk1BVF9FUlJPUiwgYEZsdjogSW52YWxpZCBIMjY0IFNQUyBjb3VudDogJHtzcHNDb3VudH1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvZmZzZXQgPSA2O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gdi5nZXRVaW50MTYob2Zmc2V0LCAhbGUpOyAvLyBzZXF1ZW5jZVBhcmFtZXRlclNldExlbmd0aFxuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG5cbiAgICAgICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm90aWNlOiBOYWx1IHdpdGhvdXQgc3RhcnRjb2RlIGhlYWRlciAoMDAgMDAgMDAgMDEpXG4gICAgICAgICAgICBjb25zdCBzcHMgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCArIG9mZnNldCwgbGVuKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBsZW47XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IFNQU1BhcnNlci5wYXJzZVNQUyhzcHMpO1xuICAgICAgICAgICAgbWV0YS5jb2RlY1dpZHRoID0gY29uZmlnLmNvZGVjX3NpemUud2lkdGg7XG4gICAgICAgICAgICBtZXRhLmNvZGVjSGVpZ2h0ID0gY29uZmlnLmNvZGVjX3NpemUuaGVpZ2h0O1xuICAgICAgICAgICAgbWV0YS5wcmVzZW50V2lkdGggPSBjb25maWcucHJlc2VudF9zaXplLndpZHRoO1xuICAgICAgICAgICAgbWV0YS5wcmVzZW50SGVpZ2h0ID0gY29uZmlnLnByZXNlbnRfc2l6ZS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIG1ldGEucHJvZmlsZSA9IGNvbmZpZy5wcm9maWxlX3N0cmluZztcbiAgICAgICAgICAgIG1ldGEubGV2ZWwgPSBjb25maWcubGV2ZWxfc3RyaW5nO1xuICAgICAgICAgICAgbWV0YS5iaXREZXB0aCA9IGNvbmZpZy5iaXRfZGVwdGg7XG4gICAgICAgICAgICBtZXRhLmNocm9tYUZvcm1hdCA9IGNvbmZpZy5jaHJvbWFfZm9ybWF0O1xuICAgICAgICAgICAgbWV0YS5zYXJSYXRpbyA9IGNvbmZpZy5zYXJfcmF0aW87XG4gICAgICAgICAgICBtZXRhLmZyYW1lUmF0ZSA9IGNvbmZpZy5mcmFtZV9yYXRlO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLmZyYW1lX3JhdGUuZml4ZWQgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgY29uZmlnLmZyYW1lX3JhdGUuZnBzX251bSA9PT0gMCB8fFxuICAgICAgICAgICAgICAgIGNvbmZpZy5mcmFtZV9yYXRlLmZwc19kZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICBtZXRhLmZyYW1lUmF0ZSA9IHRoaXMuX3JlZmVyZW5jZUZyYW1lUmF0ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZnBzX2RlbiA9IG1ldGEuZnJhbWVSYXRlLmZwc19kZW47XG4gICAgICAgICAgICBjb25zdCBmcHNfbnVtID0gbWV0YS5mcmFtZVJhdGUuZnBzX251bTtcbiAgICAgICAgICAgIG1ldGEucmVmU2FtcGxlRHVyYXRpb24gPSBNYXRoLmZsb29yKG1ldGEudGltZXNjYWxlICogKGZwc19kZW4gLyBmcHNfbnVtKSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNvZGVjQXJyYXkgPSBzcHMuc3ViYXJyYXkoMSwgNCk7XG4gICAgICAgICAgICBsZXQgY29kZWNTdHJpbmcgPSAnYXZjMS4nO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaCA9IGNvZGVjQXJyYXlbal0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGVjU3RyaW5nICs9IGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRhLmNvZGVjID0gY29kZWNTdHJpbmc7XG5cbiAgICAgICAgICAgIGNvbnN0IG1pID0gdGhpcy5fbWVkaWFJbmZvO1xuICAgICAgICAgICAgbWkud2lkdGggPSBtZXRhLmNvZGVjV2lkdGg7XG4gICAgICAgICAgICBtaS5oZWlnaHQgPSBtZXRhLmNvZGVjSGVpZ2h0O1xuICAgICAgICAgICAgbWkuZnBzID0gbWV0YS5mcmFtZVJhdGUuZnBzO1xuICAgICAgICAgICAgbWkucHJvZmlsZSA9IG1ldGEucHJvZmlsZTtcbiAgICAgICAgICAgIG1pLmxldmVsID0gbWV0YS5sZXZlbDtcbiAgICAgICAgICAgIG1pLmNocm9tYUZvcm1hdCA9IGNvbmZpZy5jaHJvbWFfZm9ybWF0X3N0cmluZztcbiAgICAgICAgICAgIG1pLnNhck51bSA9IG1ldGEuc2FyUmF0aW8ud2lkdGg7XG4gICAgICAgICAgICBtaS5zYXJEZW4gPSBtZXRhLnNhclJhdGlvLmhlaWdodDtcbiAgICAgICAgICAgIG1pLnZpZGVvQ29kZWMgPSBjb2RlY1N0cmluZztcblxuICAgICAgICAgICAgaWYgKG1pLmhhc0F1ZGlvKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pLmF1ZGlvQ29kZWMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBtaS5taW1lVHlwZSA9ICd2aWRlby94LWZsdjsgY29kZWNzPVwiJyArIG1pLnZpZGVvQ29kZWMgKyAnLCcgKyBtaS5hdWRpb0NvZGVjICsgJ1wiJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pLm1pbWVUeXBlID0gJ3ZpZGVvL3gtZmx2OyBjb2RlY3M9XCInICsgbWkudmlkZW9Db2RlYyArICdcIic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWkuaXNDb21wbGV0ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25NZWRpYUluZm8obWkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHBzQ291bnQgPSB2LmdldFVpbnQ4KG9mZnNldCk7IC8vIG51bU9mUGljdHVyZVBhcmFtZXRlclNldHNcbiAgICAgICAgaWYgKHBwc0NvdW50ID09PSAwIHx8IHBwc0NvdW50ID4gMSkge1xuICAgICAgICAgICAgdGhpcy5fb25FcnJvcihEZW11eEVycm9ycy5GT1JNQVRfRVJST1IsIGBGbHY6IEludmFsaWQgSDI2NCBQUFMgY291bnQ6ICR7cHBzQ291bnR9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXQrKztcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBwc0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHYuZ2V0VWludDE2KG9mZnNldCwgIWxlKTsgLy8gcGljdHVyZVBhcmFtZXRlclNldExlbmd0aFxuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG5cbiAgICAgICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHBzIGlzIHVzZWxlc3MgZm9yIGV4dHJhY3RpbmcgdmlkZW8gaW5mb3JtYXRpb25cbiAgICAgICAgICAgIG9mZnNldCArPSBsZW47XG4gICAgICAgIH1cblxuICAgICAgICBtZXRhLmF2Y2MgPSBuZXcgVWludDhBcnJheShkYXRhU2l6ZSk7XG4gICAgICAgIG1ldGEuYXZjYy5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKSwgMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuVEFHLCAnUGFyc2VkIEFWQ0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzSW5pdGlhbE1ldGFkYXRhRGlzcGF0Y2hlZCgpKSB7XG4gICAgICAgICAgICAvLyBmbHVzaCBwYXJzZWQgZnJhbWVzXG4gICAgICAgICAgICBpZiAodGhpcy5fZGlzcGF0Y2ggJiYgKHRoaXMuX2F1ZGlvVHJhY2subGVuZ3RoIHx8IHRoaXMuX3ZpZGVvVHJhY2subGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRGF0YUF2YWlsYWJsZSh0aGlzLl9hdWRpb1RyYWNrLCB0aGlzLl92aWRlb1RyYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvSW5pdGlhbE1ldGFkYXRhRGlzcGF0Y2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90aWZ5IG5ldyBtZXRhZGF0YVxuICAgICAgICB0aGlzLl9kaXNwYXRjaCA9IGZhbHNlO1xuICAgICAgICAvLyBpZiAodGhpcy5fb25UcmFja01ldGFkYXRhKSB7XG4gICAgICAgIC8vICAgICB0aGlzLl9vblRyYWNrTWV0YWRhdGEuY2FsbChudWxsLCBtZXRhKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHRoaXMuX29uVHJhY2tNZXRhZGF0YSgndmlkZW8nLCBtZXRhKTtcbiAgICB9XG5cbiAgICB0aW1lc3RhbXBCYXNlKGkpIHtcbiAgICAgICAgdGhpcy5fdGltZXN0YW1wQmFzZSA9IGk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pmu6YCa55qEQVZDIOeJh+autVxuICAgICAqL1xuICAgIF9wYXJzZUFWQ1ZpZGVvRGF0YShhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCwgZGF0YVNpemUsIHRhZ1RpbWVzdGFtcCwgdGFnUG9zaXRpb24sIGZyYW1lVHlwZSwgY3RzKSB7XG5cbiAgICAgICAgY29uc3QgbGUgPSB0aGlzLl9saXR0bGVFbmRpYW47XG4gICAgICAgIGNvbnN0IHYgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKTtcblxuICAgICAgICBsZXQgdW5pdHMgPSBbXSxcbiAgICAgICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGNvbnN0IGxlbmd0aFNpemUgPSB0aGlzLl9uYWx1TGVuZ3RoU2l6ZTtcbiAgICAgICAgY29uc3QgZHRzID0gdGhpcy5fdGltZXN0YW1wQmFzZSArIHRhZ1RpbWVzdGFtcDtcbiAgICAgICAgbGV0IGtleWZyYW1lID0gKGZyYW1lVHlwZSA9PT0gMSk7IC8vIGZyb20gRkxWIEZyYW1lIFR5cGUgY29uc3RhbnRzXG5cbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IGRhdGFTaXplKSB7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICsgNCA+PSBkYXRhU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuVEFHLCBgTWFsZm9ybWVkIE5hbHUgbmVhciB0aW1lc3RhbXAgJHtkdHN9LCBvZmZzZXQgPSAke29mZnNldH0sIGRhdGFTaXplID0gJHtkYXRhU2l6ZX1gKTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gZGF0YSBub3QgZW5vdWdoIGZvciBuZXh0IE5hbHVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5hbHUgd2l0aCBsZW5ndGgtaGVhZGVyIChBVkMxKVxuICAgICAgICAgICAgbGV0IG5hbHVTaXplID0gdi5nZXRVaW50MzIob2Zmc2V0LCAhbGUpOyAvLyBCaWctRW5kaWFuIHJlYWRcbiAgICAgICAgICAgIGlmIChsZW5ndGhTaXplID09PSAzKSB7XG4gICAgICAgICAgICAgICAgbmFsdVNpemUgPj4+PSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbHVTaXplID4gZGF0YVNpemUgLSBsZW5ndGhTaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5UQUcsIGBNYWxmb3JtZWQgTmFsdXMgbmVhciB0aW1lc3RhbXAgJHtkdHN9LCBOYWx1U2l6ZSA+IERhdGFTaXplIWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdW5pdFR5cGUgPSB2LmdldFVpbnQ4KG9mZnNldCArIGxlbmd0aFNpemUpICYgMHgxRjtcblxuICAgICAgICAgICAgaWYgKHVuaXRUeXBlID09PSA1KSB7IC8vIElEUlxuICAgICAgICAgICAgICAgIGtleWZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGhTaXplICsgbmFsdVNpemUpO1xuICAgICAgICAgICAgY29uc3QgdW5pdCA9IHsgdHlwZTogdW5pdFR5cGUsIGRhdGEgfTtcbiAgICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgICAgICBsZW5ndGggKz0gZGF0YS5ieXRlTGVuZ3RoO1xuXG4gICAgICAgICAgICBvZmZzZXQgKz0gbGVuZ3RoU2l6ZSArIG5hbHVTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVuaXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLl92aWRlb1RyYWNrO1xuICAgICAgICAgICAgY29uc3QgYXZjU2FtcGxlID0ge1xuICAgICAgICAgICAgICAgIHVuaXRzLFxuICAgICAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgICAgICBpc0tleWZyYW1lOiBrZXlmcmFtZSxcbiAgICAgICAgICAgICAgICBkdHMsXG4gICAgICAgICAgICAgICAgY3RzLFxuICAgICAgICAgICAgICAgIHB0czogKGR0cyArIGN0cylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoa2V5ZnJhbWUpIHtcbiAgICAgICAgICAgICAgICBhdmNTYW1wbGUuZmlsZXBvc2l0aW9uID0gdGFnUG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goYXZjU2FtcGxlKTtcbiAgICAgICAgICAgIHRyYWNrLmxlbmd0aCArPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3BhcnNlQXVkaW9EYXRhKGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0LCBkYXRhU2l6ZSwgdGFnVGltZXN0YW1wKSB7XG4gICAgICAgIGlmICh0YWdUaW1lc3RhbXAgPT0gdGhpcy5fdGltZXN0YW1wQmFzZSAmJiB0aGlzLl90aW1lc3RhbXBCYXNlICE9IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRhZ1RpbWVzdGFtcCwgdGhpcy5fdGltZXN0YW1wQmFzZSwgJ+WkreWvv+WVpui/meS4quinhumikeS4jeaYr+S7jjDlvIDlp4snKTtcbiAgICAgICAgICAgIC8vIHRpbWVzdGFtcEJhc2UoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YVNpemUgPD0gMSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5UQUcsICdGbHY6IEludmFsaWQgYXVkaW8gcGFja2V0LCBtaXNzaW5nIFNvdW5kRGF0YSBwYXlsb2FkIScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1ldGEgPSB0aGlzLl9hdWRpb01ldGFkYXRhO1xuICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG5cbiAgICAgICAgaWYgKCFtZXRhIHx8ICFtZXRhLmNvZGVjKSB7XG4gICAgICAgICAgICAvLyBpbml0aWFsIG1ldGFkYXRhXG4gICAgICAgICAgICBtZXRhID0gdGhpcy5fYXVkaW9NZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgbWV0YS50eXBlID0gJ2F1ZGlvJztcbiAgICAgICAgICAgIG1ldGEuaWQgPSB0cmFjay5pZDtcbiAgICAgICAgICAgIG1ldGEudGltZXNjYWxlID0gdGhpcy5fdGltZXNjYWxlO1xuICAgICAgICAgICAgbWV0YS5kdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuXG4gICAgICAgICAgICBjb25zdCBsZSA9IHRoaXMuX2xpdHRsZUVuZGlhbjtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKTtcblxuICAgICAgICAgICAgY29uc3Qgc291bmRTcGVjID0gdi5nZXRVaW50OCgwKTtcblxuICAgICAgICAgICAgY29uc3Qgc291bmRGb3JtYXQgPSBzb3VuZFNwZWMgPj4+IDQ7XG4gICAgICAgICAgICBpZiAoc291bmRGb3JtYXQgIT09IDEwKSB7IC8vIEFBQ1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgTVAzIGF1ZGlvIGNvZGVjXG4gICAgICAgICAgICAgICAgdGhpcy5fb25FcnJvcihEZW11eEVycm9ycy5DT0RFQ19VTlNVUFBPUlRFRCwgJ0ZsdjogVW5zdXBwb3J0ZWQgYXVkaW8gY29kZWMgaWR4OiAnICsgc291bmRGb3JtYXQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHNvdW5kUmF0ZSA9IDA7XG4gICAgICAgICAgICBjb25zdCBzb3VuZFJhdGVJbmRleCA9IChzb3VuZFNwZWMgJiAxMikgPj4+IDI7XG5cbiAgICAgICAgICAgIGNvbnN0IHNvdW5kUmF0ZVRhYmxlID0gWzU1MDAsIDExMDI1LCAyMjA1MCwgNDQxMDAsIDQ4MDAwXTtcblxuICAgICAgICAgICAgaWYgKHNvdW5kUmF0ZUluZGV4IDwgc291bmRSYXRlVGFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc291bmRSYXRlID0gc291bmRSYXRlVGFibGVbc291bmRSYXRlSW5kZXhdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkVycm9yKERlbXV4RXJyb3JzLkZPUk1BVF9FUlJPUiwgJ0ZsdjogSW52YWxpZCBhdWRpbyBzYW1wbGUgcmF0ZSBpZHg6ICcgKyBzb3VuZFJhdGVJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzb3VuZFNpemUgPSAoc291bmRTcGVjICYgMikgPj4+IDE7IC8vIHVudXNlZFxuICAgICAgICAgICAgY29uc3Qgc291bmRUeXBlID0gKHNvdW5kU3BlYyAmIDEpO1xuXG4gICAgICAgICAgICBtZXRhLmF1ZGlvU2FtcGxlUmF0ZSA9IHNvdW5kUmF0ZTtcbiAgICAgICAgICAgIG1ldGEuY2hhbm5lbENvdW50ID0gKHNvdW5kVHlwZSA9PT0gMCA/IDEgOiAyKTtcbiAgICAgICAgICAgIG1ldGEucmVmU2FtcGxlRHVyYXRpb24gPSBNYXRoLmZsb29yKDEwMjQgLyBtZXRhLmF1ZGlvU2FtcGxlUmF0ZSAqIG1ldGEudGltZXNjYWxlKTtcbiAgICAgICAgICAgIG1ldGEuY29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFhY0RhdGEgPSB0aGlzLl9wYXJzZUFBQ0F1ZGlvRGF0YShhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCArIDEsIGRhdGFTaXplIC0gMSk7XG4gICAgICAgIGlmIChhYWNEYXRhID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFhY0RhdGEucGFja2V0VHlwZSA9PT0gMCkgeyAvLyBBQUMgc2VxdWVuY2UgaGVhZGVyIChBdWRpb1NwZWNpZmljQ29uZmlnKVxuICAgICAgICAgICAgaWYgKG1ldGEuY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5UQUcsICdGb3VuZCBhbm90aGVyIEF1ZGlvU3BlY2lmaWNDb25maWchJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtaXNjID0gYWFjRGF0YS5kYXRhO1xuICAgICAgICAgICAgbWV0YS5hdWRpb1NhbXBsZVJhdGUgPSBtaXNjLnNhbXBsaW5nUmF0ZTtcbiAgICAgICAgICAgIG1ldGEuY2hhbm5lbENvdW50ID0gbWlzYy5jaGFubmVsQ291bnQ7XG4gICAgICAgICAgICBtZXRhLmNvZGVjID0gbWlzYy5jb2RlYztcbiAgICAgICAgICAgIG1ldGEuY29uZmlnID0gbWlzYy5jb25maWc7XG4gICAgICAgICAgICAvLyBUaGUgZGVjb2RlIHJlc3VsdCBvZiBhbiBhYWMgc2FtcGxlIGlzIDEwMjQgUENNIHNhbXBsZXNcbiAgICAgICAgICAgIG1ldGEucmVmU2FtcGxlRHVyYXRpb24gPSBNYXRoLmZsb29yKDEwMjQgLyBtZXRhLmF1ZGlvU2FtcGxlUmF0ZSAqIG1ldGEudGltZXNjYWxlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuVEFHLCAnUGFyc2VkIEF1ZGlvU3BlY2lmaWNDb25maWcnKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5pdGlhbE1ldGFkYXRhRGlzcGF0Y2hlZCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gTm9uLWluaXRpYWwgbWV0YWRhdGEsIGZvcmNlIGRpc3BhdGNoIChvciBmbHVzaCkgcGFyc2VkIGZyYW1lcyB0byByZW11eGVyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc3BhdGNoICYmICh0aGlzLl9hdWRpb1RyYWNrLmxlbmd0aCB8fCB0aGlzLl92aWRlb1RyYWNrLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25EYXRhQXZhaWxhYmxlKHRoaXMuX2F1ZGlvVHJhY2ssIHRoaXMuX3ZpZGVvVHJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9Jbml0aWFsTWV0YWRhdGFEaXNwYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZW4gbm90aWZ5IG5ldyBtZXRhZGF0YVxuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX29uVHJhY2tNZXRhZGF0YSgnYXVkaW8nLCBtZXRhKTtcblxuICAgICAgICAgICAgY29uc3QgbWkgPSB0aGlzLl9tZWRpYUluZm87XG4gICAgICAgICAgICBtaS5hdWRpb0NvZGVjID0gJ21wNGEuNDAuJyArIG1pc2Mub3JpZ2luYWxBdWRpb09iamVjdFR5cGU7XG4gICAgICAgICAgICBtaS5hdWRpb1NhbXBsZVJhdGUgPSBtZXRhLmF1ZGlvU2FtcGxlUmF0ZTtcbiAgICAgICAgICAgIG1pLmF1ZGlvQ2hhbm5lbENvdW50ID0gbWV0YS5jaGFubmVsQ291bnQ7XG4gICAgICAgICAgICBpZiAobWkuaGFzVmlkZW8pIHtcbiAgICAgICAgICAgICAgICBpZiAobWkudmlkZW9Db2RlYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pLm1pbWVUeXBlID0gJ3ZpZGVvL3gtZmx2OyBjb2RlY3M9XCInICsgbWkudmlkZW9Db2RlYyArICcsJyArIG1pLmF1ZGlvQ29kZWMgKyAnXCInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWkubWltZVR5cGUgPSAndmlkZW8veC1mbHY7IGNvZGVjcz1cIicgKyBtaS5hdWRpb0NvZGVjICsgJ1wiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaS5pc0NvbXBsZXRlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbk1lZGlhSW5mbyhtaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoYWFjRGF0YS5wYWNrZXRUeXBlID09PSAxKSB7IC8vIEFBQyByYXcgZnJhbWUgZGF0YVxuICAgICAgICAgICAgY29uc3QgZHRzID0gdGhpcy5fdGltZXN0YW1wQmFzZSArIHRhZ1RpbWVzdGFtcDtcbiAgICAgICAgICAgIGNvbnN0IGFhY1NhbXBsZSA9IHsgdW5pdDogYWFjRGF0YS5kYXRhLCBkdHMsIHB0czogZHRzIH07XG4gICAgICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goYWFjU2FtcGxlKTtcbiAgICAgICAgICAgIHRyYWNrLmxlbmd0aCArPSBhYWNEYXRhLmRhdGEubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5UQUcsIGBGbHY6IFVuc3VwcG9ydGVkIEFBQyBkYXRhIHR5cGUgJHthYWNEYXRhLnBhY2tldFR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcGFyc2VBQUNBdWRpb0RhdGEoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKSB7XG4gICAgICAgIGlmIChkYXRhU2l6ZSA8PSAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLlRBRywgJ0ZsdjogSW52YWxpZCBBQUMgcGFja2V0LCBtaXNzaW5nIEFBQ1BhY2tldFR5cGUgb3IvYW5kIERhdGEhJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCwgZGF0YVNpemUpO1xuXG4gICAgICAgIHJlc3VsdC5wYWNrZXRUeXBlID0gYXJyYXlbMF07XG5cbiAgICAgICAgaWYgKGFycmF5WzBdID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IHRoaXMuX3BhcnNlQUFDQXVkaW9TcGVjaWZpY0NvbmZpZyhhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCArIDEsIGRhdGFTaXplIC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IGFycmF5LnN1YmFycmF5KDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBfcGFyc2VBQUNBdWRpb1NwZWNpZmljQ29uZmlnKGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0LCBkYXRhU2l6ZSkge1xuICAgICAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0LCBkYXRhU2l6ZSk7XG4gICAgICAgIGxldCBjb25maWcgPSBudWxsO1xuXG4gICAgICAgIGNvbnN0IG1wZWdTYW1wbGluZ1JhdGVzID0gW1xuICAgICAgICAgICAgOTYwMDAsIDg4MjAwLCA2NDAwMCwgNDgwMDAsIDQ0MTAwLCAzMjAwMCxcbiAgICAgICAgICAgIDI0MDAwLCAyMjA1MCwgMTYwMDAsIDEyMDAwLCAxMTAyNSwgODAwMCwgNzM1MFxuICAgICAgICBdO1xuXG4gICAgICAgIC8qIEF1ZGlvIE9iamVjdCBUeXBlOlxuICAgICAgICAgICAwOiBOdWxsXG4gICAgICAgICAgIDE6IEFBQyBNYWluXG4gICAgICAgICAgIDI6IEFBQyBMQ1xuICAgICAgICAgICAzOiBBQUMgU1NSIChTY2FsYWJsZSBTYW1wbGUgUmF0ZSlcbiAgICAgICAgICAgNDogQUFDIExUUCAoTG9uZyBUZXJtIFByZWRpY3Rpb24pXG4gICAgICAgICAgIDU6IEhFLUFBQyAvIFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbilcbiAgICAgICAgICAgNjogQUFDIFNjYWxhYmxlXG4gICAgICAgICovXG5cbiAgICAgICAgbGV0IGF1ZGlvT2JqZWN0VHlwZSA9IDA7XG4gICAgICAgIGxldCBvcmlnaW5hbEF1ZGlvT2JqZWN0VHlwZSA9IDA7XG4gICAgICAgIGxldCBhdWRpb0V4dGVuc2lvbk9iamVjdFR5cGUgPSBudWxsO1xuICAgICAgICBsZXQgc2FtcGxpbmdJbmRleCA9IDA7XG4gICAgICAgIGxldCBleHRlbnNpb25TYW1wbGluZ0luZGV4ID0gbnVsbDtcbiAgICAgICAgLy8gZGVidWdnZXI7XG4gICAgICAgIC8vIDUgYml0c1xuICAgICAgICBhdWRpb09iamVjdFR5cGUgPSBvcmlnaW5hbEF1ZGlvT2JqZWN0VHlwZSA9IGFycmF5WzBdID4+PiAzO1xuICAgICAgICAvLyA0IGJpdHNcbiAgICAgICAgc2FtcGxpbmdJbmRleCA9ICgoYXJyYXlbMF0gJiAweDA3KSA8PCAxKSB8IChhcnJheVsxXSA+Pj4gNyk7XG4gICAgICAgIGlmIChzYW1wbGluZ0luZGV4IDwgMCB8fCBzYW1wbGluZ0luZGV4ID49IG1wZWdTYW1wbGluZ1JhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fb25FcnJvcihEZW11eEVycm9ycy5GT1JNQVRfRVJST1IsICdGbHY6IEFBQyBpbnZhbGlkIHNhbXBsaW5nIGZyZXF1ZW5jeSBpbmRleCEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNhbXBsaW5nRnJlcXVlbmNlID0gbXBlZ1NhbXBsaW5nUmF0ZXNbc2FtcGxpbmdJbmRleF07XG5cbiAgICAgICAgLy8gNCBiaXRzXG4gICAgICAgIGNvbnN0IGNoYW5uZWxDb25maWcgPSAoYXJyYXlbMV0gJiAweDc4KSA+Pj4gMztcbiAgICAgICAgaWYgKGNoYW5uZWxDb25maWcgPCAwIHx8IGNoYW5uZWxDb25maWcgPj0gOCkge1xuICAgICAgICAgICAgdGhpcy5fb25FcnJvcihEZW11eEVycm9ycy5GT1JNQVRfRVJST1IsICdGbHY6IEFBQyBpbnZhbGlkIGNoYW5uZWwgY29uZmlndXJhdGlvbicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF1ZGlvT2JqZWN0VHlwZSA9PT0gNSkgeyAvLyBIRS1BQUM/XG4gICAgICAgICAgICAvLyA0IGJpdHNcbiAgICAgICAgICAgIGV4dGVuc2lvblNhbXBsaW5nSW5kZXggPSAoKGFycmF5WzFdICYgMHgwNykgPDwgMSkgfCAoYXJyYXlbMl0gPj4+IDcpO1xuICAgICAgICAgICAgLy8gNSBiaXRzXG4gICAgICAgICAgICBhdWRpb0V4dGVuc2lvbk9iamVjdFR5cGUgPSAoYXJyYXlbMl0gJiAweDdDKSA+Pj4gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdvcmthcm91bmRzIGZvciB2YXJpb3VzIGJyb3dzZXJzXG4gICAgICAgIGNvbnN0IHVzZXJBZ2VudCA9IHNlbGYubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmICh1c2VyQWdlbnQuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gZmlyZWZveDogdXNlIFNCUiAoSEUtQUFDKSBpZiBmcmVxIGxlc3MgdGhhbiAyNGtIelxuICAgICAgICAgICAgaWYgKHNhbXBsaW5nSW5kZXggPj0gNikge1xuICAgICAgICAgICAgICAgIGF1ZGlvT2JqZWN0VHlwZSA9IDU7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBzYW1wbGluZ0luZGV4IC0gMztcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVzZSBMQy1BQUNcbiAgICAgICAgICAgICAgICBhdWRpb09iamVjdFR5cGUgPSAyO1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25TYW1wbGluZ0luZGV4ID0gc2FtcGxpbmdJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gYW5kcm9pZDogYWx3YXlzIHVzZSBMQy1BQUNcbiAgICAgICAgICAgIGF1ZGlvT2JqZWN0VHlwZSA9IDI7XG4gICAgICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICAgICAgICBleHRlbnNpb25TYW1wbGluZ0luZGV4ID0gc2FtcGxpbmdJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZvciBvdGhlciBicm93c2VycywgZS5nLiBjaHJvbWUuLi5cbiAgICAgICAgICAgIC8vIEFsd2F5cyB1c2UgSEUtQUFDIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHN3aXRjaCBhYWMgY29kZWMgcHJvZmlsZVxuICAgICAgICAgICAgYXVkaW9PYmplY3RUeXBlID0gNTtcbiAgICAgICAgICAgIGV4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBzYW1wbGluZ0luZGV4O1xuICAgICAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuXG4gICAgICAgICAgICBpZiAoc2FtcGxpbmdJbmRleCA+PSA2KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IHNhbXBsaW5nSW5kZXggLSAzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ29uZmlnID09PSAxKSB7IC8vIE1vbm8gY2hhbm5lbFxuICAgICAgICAgICAgICAgIGF1ZGlvT2JqZWN0VHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBzYW1wbGluZ0luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnWzBdID0gYXVkaW9PYmplY3RUeXBlIDw8IDM7XG4gICAgICAgIGNvbmZpZ1swXSB8PSAoc2FtcGxpbmdJbmRleCAmIDB4MEYpID4+PiAxO1xuICAgICAgICBjb25maWdbMV0gPSAoc2FtcGxpbmdJbmRleCAmIDB4MEYpIDw8IDc7XG4gICAgICAgIGNvbmZpZ1sxXSB8PSAoY2hhbm5lbENvbmZpZyAmIDB4MEYpIDw8IDM7XG4gICAgICAgIGlmIChhdWRpb09iamVjdFR5cGUgPT09IDUpIHtcbiAgICAgICAgICAgIGNvbmZpZ1sxXSB8PSAoKGV4dGVuc2lvblNhbXBsaW5nSW5kZXggJiAweDBGKSA+Pj4gMSk7XG4gICAgICAgICAgICBjb25maWdbMl0gPSAoZXh0ZW5zaW9uU2FtcGxpbmdJbmRleCAmIDB4MDEpIDw8IDc7XG4gICAgICAgICAgICAvLyBleHRlbmRlZCBhdWRpbyBvYmplY3QgdHlwZTogZm9yY2UgdG8gMiAoTEMtQUFDKVxuICAgICAgICAgICAgY29uZmlnWzJdIHw9ICgyIDw8IDIpO1xuICAgICAgICAgICAgY29uZmlnWzNdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBzYW1wbGluZ1JhdGU6IHNhbXBsaW5nRnJlcXVlbmNlLFxuICAgICAgICAgICAgY2hhbm5lbENvdW50OiBjaGFubmVsQ29uZmlnLFxuICAgICAgICAgICAgY29kZWM6ICdtcDRhLjQwLicgKyBhdWRpb09iamVjdFR5cGUsXG4gICAgICAgICAgICBvcmlnaW5hbEF1ZGlvT2JqZWN0VHlwZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaXNJbml0aWFsTWV0YWRhdGFEaXNwYXRjaGVkKCkge1xuICAgICAgICBpZiAodGhpcy5faGFzQXVkaW8gJiYgdGhpcy5faGFzVmlkZW8pIHsgLy8gYm90aCBhdWRpbyAmIHZpZGVvXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXVkaW9Jbml0aWFsTWV0YWRhdGFEaXNwYXRjaGVkICYmIHRoaXMuX3ZpZGVvSW5pdGlhbE1ldGFkYXRhRGlzcGF0Y2hlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faGFzQXVkaW8gJiYgIXRoaXMuX2hhc1ZpZGVvKSB7IC8vIGF1ZGlvIG9ubHlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdWRpb0luaXRpYWxNZXRhZGF0YURpc3BhdGNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNBdWRpbyAmJiB0aGlzLl9oYXNWaWRlbykgeyAvLyB2aWRlbyBvbmx5XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlkZW9Jbml0aWFsTWV0YWRhdGFEaXNwYXRjaGVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgbmV3IHRhZ0RlbXV4KCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvZmx2L3RhZ2RlbXV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/**\n * 代码借鉴了flv.js\n * 增加了自己的注释和写法\n */\n/* eslint-disable */\nclass MP4 {\n\n    static init() {\n        MP4.types = {\n            avc1: [],\n            avcC: [],\n            btrt: [],\n            dinf: [],\n            dref: [],\n            esds: [],\n            ftyp: [],\n            hdlr: [],\n            mdat: [],\n            mdhd: [],\n            mdia: [],\n            mfhd: [],\n            minf: [],\n            moof: [],\n            moov: [],\n            mp4a: [],\n            mvex: [],\n            mvhd: [],\n            sdtp: [],\n            stbl: [],\n            stco: [],\n            stsc: [],\n            stsd: [],\n            stsz: [],\n            stts: [],\n            tfdt: [],\n            tfhd: [],\n            traf: [],\n            trak: [],\n            trun: [],\n            trex: [],\n            tkhd: [],\n            vmhd: [],\n            smhd: []\n        };\n\n        for (const name in MP4.types) {\n            if (MP4.types.hasOwnProperty(name)) {\n                MP4.types[name] = [\n                    name.charCodeAt(0),\n                    name.charCodeAt(1),\n                    name.charCodeAt(2),\n                    name.charCodeAt(3)\n                ];\n            }\n        }\n\n        const constants = MP4.constants = {};\n\n        constants.FTYP = new Uint8Array([\n            0x69, 0x73, 0x6F, 0x6D, // major_brand: isom\t\tisom\tMP4  Base Media v1 [IS0 14496-12:2003]\tISO\tYES\tvideo/mp4\n            0x0, 0x0, 0x0, 0x1, // minor_version: 0x01\n            0x69, 0x73, 0x6F, 0x6D, // isom\n            0x61, 0x76, 0x63, 0x31 // avc1\n        ]);\n\n        constants.STSD_PREFIX = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags  version字段后会有一个entry count字段\n            0x00, 0x00, 0x00, 0x01 // entry_count\t根据entry的个数，每个entry会有type信息，如“vide”、“sund”等，根据type不同sample description会提供不同的信息，例如对于video track，会有“VisualSampleEntry”类型信息，对于audio track会有“AudioSampleEntry”类型信息。\n        ]);\n\n        constants.STTS = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags\n            0x00, 0x00, 0x00, 0x00 // entry_count     0个索引\n        ]);\n\n        constants.STSC = constants.STCO = constants.STTS;\n\n        constants.STSZ = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags\n            0x00, 0x00, 0x00, 0x00, // sample_size\n            0x00, 0x00, 0x00, 0x00 // sample_count\n        ]);\n\n        constants.HDLR_VIDEO = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags\n            0x00, 0x00, 0x00, 0x00, // pre_defined\n            0x76, 0x69, 0x64, 0x65, // handler_type: 'vide' 在media box中，该值为4个字符\t\t“vide”— video track\n            0x00, 0x00, 0x00, 0x00, // reserved: 3 * 4 bytes\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, // 保留位\n            0x56, 0x69, 0x64, 0x65,\n            0x6F, 0x48, 0x61, 0x6E,\n            0x64, 0x6C, 0x65, 0x72, 0x00 // name: VideoHandler 长度不定\t\ttrack type name，以‘\\0’结尾的字符串\n        ]);\n\n        constants.HDLR_AUDIO = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags\n            0x00, 0x00, 0x00, 0x00, // pre_defined\n            0x73, 0x6F, 0x75, 0x6E, // handler_type: 'soun'在media box中，该值为4个字符\t\t“soun”— audio track\n            0x00, 0x00, 0x00, 0x00, // reserved: 3 * 4 bytes\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, // 保留位\n            0x53, 0x6F, 0x75, 0x6E,\n            0x64, 0x48, 0x61, 0x6E,\n            0x64, 0x6C, 0x65, 0x72, 0x00 // name: SoundHandler 长度不定\t\ttrack type name，以‘\\0’结尾的字符串\n        ]);\n\n        constants.DREF = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags\n            0x00, 0x00, 0x00, 0x01, // entry_count 1个url\n            // url\tbox开始\n            0x00, 0x00, 0x00, 0x0C, // entry_size\n            0x75, 0x72, 0x6C, 0x20, // type 'url '\n            0x00, 0x00, 0x00, 0x01 // version(0) + flags 当“url”或“urn”的box flag为1时，字符串均为空。\n        ]);\n\n        // Sound media header\n        constants.SMHD = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags\tbox版本，0或1，一般为0。\n            0x00, 0x00, 0x00, 0x00 // balance(2) + reserved(2) 立体声平衡，[8.8] 格式值，一般为0，-1.0表示全部左声道，1.0表示全部右声道+2位保留位\n        ]);\n\n        // video media header\n        constants.VMHD = new Uint8Array([\n            0x00, 0x00, 0x00, 0x01, // version(0) + flags\n            0x00, 0x00, // graphicsmode: 2 bytes 视频合成模式，为0时拷贝原始图像，否则与opcolor进行合成   //理论上是4位啊  暂时保留\n            0x00, 0x00, 0x00, 0x00, // opcolor: 3 * 2 bytes ｛red，green，blue｝\n            0x00, 0x00\n        ]);\n    }\n\n    /**\n     * 封装box\n     */\n    static box(type) {\n        let size = 8;\n        let result = null;\n        const datas = Array.prototype.slice.call(arguments, 1);\n        const arrayCount = datas.length;\n\n        for (let i = 0; i < arrayCount; i++) {\n            size += datas[i].byteLength;\n        }\n        // box头部大小\n        result = new Uint8Array(size);\n        result[0] = (size >>> 24) & 0xFF; // size\n        result[1] = (size >>> 16) & 0xFF;\n        result[2] = (size >>> 8) & 0xFF;\n        result[3] = (size) & 0xFF;\n        // 写入box的type\n        result.set(type, 4); // type\n\n        let offset = 8;\n        for (let i = 0; i < arrayCount; i++) { // data body\n            result.set(datas[i], offset);\n            offset += datas[i].byteLength;\n        }\n\n        return result;\n    }\n\n    // 创建ftyp&moov\n    static generateInitSegment(meta) {\n        if (meta.constructor != Array) {\n            meta = [meta];\n        }\n        const ftyp = MP4.box(MP4.types.ftyp, MP4.constants.FTYP);\n        const moov = MP4.moov(meta);\n\n        const result = new Uint8Array(ftyp.byteLength + moov.byteLength);\n        result.set(ftyp, 0);\n        result.set(moov, ftyp.byteLength);\n        return result;\n    }\n\n    // Movie metadata box\n    static moov(meta) {\n        const mvhd = MP4.mvhd(meta[0].timescale, meta[0].duration); // /moov里面的第一个box\n        const vtrak = MP4.trak(meta[0]);\n        let atrak;\n        if (meta.length > 1) {\n            atrak = MP4.trak(meta[1]);\n        }\n\n        const mvex = MP4.mvex(meta);\n        if (meta.length > 1) { return MP4.box(MP4.types.moov, mvhd, vtrak, atrak, mvex); } else { return MP4.box(MP4.types.moov, mvhd, vtrak, mvex); }\n    }\n\n    // Movie header box\n    static mvhd(timescale, duration) {\n        return MP4.box(MP4.types.mvhd, new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags     1位的box版本+3位flags   box版本，0或1，一般为0。（以下字节数均按version=0）\n            0x00, 0x00, 0x00, 0x00, // creation_time    创建时间  （相对于UTC时间1904-01-01零点的秒数）\n            0x00, 0x00, 0x00, 0x00, // modification_time   修改时间\n            (timescale >>> 24) & 0xFF, // timescale: 4 bytes\t\t文件媒体在1秒时间内的刻度值，可以理解为1秒长度\n            (timescale >>> 16) & 0xFF,\n            (timescale >>> 8) & 0xFF,\n            (timescale) & 0xFF,\n            (duration >>> 24) & 0xFF, // duration: 4 bytes\t该track的时间长度，用duration和time scale值可以计算track时长，比如audio track的time scale = 8000, duration = 560128，时长为70.016，video track的time scale = 600, duration = 42000，时长为70\n            (duration >>> 16) & 0xFF,\n            (duration >>> 8) & 0xFF,\n            (duration) & 0xFF,\n            0x00, 0x01, 0x00, 0x00, // Preferred rate: 1.0   推荐播放速率，高16位和低16位分别为小数点整数部分和小数部分，即[16.16] 格式，该值为1.0（0x00010000）表示正常前向播放\n            0x01, 0x00, 0x00, 0x00, // PreferredVolume(1.0, 2bytes) + reserved(2bytes)\t与rate类似，[8.8] 格式，1.0（0x0100）表示最大音量\n            0x00, 0x00, 0x00, 0x00, // reserved: 4 + 4 bytes\t保留位\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x01, 0x00, 0x00, // ----begin composition matrix----\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, // 视频变换矩阵   线性代数\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x01, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x40, 0x00, 0x00, 0x00, // ----end composition matrix----\n            0x00, 0x00, 0x00, 0x00, // ----begin pre_defined 6 * 4 bytes----\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, // pre-defined 保留位\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, // ----end pre_defined 6 * 4 bytes----\n            0xFF, 0xFF, 0xFF, 0xFF // next_track_ID 下一个track使用的id号\n        ]));\n    }\n\n    // Track box\n    static trak(meta) {\n        return MP4.box(MP4.types.trak, MP4.tkhd(meta), MP4.mdia(meta));\n    }\n\n    // Track header box\n    static tkhd(meta) {\n        let trackId = meta.id,\n            duration = meta.duration;\n        let width = meta.presentWidth,\n            height = meta.presentHeight;\n\n        return MP4.box(MP4.types.tkhd, new Uint8Array([\n            0x00, 0x00, 0x00, 0x07, // version(0) + flags 1位版本 box版本，0或1，一般为0。（以下字节数均按version=0）按位或操作结果值，预定义如下：\n            // 0x000001 track_enabled，否则该track不被播放；\n            // 0x000002 track_in_movie，表示该track在播放中被引用；\n            // 0x000004 track_in_preview，表示该track在预览时被引用。\n            // 一般该值为7，1+2+4 如果一个媒体所有track均未设置track_in_movie和track_in_preview，将被理解为所有track均设置了这两项；对于hint track，该值为0\n            // hint track  这个特殊的track并不包含媒体数据，而是包含了一些将其他数据track打包成流媒体的指示信息。\n            0x00, 0x00, 0x00, 0x00, // creation_time\t创建时间（相对于UTC时间1904-01-01零点的秒数）\n            0x00, 0x00, 0x00, 0x00, // modification_time\t修改时间\n            (trackId >>> 24) & 0xFF, // track_ID: 4 bytes\tid号，不能重复且不能为0\n            (trackId >>> 16) & 0xFF,\n            (trackId >>> 8) & 0xFF,\n            (trackId) & 0xFF,\n            0x00, 0x00, 0x00, 0x00, // reserved: 4 bytes    保留位\n            (duration >>> 24) & 0xFF, // duration: 4 bytes  \ttrack的时间长度\n            (duration >>> 16) & 0xFF,\n            (duration >>> 8) & 0xFF,\n            (duration) & 0xFF,\n            0x00, 0x00, 0x00, 0x00, // reserved: 2 * 4 bytes    保留位\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, // layer(2bytes) + alternate_group(2bytes)  视频层，默认为0，值小的在上层.track分组信息，默认为0表示该track未与其他track有群组关系\n            0x00, 0x00, 0x00, 0x00, // volume(2bytes) + reserved(2bytes)    [8.8] 格式，如果为音频track，1.0（0x0100）表示最大音量；否则为0   +保留位\n            0x00, 0x01, 0x00, 0x00, // ----begin composition matrix----\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x01, 0x00, 0x00, // 视频变换矩阵\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x40, 0x00, 0x00, 0x00, // ----end composition matrix----\n            (width >>> 8) & 0xFF, // //宽度\n            (width) & 0xFF,\n            0x00, 0x00,\n            (height >>> 8) & 0xFF, // 高度\n            (height) & 0xFF,\n            0x00, 0x00\n        ]));\n    }\n\n    /**\n     * “mdia”也是个container box，其子box的结构和种类还是比较复杂的。先来看一个“mdia”的实例结构树图。\n     * 总体来说，“mdia”定义了track媒体类型以及sample数据，描述sample信息。一般“mdia”包含一个“mdhd”，\n     * 一个“hdlr”和一个“minf”，其中“mdhd”为media header box，“hdlr”为handler reference box，\n     * “minf”为media information box。\n     *\n     * mdia\n     * \t\tmdhd\n     * \t\thdlr\n     * \t\tminf\n     * \t\t\tsmhd\n     * \t\t\tdinf\n     * \t\t\t\tdref\n     * \t\t\t\t\turl\n     * \t\t\tstbl\n     * \t\t\t\tstsd\n     * \t\t\t\t\tmp4a\n     * \t\t\t\t\t\tesds\n     * \t\t\t\tstts\n     * \t\t\t\tstsc\n     * \t\t\t\tstsz\n     * \t\t\t\tstco\n     */\n    static mdia(meta) {\n        return MP4.box(MP4.types.mdia, MP4.mdhd(meta), MP4.hdlr(meta), MP4.minf(meta));\n    }\n\n    // Media header box\n    static mdhd(meta) {\n        const timescale = meta.timescale;\n        const duration = meta.duration;\n        return MP4.box(MP4.types.mdhd, new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags // version(0) + flags\t\tbox版本，0或1，一般为0。\n            0x00, 0x00, 0x00, 0x00, // creation_time    创建时间\n            0x00, 0x00, 0x00, 0x00, // modification_time修改时间\n            (timescale >>> 24) & 0xFF, // timescale: 4 bytes    文件媒体在1秒时间内的刻度值，可以理解为1秒长度\n            (timescale >>> 16) & 0xFF,\n            (timescale >>> 8) & 0xFF,\n            (timescale) & 0xFF,\n            (duration >>> 24) & 0xFF, // duration: 4 bytes  track的时间长度\n            (duration >>> 16) & 0xFF,\n            (duration >>> 8) & 0xFF,\n            (duration) & 0xFF,\n            0x55, 0xC4, // language: und (undetermined) 媒体语言码。最高位为0，后面15位为3个字符（见ISO 639-2/T标准中定义）\n            0x00, 0x00 // pre_defined = 0\n        ]));\n    }\n\n    // Media handler reference box\n    static hdlr(meta) {\n        let data = null;\n        if (meta.type === 'audio') {\n            data = MP4.constants.HDLR_AUDIO;\n        } else {\n            data = MP4.constants.HDLR_VIDEO;\n        }\n        return MP4.box(MP4.types.hdlr, data);\n    }\n\n    /**\n\t\t * “minf”存储了解释track媒体数据的handler-specific信息，media handler用这些信息将媒体时间映射到媒体数据并进行处理。“minf”中的信息格式和内容与媒体类型以及解释媒体数据的media handler密切相关，其他media handler不知道如何解释这些信息。“minf”是一个container box，其实际内容由子box说明。\n    一般情况下，“minf”包含一个header box，一个“dinf”和一个“stbl”，其中，header box根据track type（即media handler type）分为“vmhd”、“smhd”、“hmhd”和“nmhd”，“dinf”为data information box，“stbl”为sample table box。下面分别介绍。\n\n\t\t *\n\t\t */\n    // Media infomation box\n    static minf(meta) {\n        // header box根据track type（即media handler type）分为“vmhd”、“smhd”、“hmhd”和“nmhd”\n        let xmhd = null;\n        if (meta.type === 'audio') {\n            xmhd = MP4.box(MP4.types.smhd, MP4.constants.SMHD);\n        } else {\n            xmhd = MP4.box(MP4.types.vmhd, MP4.constants.VMHD);\n        }\n        return MP4.box(MP4.types.minf, xmhd, MP4.dinf(), MP4.stbl(meta));\n    }\n\n    /**\n     * Data Information Box\n     * “dinf”解释如何定位媒体信息，是一个container box。“dinf”一般包含一个“dref”，即data reference box；\n     * “dref”下会包含若干个“url”或“urn”，这些box组成一个表，用来定位track数据。\n     * 简单的说，track可以被分成若干段，每一段都可以根据“url”或“urn”指向的地址来获取数据，\n     * sample描述中会用这些片段的序号将这些片段组成一个完整的track。\n     * 一般情况下，当数据被完全包含在文件中时，“url”或“urn”中的定位字符串是空的。\n     */\n    static dinf() {\n        const result = MP4.box(MP4.types.dinf,\n            MP4.box(MP4.types.dref, MP4.constants.DREF)\n        );\n        return result;\n    }\n\n    /**\n\t\t * Sample Table Box（stbl）\n    \t*\t“stbl”几乎是普通的MP4文件中最复杂的一个box了，首先需要回忆一下sample的概念。\n \t\t* \tsample是媒体数据存储的单位，存储在media的chunk中，chunk和sample的长度均可互不相同，如下图所示。\n\t\t\t“stbl”是一个container box，其子box包括：sample description box（stsd）、\n\t\t\t * time to sample box（stts）、sample size box（stsz或stz2）、\n\t\t\t * sample to chunk box（stsc）、chunk offset box（stco或co64）、\n\t\t\t * composition time to sample box（ctts）、sync sample box（stss）\n\t\t\t * stsd”必不可少，且至少包含一个条目，该box包含了data reference box进行sample数据检索的信息。\n\t\t\t * 没有“stsd”就无法计算media sample的存储位置。“stsd”包含了编码的信息，其存储的信息随媒体类型不同而不同。\n\t\t\t * \t\t\tstbl\n\t\t\t * \t\t\t\tstsd\n\t\t\t * \t\t\t\t\tavc1\n\t\t\t * \t\t\t\t\t\tavcC\n\t\t\t * \t\t\t\tstts\n\t\t\t * \t\t\t\tstsc\n\t\t\t * \t\t\t\tstsz\n\t\t\t * \t\t\t\tstco\n\t\t */\n    static stbl(meta) {\n        const result = MP4.box(MP4.types.stbl, // type: stbl\n            MP4.stsd(meta), // Sample Description Table\n            MP4.box(MP4.types.stts, MP4.constants.STTS), // Time-To-Sample    因为stts的entry count 为0\n            // 所以没有关键帧index 的stss\n            // 也没有CTTS box CTTS是记录偏移量\n            MP4.box(MP4.types.stsc, MP4.constants.STSC), // Sample-To-Chunk\n            MP4.box(MP4.types.stsz, MP4.constants.STSZ), // Sample size\n            MP4.box(MP4.types.stco, MP4.constants.STCO) // Chunk offset\n        );\n        return result;\n    }\n\n    /**\n\t\t * Sample Description Box（stsd）\n    \t\tbox header和version字段后会有一个entry count字段，\n * \t\t\t根据entry的个数，每个entry会有type信息，如“vide”、“sund”等，\n * \t\t根据type不同sample description会提供不同的信息，例如对于video track，\n * 会有“VisualSampleEntry”类型信息，对于audio track会有“AudioSampleEntry”类型信息。\n\n\t\t * * \t\t\t\tstsd\n\t\t\t* \t\t\t\t\tmp4a\n\t\t\t* \t\t\t\t\t\tesds\n\t\t\t *\n\t\t\t *\n\t\t\t *\n\t\t\t *\n\t\t\t * \t\t 4 bytes - length in total\n\t\t\t\t\t 4 bytes - 4 char code of sample description table (stsd)\n\t\t\t\t\t 4 bytes - version & flags\n\t\t\t\t\t 4 bytes - number of sample entries (num_sample_entries)\n\t\t\t\t\t\t [\n\t\t\t\t\t\t    4 bytes - length of sample entry (len_sample_entry)\n\t\t\t\t\t\t    4 bytes - 4 char code of sample entry\n\t\t\t\t\t\t    ('len_sample_entry' - 8) bytes of data\n\t\t\t\t\t\t ] (repeated 'num_sample_entries' times)\n\t\t\t\t\t(4 bytes - optional 0x00000000 as end of box marker )\n\t\t */\n    static stsd(meta) {\n        if (meta.type === 'audio') {\n            return MP4.box(MP4.types.stsd, MP4.constants.STSD_PREFIX, MP4.mp4a(meta));\n        } else {\n            return MP4.box(MP4.types.stsd, MP4.constants.STSD_PREFIX, MP4.avc1(meta));\n        }\n    }\n\n    static mp4a(meta) {\n        const channelCount = meta.channelCount;\n        const sampleRate = meta.audioSampleRate;\n\n        const data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // reserved(4) 6个字节，设置为0；\n            0x00, 0x00, 0x00, 0x01, // reserved(2) + data_reference_index(2)\n            0x00, 0x00, 0x00, 0x00, // reserved: 2 * 4 bytes 保留位\n            0x00, 0x00, 0x00, 0x00,\n            0x00, channelCount, // channelCount(2) 单声道还是双声道\n            0x00, 0x10, // sampleSize(2)\n            0x00, 0x00, 0x00, 0x00, // reserved(4) 4字节保留位\n            (sampleRate >>> 8) & 0xFF, // Audio sample rate 显然要右移16位才有意义\ttemplate unsigned int(32) samplerate = {timescale of media}<<16;\n            (sampleRate) & 0xFF,\n            0x00, 0x00\n        ]);\n\n        return MP4.box(MP4.types.mp4a, data, MP4.esds(meta));\n    }\n\n    static esds(meta) {\n        const config = meta.config;\n        const configSize = config.length;\n        const data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version 0 + flags\n\n            0x03, // descriptor_type    MP4ESDescrTag\n            0x17 + configSize, // length3\n            0x00, 0x01, // es_id\n            0x00, // stream_priority\n\n            0x04, // descriptor_type    MP4DecConfigDescrTag\n            0x0F + configSize, // length\n            0x40, // codec: mpeg4_audio\n            /**\n             *当objectTypeIndication为0x40时，为MPEG-4 Audio（MPEG-4 Audio generally is thought of as AAC\n             * but there is a whole framework of audio codecs that can Go in MPEG-4 Audio including AAC, BSAC, ALS, CELP,\n             * and something called MP3On4），如果想更细分format为aac还是mp3，\n             * 可以读取MP4DecSpecificDescr层data[0]的前五位\n             */\n            0x15, // stream_type: Audio\n            0x00, 0x00, 0x00, // buffer_size\n            0x00, 0x00, 0x00, 0x00, // maxBitrate\n            0x00, 0x00, 0x00, 0x00, // avgBitrate\n\n            0x05 // descriptor_type MP4DecSpecificDescrTag\n        ].concat([\n            configSize\n        ]).concat(\n            config\n        ).concat([\n            0x06, 0x01, 0x02 // GASpecificConfig\n        ]));\n        return MP4.box(MP4.types.esds, data);\n    }\n\n    /**\n     * 改版\n     *stsd下的avc1视频解析\n     */\n    static avc1(meta) {\n        const avcc = meta.avcc;\n        let width = meta.codecWidth,\n            height = meta.codecHeight;\n\n        const data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // // reserved(4)    6个 保留位\tReserved：6个字节，设置为0；\n            0x00, 0x00, 0x00, 0x01, // reserved(2) + {{{{data_reference_index(2)  数据引用索引}}}}\n            0x00, 0x00, 0x00, 0x00, // pre_defined(2) + reserved(2)\n            0x00, 0x00, 0x00, 0x00, // pre_defined: 3 * 4 bytes  3*4个字节的保留位\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            (width >>> 8) & 0xFF, // width: 2 bytes\n            (width) & 0xFF,\n            (height >>> 8) & 0xFF, // height: 2 bytes\n            (height) & 0xFF,\n            0x00, 0x48, 0x00, 0x00, // horizresolution: 4 bytes 常数\n            0x00, 0x48, 0x00, 0x00, // vertresolution: 4 bytes 常数\n            0x00, 0x00, 0x00, 0x00, // reserved: 4 bytes 保留位\n            0x00, 0x01, // frame_count\n            // frame_count表明多少帧压缩视频存储在每个样本。默认是1,每样一帧;它可能超过1每个样本的多个帧数\n            0x04, //\tstrlen compressorname: 32 bytes\t\t\tString[32]\n            // 32个8 bit    第一个8bit表示长度,剩下31个8bit表示内容\n            0x67, 0x31, 0x31, 0x31, // compressorname: 32 bytes    翻译过来是g111\n            0x00, 0x00, 0x00, 0x00, //\n            0x00, 0x00, 0x00, 0x00, //\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00,\n            0x00, 0x18, // depth 颜色深度\n            0xFF, 0xFF // pre_defined = -1\n        ]);\n        return MP4.box(MP4.types.avc1, data, MP4.box(MP4.types.avcC, avcc));\n    }\n\n    // Movie Extends box\n    static mvex(meta) {\n        if (meta.length > 1) { return MP4.box(MP4.types.mvex, MP4.trex(meta[0]), MP4.trex(meta[1])); } else { return MP4.box(MP4.types.mvex, MP4.trex(meta[0])); }\n    }\n\n    // Track Extends box\n    static trex(meta) {\n        const trackId = meta.id;\n        const data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) + flags\n            (trackId >>> 24) & 0xFF, // track_ID\n            (trackId >>> 16) & 0xFF,\n            (trackId >>> 8) & 0xFF,\n            (trackId) & 0xFF,\n            0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n            0x00, 0x00, 0x00, 0x00, // default_sample_duration\n            0x00, 0x00, 0x00, 0x00, // default_sample_size\n            0x00, 0x01, 0x00, 0x01 // default_sample_flags\n        ]);\n        // if (meta.type !== 'video') {\n        //     data[data.length - 1] = 0x00;\n        // }\n        return MP4.box(MP4.types.trex, data);\n    }\n\n    // Movie fragment box\n    static moof(track, baseMediaDecodeTime) {\n        return MP4.box(MP4.types.moof, MP4.mfhd(track.sequenceNumber), MP4.traf(track, baseMediaDecodeTime));\n    }\n\n    static mfhd(sequenceNumber) {\n        const data = new Uint8Array([\n            0x00, 0x00, 0x00, 0x00,\n            (sequenceNumber >>> 24) & 0xFF, // sequence_number: int32\n            (sequenceNumber >>> 16) & 0xFF,\n            (sequenceNumber >>> 8) & 0xFF,\n            (sequenceNumber) & 0xFF\n        ]);\n        return MP4.box(MP4.types.mfhd, data);\n    }\n\n    // Track fragment box\n    static traf(track, baseMediaDecodeTime) {\n        const trackId = track.id;\n\n        // Track fragment header box\n        const tfhd = MP4.box(MP4.types.tfhd, new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) & flags\n            (trackId >>> 24) & 0xFF, // track_ID\n            (trackId >>> 16) & 0xFF,\n            (trackId >>> 8) & 0xFF,\n            (trackId) & 0xFF\n        ]));\n        // Track Fragment Decode Time\n        const tfdt = MP4.box(MP4.types.tfdt, new Uint8Array([\n            0x00, 0x00, 0x00, 0x00, // version(0) & flags\n            (baseMediaDecodeTime >>> 24) & 0xFF, // baseMediaDecodeTime: int32\n            (baseMediaDecodeTime >>> 16) & 0xFF,\n            (baseMediaDecodeTime >>> 8) & 0xFF,\n            (baseMediaDecodeTime) & 0xFF\n        ]));\n        const sdtp = MP4.sdtp(track);\n        const trun = MP4.trun(track, sdtp.byteLength + 16 + 16 + 8 + 16 + 8 + 8);\n\n        return MP4.box(MP4.types.traf, tfhd, tfdt, trun, sdtp);\n    }\n\n    // Sample Dependency Type box\n    static sdtp(track) {\n        const samples = track.samples || [];\n        const sampleCount = samples.length;\n        const data = new Uint8Array(4 + sampleCount);\n        // 0~4 bytes: version(0) & flags\n        for (let i = 0; i < sampleCount; i++) {\n            const flags = samples[i].flags;\n            data[i + 4] = (flags.isLeading << 6) // is_leading: 2 (bit)\n                |\n                (flags.dependsOn << 4) // sample_depends_on\n                |\n                (flags.isDependedOn << 2) // sample_is_depended_on\n                |\n                (flags.hasRedundancy); // sample_has_redundancy\n        }\n        return MP4.box(MP4.types.sdtp, data);\n    }\n\n    // Track fragment run box\n    static trun(track, offset) {\n        const samples = track.samples || [];\n        const sampleCount = samples.length;\n        const dataSize = 12 + 16 * sampleCount;\n        const data = new Uint8Array(dataSize);\n        offset += 8 + dataSize;\n\n        data.set([\n            0x00, 0x00, 0x0F, 0x01, // version(0) & flags\n            (sampleCount >>> 24) & 0xFF, // sample_count\n            (sampleCount >>> 16) & 0xFF,\n            (sampleCount >>> 8) & 0xFF,\n            (sampleCount) & 0xFF,\n            (offset >>> 24) & 0xFF, // data_offset\n            (offset >>> 16) & 0xFF,\n            (offset >>> 8) & 0xFF,\n            (offset) & 0xFF\n        ], 0);\n\n        for (let i = 0; i < sampleCount; i++) {\n\n            const duration = samples[i].duration;\n\n            const size = samples[i].size;\n            const flags = samples[i].flags;\n            const cts = samples[i].cts;\n            data.set([\n                (duration >>> 24) & 0xFF, // sample_duration\n                (duration >>> 16) & 0xFF,\n                (duration >>> 8) & 0xFF,\n                (duration) & 0xFF,\n                (size >>> 24) & 0xFF, // sample_size\n                (size >>> 16) & 0xFF,\n                (size >>> 8) & 0xFF,\n                (size) & 0xFF,\n                (flags.isLeading << 2) | flags.dependsOn, // sample_flags\n                (flags.isDependedOn << 6) | (flags.hasRedundancy << 4) | flags.isNonSync,\n                0x00, 0x00, // sample_degradation_priority\n                (cts >>> 24) & 0xFF, // sample_composition_time_offset\n                (cts >>> 16) & 0xFF,\n                (cts >>> 8) & 0xFF,\n                (cts) & 0xFF\n            ], 12 + 16 * i);\n        }\n        return MP4.box(MP4.types.trun, data);\n    }\n\n    static mdat(data) {\n        return MP4.box(MP4.types.mdat, data);\n    }\n\n}\n\nMP4.init();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (MP4);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvbXA0L21wNHJlbXV4LmpzPzFhYTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0EsdUJBQXVCLGdCQUFnQixPQUFPO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLDBEQUEwRCxFQUFFLE9BQU8sbURBQW1EO0FBQ3BKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUgsbUJBQW1CO0FBQ3BJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixzRUFBc0UsRUFBRSxPQUFPLG1EQUFtRDtBQUNoSzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsaUJBQWlCOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDku6PnoIHlgJ/pibTkuoZmbHYuanNcbiAqIOWinuWKoOS6huiHquW3seeahOazqOmHiuWSjOWGmeazlVxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY2xhc3MgTVA0IHtcblxuICAgIHN0YXRpYyBpbml0KCkge1xuICAgICAgICBNUDQudHlwZXMgPSB7XG4gICAgICAgICAgICBhdmMxOiBbXSxcbiAgICAgICAgICAgIGF2Y0M6IFtdLFxuICAgICAgICAgICAgYnRydDogW10sXG4gICAgICAgICAgICBkaW5mOiBbXSxcbiAgICAgICAgICAgIGRyZWY6IFtdLFxuICAgICAgICAgICAgZXNkczogW10sXG4gICAgICAgICAgICBmdHlwOiBbXSxcbiAgICAgICAgICAgIGhkbHI6IFtdLFxuICAgICAgICAgICAgbWRhdDogW10sXG4gICAgICAgICAgICBtZGhkOiBbXSxcbiAgICAgICAgICAgIG1kaWE6IFtdLFxuICAgICAgICAgICAgbWZoZDogW10sXG4gICAgICAgICAgICBtaW5mOiBbXSxcbiAgICAgICAgICAgIG1vb2Y6IFtdLFxuICAgICAgICAgICAgbW9vdjogW10sXG4gICAgICAgICAgICBtcDRhOiBbXSxcbiAgICAgICAgICAgIG12ZXg6IFtdLFxuICAgICAgICAgICAgbXZoZDogW10sXG4gICAgICAgICAgICBzZHRwOiBbXSxcbiAgICAgICAgICAgIHN0Ymw6IFtdLFxuICAgICAgICAgICAgc3RjbzogW10sXG4gICAgICAgICAgICBzdHNjOiBbXSxcbiAgICAgICAgICAgIHN0c2Q6IFtdLFxuICAgICAgICAgICAgc3RzejogW10sXG4gICAgICAgICAgICBzdHRzOiBbXSxcbiAgICAgICAgICAgIHRmZHQ6IFtdLFxuICAgICAgICAgICAgdGZoZDogW10sXG4gICAgICAgICAgICB0cmFmOiBbXSxcbiAgICAgICAgICAgIHRyYWs6IFtdLFxuICAgICAgICAgICAgdHJ1bjogW10sXG4gICAgICAgICAgICB0cmV4OiBbXSxcbiAgICAgICAgICAgIHRraGQ6IFtdLFxuICAgICAgICAgICAgdm1oZDogW10sXG4gICAgICAgICAgICBzbWhkOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBNUDQudHlwZXMpIHtcbiAgICAgICAgICAgIGlmIChNUDQudHlwZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBNUDQudHlwZXNbbmFtZV0gPSBbXG4gICAgICAgICAgICAgICAgICAgIG5hbWUuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZS5jaGFyQ29kZUF0KDEpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLmNoYXJDb2RlQXQoMiksXG4gICAgICAgICAgICAgICAgICAgIG5hbWUuY2hhckNvZGVBdCgzKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb25zdGFudHMgPSBNUDQuY29uc3RhbnRzID0ge307XG5cbiAgICAgICAgY29uc3RhbnRzLkZUWVAgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDY5LCAweDczLCAweDZGLCAweDZELCAvLyBtYWpvcl9icmFuZDogaXNvbVx0XHRpc29tXHRNUDQgIEJhc2UgTWVkaWEgdjEgW0lTMCAxNDQ5Ni0xMjoyMDAzXVx0SVNPXHRZRVNcdHZpZGVvL21wNFxuICAgICAgICAgICAgMHgwLCAweDAsIDB4MCwgMHgxLCAvLyBtaW5vcl92ZXJzaW9uOiAweDAxXG4gICAgICAgICAgICAweDY5LCAweDczLCAweDZGLCAweDZELCAvLyBpc29tXG4gICAgICAgICAgICAweDYxLCAweDc2LCAweDYzLCAweDMxIC8vIGF2YzFcbiAgICAgICAgXSk7XG5cbiAgICAgICAgY29uc3RhbnRzLlNUU0RfUFJFRklYID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdmVyc2lvbigwKSArIGZsYWdzICB2ZXJzaW9u5a2X5q615ZCO5Lya5pyJ5LiA5LiqZW50cnkgY291bnTlrZfmrrVcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEgLy8gZW50cnlfY291bnRcdOagueaNrmVudHJ555qE5Liq5pWw77yM5q+P5LiqZW50cnnkvJrmnIl0eXBl5L+h5oGv77yM5aaC4oCcdmlkZeKAneOAgeKAnHN1bmTigJ3nrYnvvIzmoLnmja50eXBl5LiN5ZCMc2FtcGxlIGRlc2NyaXB0aW9u5Lya5o+Q5L6b5LiN5ZCM55qE5L+h5oGv77yM5L6L5aaC5a+55LqOdmlkZW8gdHJhY2vvvIzkvJrmnInigJxWaXN1YWxTYW1wbGVFbnRyeeKAneexu+Wei+S/oeaBr++8jOWvueS6jmF1ZGlvIHRyYWNr5Lya5pyJ4oCcQXVkaW9TYW1wbGVFbnRyeeKAneexu+Wei+S/oeaBr+OAglxuICAgICAgICBdKTtcblxuICAgICAgICBjb25zdGFudHMuU1RUUyA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHZlcnNpb24oMCkgKyBmbGFnc1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBlbnRyeV9jb3VudCAgICAgMOS4que0ouW8lVxuICAgICAgICBdKTtcblxuICAgICAgICBjb25zdGFudHMuU1RTQyA9IGNvbnN0YW50cy5TVENPID0gY29uc3RhbnRzLlNUVFM7XG5cbiAgICAgICAgY29uc3RhbnRzLlNUU1ogPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyB2ZXJzaW9uKDApICsgZmxhZ3NcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHNhbXBsZV9zaXplXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIHNhbXBsZV9jb3VudFxuICAgICAgICBdKTtcblxuICAgICAgICBjb25zdGFudHMuSERMUl9WSURFTyA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHZlcnNpb24oMCkgKyBmbGFnc1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgICAgICAgIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsIC8vIGhhbmRsZXJfdHlwZTogJ3ZpZGUnIOWcqG1lZGlhIGJveOS4re+8jOivpeWAvOS4ujTkuKrlrZfnrKZcdFx04oCcdmlkZeKAneKAlCB2aWRlbyB0cmFja1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWQ6IDMgKiA0IGJ5dGVzXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8g5L+d55WZ5L2NXG4gICAgICAgICAgICAweDU2LCAweDY5LCAweDY0LCAweDY1LFxuICAgICAgICAgICAgMHg2RiwgMHg0OCwgMHg2MSwgMHg2RSxcbiAgICAgICAgICAgIDB4NjQsIDB4NkMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogVmlkZW9IYW5kbGVyIOmVv+W6puS4jeWumlx0XHR0cmFjayB0eXBlIG5hbWXvvIzku6XigJhcXDDigJnnu5PlsL7nmoTlrZfnrKbkuLJcbiAgICAgICAgXSk7XG5cbiAgICAgICAgY29uc3RhbnRzLkhETFJfQVVESU8gPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyB2ZXJzaW9uKDApICsgZmxhZ3NcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAgICAgICAweDczLCAweDZGLCAweDc1LCAweDZFLCAvLyBoYW5kbGVyX3R5cGU6ICdzb3VuJ+WcqG1lZGlhIGJveOS4re+8jOivpeWAvOS4ujTkuKrlrZfnrKZcdFx04oCcc291buKAneKAlCBhdWRpbyB0cmFja1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWQ6IDMgKiA0IGJ5dGVzXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8g5L+d55WZ5L2NXG4gICAgICAgICAgICAweDUzLCAweDZGLCAweDc1LCAweDZFLFxuICAgICAgICAgICAgMHg2NCwgMHg0OCwgMHg2MSwgMHg2RSxcbiAgICAgICAgICAgIDB4NjQsIDB4NkMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogU291bmRIYW5kbGVyIOmVv+W6puS4jeWumlx0XHR0cmFjayB0eXBlIG5hbWXvvIzku6XigJhcXDDigJnnu5PlsL7nmoTlrZfnrKbkuLJcbiAgICAgICAgXSk7XG5cbiAgICAgICAgY29uc3RhbnRzLkRSRUYgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyB2ZXJzaW9uKDApICsgZmxhZ3NcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGVudHJ5X2NvdW50IDHkuKp1cmxcbiAgICAgICAgICAgIC8vIHVybFx0Ym945byA5aeLXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDBDLCAvLyBlbnRyeV9zaXplXG4gICAgICAgICAgICAweDc1LCAweDcyLCAweDZDLCAweDIwLCAvLyB0eXBlICd1cmwgJ1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSAvLyB2ZXJzaW9uKDApICsgZmxhZ3Mg5b2T4oCcdXJs4oCd5oiW4oCcdXJu4oCd55qEYm94IGZsYWfkuLox5pe277yM5a2X56ym5Liy5Z2H5Li656m644CCXG4gICAgICAgIF0pO1xuXG4gICAgICAgIC8vIFNvdW5kIG1lZGlhIGhlYWRlclxuICAgICAgICBjb25zdGFudHMuU01IRCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHZlcnNpb24oMCkgKyBmbGFnc1x0Ym9454mI5pys77yMMOaIljHvvIzkuIDoiKzkuLow44CCXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIGJhbGFuY2UoMikgKyByZXNlcnZlZCgyKSDnq4vkvZPlo7DlubPooaHvvIxbOC44XSDmoLzlvI/lgLzvvIzkuIDoiKzkuLow77yMLTEuMOihqOekuuWFqOmDqOW3puWjsOmBk++8jDEuMOihqOekuuWFqOmDqOWPs+WjsOmBkysy5L2N5L+d55WZ5L2NXG4gICAgICAgIF0pO1xuXG4gICAgICAgIC8vIHZpZGVvIG1lZGlhIGhlYWRlclxuICAgICAgICBjb25zdGFudHMuVk1IRCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIHZlcnNpb24oMCkgKyBmbGFnc1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgLy8gZ3JhcGhpY3Ntb2RlOiAyIGJ5dGVzIOinhumikeWQiOaIkOaooeW8j++8jOS4ujDml7bmi7fotJ3ljp/lp4vlm77lg4/vvIzlkKbliJnkuI5vcGNvbG9y6L+b6KGM5ZCI5oiQICAgLy/nkIborrrkuIrmmK805L2N5ZWKICDmmoLml7bkv53nlZlcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIG9wY29sb3I6IDMgKiAyIGJ5dGVzIO+9m3JlZO+8jGdyZWVu77yMYmx1Ze+9nVxuICAgICAgICAgICAgMHgwMCwgMHgwMFxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlsIHoo4Vib3hcbiAgICAgKi9cbiAgICBzdGF0aWMgYm94KHR5cGUpIHtcbiAgICAgICAgbGV0IHNpemUgPSA4O1xuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgY29uc3QgZGF0YXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBjb25zdCBhcnJheUNvdW50ID0gZGF0YXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBzaXplICs9IGRhdGFzW2ldLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYm945aS06YOo5aSn5bCPXG4gICAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICByZXN1bHRbMF0gPSAoc2l6ZSA+Pj4gMjQpICYgMHhGRjsgLy8gc2l6ZVxuICAgICAgICByZXN1bHRbMV0gPSAoc2l6ZSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgcmVzdWx0WzJdID0gKHNpemUgPj4+IDgpICYgMHhGRjtcbiAgICAgICAgcmVzdWx0WzNdID0gKHNpemUpICYgMHhGRjtcbiAgICAgICAgLy8g5YaZ5YWlYm9455qEdHlwZVxuICAgICAgICByZXN1bHQuc2V0KHR5cGUsIDQpOyAvLyB0eXBlXG5cbiAgICAgICAgbGV0IG9mZnNldCA9IDg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlDb3VudDsgaSsrKSB7IC8vIGRhdGEgYm9keVxuICAgICAgICAgICAgcmVzdWx0LnNldChkYXRhc1tpXSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSBkYXRhc1tpXS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyDliJvlu7pmdHlwJm1vb3ZcbiAgICBzdGF0aWMgZ2VuZXJhdGVJbml0U2VnbWVudChtZXRhKSB7XG4gICAgICAgIGlmIChtZXRhLmNvbnN0cnVjdG9yICE9IEFycmF5KSB7XG4gICAgICAgICAgICBtZXRhID0gW21ldGFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ0eXAgPSBNUDQuYm94KE1QNC50eXBlcy5mdHlwLCBNUDQuY29uc3RhbnRzLkZUWVApO1xuICAgICAgICBjb25zdCBtb292ID0gTVA0Lm1vb3YobWV0YSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZnR5cC5ieXRlTGVuZ3RoICsgbW9vdi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmVzdWx0LnNldChmdHlwLCAwKTtcbiAgICAgICAgcmVzdWx0LnNldChtb292LCBmdHlwLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIE1vdmllIG1ldGFkYXRhIGJveFxuICAgIHN0YXRpYyBtb292KG1ldGEpIHtcbiAgICAgICAgY29uc3QgbXZoZCA9IE1QNC5tdmhkKG1ldGFbMF0udGltZXNjYWxlLCBtZXRhWzBdLmR1cmF0aW9uKTsgLy8gL21vb3bph4zpnaLnmoTnrKzkuIDkuKpib3hcbiAgICAgICAgY29uc3QgdnRyYWsgPSBNUDQudHJhayhtZXRhWzBdKTtcbiAgICAgICAgbGV0IGF0cmFrO1xuICAgICAgICBpZiAobWV0YS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBhdHJhayA9IE1QNC50cmFrKG1ldGFbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbXZleCA9IE1QNC5tdmV4KG1ldGEpO1xuICAgICAgICBpZiAobWV0YS5sZW5ndGggPiAxKSB7IHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tb292LCBtdmhkLCB2dHJhaywgYXRyYWssIG12ZXgpOyB9IGVsc2UgeyByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubW9vdiwgbXZoZCwgdnRyYWssIG12ZXgpOyB9XG4gICAgfVxuXG4gICAgLy8gTW92aWUgaGVhZGVyIGJveFxuICAgIHN0YXRpYyBtdmhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm12aGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHZlcnNpb24oMCkgKyBmbGFncyAgICAgMeS9jeeahGJveOeJiOacrCsz5L2NZmxhZ3MgICBib3jniYjmnKzvvIww5oiWMe+8jOS4gOiIrOS4ujDjgILvvIjku6XkuIvlrZfoioLmlbDlnYfmjIl2ZXJzaW9uPTDvvIlcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNyZWF0aW9uX3RpbWUgICAg5Yib5bu65pe26Ze0ICDvvIjnm7jlr7nkuo5VVEPml7bpl7QxOTA0LTAxLTAx6Zu254K555qE56eS5pWw77yJXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtb2RpZmljYXRpb25fdGltZSAgIOS/ruaUueaXtumXtFxuICAgICAgICAgICAgKHRpbWVzY2FsZSA+Pj4gMjQpICYgMHhGRiwgLy8gdGltZXNjYWxlOiA0IGJ5dGVzXHRcdOaWh+S7tuWqkuS9k+WcqDHnp5Lml7bpl7TlhoXnmoTliLvluqblgLzvvIzlj6/ku6XnkIbop6PkuLox56eS6ZW/5bqmXG4gICAgICAgICAgICAodGltZXNjYWxlID4+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKHRpbWVzY2FsZSA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgKHRpbWVzY2FsZSkgJiAweEZGLFxuICAgICAgICAgICAgKGR1cmF0aW9uID4+PiAyNCkgJiAweEZGLCAvLyBkdXJhdGlvbjogNCBieXRlc1x06K+ldHJhY2vnmoTml7bpl7Tplb/luqbvvIznlKhkdXJhdGlvbuWSjHRpbWUgc2NhbGXlgLzlj6/ku6XorqHnrpd0cmFja+aXtumVv++8jOavlOWmgmF1ZGlvIHRyYWNr55qEdGltZSBzY2FsZSA9IDgwMDAsIGR1cmF0aW9uID0gNTYwMTI477yM5pe26ZW/5Li6NzAuMDE277yMdmlkZW8gdHJhY2vnmoR0aW1lIHNjYWxlID0gNjAwLCBkdXJhdGlvbiA9IDQyMDAw77yM5pe26ZW/5Li6NzBcbiAgICAgICAgICAgIChkdXJhdGlvbiA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgIChkdXJhdGlvbiA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgKGR1cmF0aW9uKSAmIDB4RkYsXG4gICAgICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAvLyBQcmVmZXJyZWQgcmF0ZTogMS4wICAg5o6o6I2Q5pKt5pS+6YCf546H77yM6auYMTbkvY3lkozkvY4xNuS9jeWIhuWIq+S4uuWwj+aVsOeCueaVtOaVsOmDqOWIhuWSjOWwj+aVsOmDqOWIhu+8jOWNs1sxNi4xNl0g5qC85byP77yM6K+l5YC85Li6MS4w77yIMHgwMDAxMDAwMO+8ieihqOekuuato+W4uOWJjeWQkeaSreaUvlxuICAgICAgICAgICAgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gUHJlZmVycmVkVm9sdW1lKDEuMCwgMmJ5dGVzKSArIHJlc2VydmVkKDJieXRlcylcdOS4jnJhdGXnsbvkvLzvvIxbOC44XSDmoLzlvI/vvIwxLjDvvIgweDAxMDDvvInooajnpLrmnIDlpKfpn7Pph49cbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkOiA0ICsgNCBieXRlc1x05L+d55WZ5L2NXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgLy8gLS0tLWJlZ2luIGNvbXBvc2l0aW9uIG1hdHJpeC0tLS1cbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyDop4bpopHlj5jmjaLnn6npmLUgICDnur/mgKfku6PmlbBcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gLS0tLWVuZCBjb21wb3NpdGlvbiBtYXRyaXgtLS0tXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyAtLS0tYmVnaW4gcHJlX2RlZmluZWQgNiAqIDQgYnl0ZXMtLS0tXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlLWRlZmluZWQg5L+d55WZ5L2NXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIC0tLS1lbmQgcHJlX2RlZmluZWQgNiAqIDQgYnl0ZXMtLS0tXG4gICAgICAgICAgICAweEZGLCAweEZGLCAweEZGLCAweEZGIC8vIG5leHRfdHJhY2tfSUQg5LiL5LiA5LiqdHJhY2vkvb/nlKjnmoRpZOWPt1xuICAgICAgICBdKSk7XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgYm94XG4gICAgc3RhdGljIHRyYWsobWV0YSkge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhaywgTVA0LnRraGQobWV0YSksIE1QNC5tZGlhKG1ldGEpKTtcbiAgICB9XG5cbiAgICAvLyBUcmFjayBoZWFkZXIgYm94XG4gICAgc3RhdGljIHRraGQobWV0YSkge1xuICAgICAgICBsZXQgdHJhY2tJZCA9IG1ldGEuaWQsXG4gICAgICAgICAgICBkdXJhdGlvbiA9IG1ldGEuZHVyYXRpb247XG4gICAgICAgIGxldCB3aWR0aCA9IG1ldGEucHJlc2VudFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gbWV0YS5wcmVzZW50SGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50a2hkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDA3LCAvLyB2ZXJzaW9uKDApICsgZmxhZ3MgMeS9jeeJiOacrCBib3jniYjmnKzvvIww5oiWMe+8jOS4gOiIrOS4ujDjgILvvIjku6XkuIvlrZfoioLmlbDlnYfmjIl2ZXJzaW9uPTDvvInmjInkvY3miJbmk43kvZznu5PmnpzlgLzvvIzpooTlrprkuYnlpoLkuIvvvJpcbiAgICAgICAgICAgIC8vIDB4MDAwMDAxIHRyYWNrX2VuYWJsZWTvvIzlkKbliJnor6V0cmFja+S4jeiiq+aSreaUvu+8m1xuICAgICAgICAgICAgLy8gMHgwMDAwMDIgdHJhY2tfaW5fbW92aWXvvIzooajnpLror6V0cmFja+WcqOaSreaUvuS4reiiq+W8leeUqO+8m1xuICAgICAgICAgICAgLy8gMHgwMDAwMDQgdHJhY2tfaW5fcHJldmlld++8jOihqOekuuivpXRyYWNr5Zyo6aKE6KeI5pe26KKr5byV55So44CCXG4gICAgICAgICAgICAvLyDkuIDoiKzor6XlgLzkuLo377yMMSsyKzQg5aaC5p6c5LiA5Liq5aqS5L2T5omA5pyJdHJhY2vlnYfmnKrorr7nva50cmFja19pbl9tb3ZpZeWSjHRyYWNrX2luX3ByZXZpZXfvvIzlsIbooqvnkIbop6PkuLrmiYDmnIl0cmFja+Wdh+iuvue9ruS6hui/meS4pOmhue+8m+WvueS6jmhpbnQgdHJhY2vvvIzor6XlgLzkuLowXG4gICAgICAgICAgICAvLyBoaW50IHRyYWNrwqAg6L+Z5Liq54m55q6K55qEdHJhY2vlubbkuI3ljIXlkKvlqpLkvZPmlbDmja7vvIzogIzmmK/ljIXlkKvkuobkuIDkupvlsIblhbbku5bmlbDmja50cmFja+aJk+WMheaIkOa1geWqkuS9k+eahOaMh+ekuuS/oeaBr+OAglxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gY3JlYXRpb25fdGltZVx05Yib5bu65pe26Ze077yI55u45a+55LqOVVRD5pe26Ze0MTkwNC0wMS0wMembtueCueeahOenkuaVsO+8iVxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gbW9kaWZpY2F0aW9uX3RpbWVcdOS/ruaUueaXtumXtFxuICAgICAgICAgICAgKHRyYWNrSWQgPj4+IDI0KSAmIDB4RkYsIC8vIHRyYWNrX0lEOiA0IGJ5dGVzXHRpZOWPt++8jOS4jeiDvemHjeWkjeS4lOS4jeiDveS4ujBcbiAgICAgICAgICAgICh0cmFja0lkID4+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKHRyYWNrSWQgPj4+IDgpICYgMHhGRixcbiAgICAgICAgICAgICh0cmFja0lkKSAmIDB4RkYsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDogNCBieXRlcyAgICDkv53nlZnkvY1cbiAgICAgICAgICAgIChkdXJhdGlvbiA+Pj4gMjQpICYgMHhGRiwgLy8gZHVyYXRpb246IDQgYnl0ZXMgIFx0dHJhY2vnmoTml7bpl7Tplb/luqZcbiAgICAgICAgICAgIChkdXJhdGlvbiA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgIChkdXJhdGlvbiA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgKGR1cmF0aW9uKSAmIDB4RkYsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDogMiAqIDQgYnl0ZXMgICAg5L+d55WZ5L2NXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gbGF5ZXIoMmJ5dGVzKSArIGFsdGVybmF0ZV9ncm91cCgyYnl0ZXMpICDop4bpopHlsYLvvIzpu5jorqTkuLow77yM5YC85bCP55qE5Zyo5LiK5bGCLnRyYWNr5YiG57uE5L+h5oGv77yM6buY6K6k5Li6MOihqOekuuivpXRyYWNr5pyq5LiO5YW25LuWdHJhY2vmnInnvqTnu4TlhbPns7tcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHZvbHVtZSgyYnl0ZXMpICsgcmVzZXJ2ZWQoMmJ5dGVzKSAgICBbOC44XSDmoLzlvI/vvIzlpoLmnpzkuLrpn7PpopF0cmFja++8jDEuMO+8iDB4MDEwMO+8ieihqOekuuacgOWkp+mfs+mHj++8m+WQpuWImeS4ujAgICAr5L+d55WZ5L2NXG4gICAgICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAvLyAtLS0tYmVnaW4gY29tcG9zaXRpb24gbWF0cml4LS0tLVxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgLy8g6KeG6aKR5Y+Y5o2i55+p6Zi1XG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyAtLS0tZW5kIGNvbXBvc2l0aW9uIG1hdHJpeC0tLS1cbiAgICAgICAgICAgICh3aWR0aCA+Pj4gOCkgJiAweEZGLCAvLyAvL+WuveW6plxuICAgICAgICAgICAgKHdpZHRoKSAmIDB4RkYsXG4gICAgICAgICAgICAweDAwLCAweDAwLFxuICAgICAgICAgICAgKGhlaWdodCA+Pj4gOCkgJiAweEZGLCAvLyDpq5jluqZcbiAgICAgICAgICAgIChoZWlnaHQpICYgMHhGRixcbiAgICAgICAgICAgIDB4MDAsIDB4MDBcbiAgICAgICAgXSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOKAnG1kaWHigJ3kuZ/mmK/kuKpjb250YWluZXIgYm9477yM5YW25a2QYm9455qE57uT5p6E5ZKM56eN57G76L+Y5piv5q+U6L6D5aSN5p2C55qE44CC5YWI5p2l55yL5LiA5Liq4oCcbWRpYeKAneeahOWunuS+i+e7k+aehOagkeWbvuOAglxuICAgICAqIOaAu+S9k+adpeivtO+8jOKAnG1kaWHigJ3lrprkuYnkuoZ0cmFja+WqkuS9k+exu+Wei+S7peWPinNhbXBsZeaVsOaNru+8jOaPj+i/sHNhbXBsZeS/oeaBr+OAguS4gOiIrOKAnG1kaWHigJ3ljIXlkKvkuIDkuKrigJxtZGhk4oCd77yMXG4gICAgICog5LiA5Liq4oCcaGRscuKAneWSjOS4gOS4quKAnG1pbmbigJ3vvIzlhbbkuK3igJxtZGhk4oCd5Li6bWVkaWEgaGVhZGVyIGJveO+8jOKAnGhkbHLigJ3kuLpoYW5kbGVyIHJlZmVyZW5jZSBib3jvvIxcbiAgICAgKiDigJxtaW5m4oCd5Li6bWVkaWEgaW5mb3JtYXRpb24gYm9444CCXG4gICAgICpcbiAgICAgKiBtZGlhXG4gICAgICogXHRcdG1kaGRcbiAgICAgKiBcdFx0aGRsclxuICAgICAqIFx0XHRtaW5mXG4gICAgICogXHRcdFx0c21oZFxuICAgICAqIFx0XHRcdGRpbmZcbiAgICAgKiBcdFx0XHRcdGRyZWZcbiAgICAgKiBcdFx0XHRcdFx0dXJsXG4gICAgICogXHRcdFx0c3RibFxuICAgICAqIFx0XHRcdFx0c3RzZFxuICAgICAqIFx0XHRcdFx0XHRtcDRhXG4gICAgICogXHRcdFx0XHRcdFx0ZXNkc1xuICAgICAqIFx0XHRcdFx0c3R0c1xuICAgICAqIFx0XHRcdFx0c3RzY1xuICAgICAqIFx0XHRcdFx0c3RzelxuICAgICAqIFx0XHRcdFx0c3Rjb1xuICAgICAqL1xuICAgIHN0YXRpYyBtZGlhKG1ldGEpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaWEsIE1QNC5tZGhkKG1ldGEpLCBNUDQuaGRscihtZXRhKSwgTVA0Lm1pbmYobWV0YSkpO1xuICAgIH1cblxuICAgIC8vIE1lZGlhIGhlYWRlciBib3hcbiAgICBzdGF0aWMgbWRoZChtZXRhKSB7XG4gICAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IG1ldGEudGltZXNjYWxlO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IG1ldGEuZHVyYXRpb247XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGhkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyB2ZXJzaW9uKDApICsgZmxhZ3MgLy8gdmVyc2lvbigwKSArIGZsYWdzXHRcdGJveOeJiOacrO+8jDDmiJYx77yM5LiA6Iis5Li6MOOAglxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gY3JlYXRpb25fdGltZSAgICDliJvlu7rml7bpl7RcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIG1vZGlmaWNhdGlvbl90aW1l5L+u5pS55pe26Ze0XG4gICAgICAgICAgICAodGltZXNjYWxlID4+PiAyNCkgJiAweEZGLCAvLyB0aW1lc2NhbGU6IDQgYnl0ZXMgICAg5paH5Lu25aqS5L2T5ZyoMeenkuaXtumXtOWGheeahOWIu+W6puWAvO+8jOWPr+S7peeQhuino+S4ujHnp5Lplb/luqZcbiAgICAgICAgICAgICh0aW1lc2NhbGUgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAodGltZXNjYWxlID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICAodGltZXNjYWxlKSAmIDB4RkYsXG4gICAgICAgICAgICAoZHVyYXRpb24gPj4+IDI0KSAmIDB4RkYsIC8vIGR1cmF0aW9uOiA0IGJ5dGVzICB0cmFja+eahOaXtumXtOmVv+W6plxuICAgICAgICAgICAgKGR1cmF0aW9uID4+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKGR1cmF0aW9uID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICAoZHVyYXRpb24pICYgMHhGRixcbiAgICAgICAgICAgIDB4NTUsIDB4QzQsIC8vIGxhbmd1YWdlOiB1bmQgKHVuZGV0ZXJtaW5lZCkg5aqS5L2T6K+t6KiA56CB44CC5pyA6auY5L2N5Li6MO+8jOWQjumdojE15L2N5Li6M+S4quWtl+espu+8iOingUlTTyA2MzktMi9U5qCH5YeG5Lit5a6a5LmJ77yJXG4gICAgICAgICAgICAweDAwLCAweDAwIC8vIHByZV9kZWZpbmVkID0gMFxuICAgICAgICBdKSk7XG4gICAgfVxuXG4gICAgLy8gTWVkaWEgaGFuZGxlciByZWZlcmVuY2UgYm94XG4gICAgc3RhdGljIGhkbHIobWV0YSkge1xuICAgICAgICBsZXQgZGF0YSA9IG51bGw7XG4gICAgICAgIGlmIChtZXRhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIGRhdGEgPSBNUDQuY29uc3RhbnRzLkhETFJfQVVESU87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gTVA0LmNvbnN0YW50cy5IRExSX1ZJREVPO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5oZGxyLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcblx0XHQgKiDigJxtaW5m4oCd5a2Y5YKo5LqG6Kej6YeKdHJhY2vlqpLkvZPmlbDmja7nmoRoYW5kbGVyLXNwZWNpZmlj5L+h5oGv77yMbWVkaWEgaGFuZGxlcueUqOi/meS6m+S/oeaBr+WwhuWqkuS9k+aXtumXtOaYoOWwhOWIsOWqkuS9k+aVsOaNruW5tui/m+ihjOWkhOeQhuOAguKAnG1pbmbigJ3kuK3nmoTkv6Hmga/moLzlvI/lkozlhoXlrrnkuI7lqpLkvZPnsbvlnovku6Xlj4rop6Pph4rlqpLkvZPmlbDmja7nmoRtZWRpYSBoYW5kbGVy5a+G5YiH55u45YWz77yM5YW25LuWbWVkaWEgaGFuZGxlcuS4jeefpemBk+WmguS9leino+mHiui/meS6m+S/oeaBr+OAguKAnG1pbmbigJ3mmK/kuIDkuKpjb250YWluZXIgYm9477yM5YW25a6e6ZmF5YaF5a6555Sx5a2QYm946K+05piO44CCXG7CoMKgwqAg5LiA6Iis5oOF5Ya15LiL77yM4oCcbWluZuKAneWMheWQq+S4gOS4qmhlYWRlciBib3jvvIzkuIDkuKrigJxkaW5m4oCd5ZKM5LiA5Liq4oCcc3RibOKAne+8jOWFtuS4re+8jGhlYWRlciBib3jmoLnmja50cmFjayB0eXBl77yI5Y2zbWVkaWEgaGFuZGxlciB0eXBl77yJ5YiG5Li64oCcdm1oZOKAneOAgeKAnHNtaGTigJ3jgIHigJxobWhk4oCd5ZKM4oCcbm1oZOKAne+8jOKAnGRpbmbigJ3kuLpkYXRhIGluZm9ybWF0aW9uIGJveO+8jOKAnHN0YmzigJ3kuLpzYW1wbGUgdGFibGUgYm9444CC5LiL6Z2i5YiG5Yir5LuL57uN44CCXG5cblx0XHQgKlxuXHRcdCAqL1xuICAgIC8vIE1lZGlhIGluZm9tYXRpb24gYm94XG4gICAgc3RhdGljIG1pbmYobWV0YSkge1xuICAgICAgICAvLyBoZWFkZXIgYm945qC55o2udHJhY2sgdHlwZe+8iOWNs21lZGlhIGhhbmRsZXIgdHlwZe+8ieWIhuS4uuKAnHZtaGTigJ3jgIHigJxzbWhk4oCd44CB4oCcaG1oZOKAneWSjOKAnG5taGTigJ1cbiAgICAgICAgbGV0IHhtaGQgPSBudWxsO1xuICAgICAgICBpZiAobWV0YS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB4bWhkID0gTVA0LmJveChNUDQudHlwZXMuc21oZCwgTVA0LmNvbnN0YW50cy5TTUhEKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhtaGQgPSBNUDQuYm94KE1QNC50eXBlcy52bWhkLCBNUDQuY29uc3RhbnRzLlZNSEQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCB4bWhkLCBNUDQuZGluZigpLCBNUDQuc3RibChtZXRhKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGF0YSBJbmZvcm1hdGlvbiBCb3hcbiAgICAgKiDigJxkaW5m4oCd6Kej6YeK5aaC5L2V5a6a5L2N5aqS5L2T5L+h5oGv77yM5piv5LiA5LiqY29udGFpbmVyIGJveOOAguKAnGRpbmbigJ3kuIDoiKzljIXlkKvkuIDkuKrigJxkcmVm4oCd77yM5Y2zZGF0YSByZWZlcmVuY2UgYm9477ybXG4gICAgICog4oCcZHJlZuKAneS4i+S8muWMheWQq+iLpeW5suS4quKAnHVybOKAneaIluKAnHVybuKAne+8jOi/meS6m2JveOe7hOaIkOS4gOS4quihqO+8jOeUqOadpeWumuS9jXRyYWNr5pWw5o2u44CCXG4gICAgICog566A5Y2V55qE6K+077yMdHJhY2vlj6/ku6XooqvliIbmiJDoi6XlubLmrrXvvIzmr4/kuIDmrrXpg73lj6/ku6XmoLnmja7igJx1cmzigJ3miJbigJx1cm7igJ3mjIflkJHnmoTlnLDlnYDmnaXojrflj5bmlbDmja7vvIxcbiAgICAgKiBzYW1wbGXmj4/ov7DkuK3kvJrnlKjov5nkupvniYfmrrXnmoTluo/lj7flsIbov5nkupvniYfmrrXnu4TmiJDkuIDkuKrlrozmlbTnmoR0cmFja+OAglxuICAgICAqIOS4gOiIrOaDheWGteS4i++8jOW9k+aVsOaNruiiq+WujOWFqOWMheWQq+WcqOaWh+S7tuS4reaXtu+8jOKAnHVybOKAneaIluKAnHVybuKAneS4reeahOWumuS9jeWtl+espuS4suaYr+epuueahOOAglxuICAgICAqL1xuICAgIHN0YXRpYyBkaW5mKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBNUDQuYm94KE1QNC50eXBlcy5kaW5mLFxuICAgICAgICAgICAgTVA0LmJveChNUDQudHlwZXMuZHJlZiwgTVA0LmNvbnN0YW50cy5EUkVGKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuXHRcdCAqIFNhbXBsZSBUYWJsZSBCb3jvvIhzdGJs77yJXG7CoMKgwqAgXHQqXHTigJxzdGJs4oCd5Yeg5LmO5piv5pmu6YCa55qETVA05paH5Lu25Lit5pyA5aSN5p2C55qE5LiA5LiqYm945LqG77yM6aaW5YWI6ZyA6KaB5Zue5b+G5LiA5LiLc2FtcGxl55qE5qaC5b+144CCXG4gXHRcdCogXHRzYW1wbGXmmK/lqpLkvZPmlbDmja7lrZjlgqjnmoTljZXkvY3vvIzlrZjlgqjlnKhtZWRpYeeahGNodW5r5Lit77yMY2h1bmvlkoxzYW1wbGXnmoTplb/luqblnYflj6/kupLkuI3nm7jlkIzvvIzlpoLkuIvlm77miYDnpLrjgIJcblx0XHRcdOKAnHN0YmzigJ3mmK/kuIDkuKpjb250YWluZXIgYm9477yM5YW25a2QYm945YyF5ous77yac2FtcGxlIGRlc2NyaXB0aW9uIGJveO+8iHN0c2TvvInjgIFcblx0XHRcdCAqIHRpbWUgdG8gc2FtcGxlIGJveO+8iHN0dHPvvInjgIFzYW1wbGUgc2l6ZSBib3jvvIhzdHN65oiWc3R6Mu+8ieOAgVxuXHRcdFx0ICogc2FtcGxlIHRvIGNodW5rIGJveO+8iHN0c2PvvInjgIFjaHVuayBvZmZzZXQgYm9477yIc3Rjb+aIlmNvNjTvvInjgIFcblx0XHRcdCAqIGNvbXBvc2l0aW9uIHRpbWUgdG8gc2FtcGxlIGJveO+8iGN0dHPvvInjgIFzeW5jIHNhbXBsZSBib3jvvIhzdHNz77yJXG5cdFx0XHQgKiBzdHNk4oCd5b+F5LiN5Y+v5bCR77yM5LiU6Iez5bCR5YyF5ZCr5LiA5Liq5p2h55uu77yM6K+lYm945YyF5ZCr5LqGZGF0YSByZWZlcmVuY2UgYm946L+b6KGMc2FtcGxl5pWw5o2u5qOA57Si55qE5L+h5oGv44CCXG5cdFx0XHQgKiDmsqHmnInigJxzdHNk4oCd5bCx5peg5rOV6K6h566XbWVkaWEgc2FtcGxl55qE5a2Y5YKo5L2N572u44CC4oCcc3RzZOKAneWMheWQq+S6hue8lueggeeahOS/oeaBr++8jOWFtuWtmOWCqOeahOS/oeaBr+maj+WqkuS9k+exu+Wei+S4jeWQjOiAjOS4jeWQjOOAglxuXHRcdFx0ICogXHRcdFx0c3RibFxuXHRcdFx0ICogXHRcdFx0XHRzdHNkXG5cdFx0XHQgKiBcdFx0XHRcdFx0YXZjMVxuXHRcdFx0ICogXHRcdFx0XHRcdFx0YXZjQ1xuXHRcdFx0ICogXHRcdFx0XHRzdHRzXG5cdFx0XHQgKiBcdFx0XHRcdHN0c2Ncblx0XHRcdCAqIFx0XHRcdFx0c3RzelxuXHRcdFx0ICogXHRcdFx0XHRzdGNvXG5cdFx0ICovXG4gICAgc3RhdGljIHN0YmwobWV0YSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBNUDQuYm94KE1QNC50eXBlcy5zdGJsLCAvLyB0eXBlOiBzdGJsXG4gICAgICAgICAgICBNUDQuc3RzZChtZXRhKSwgLy8gU2FtcGxlIERlc2NyaXB0aW9uIFRhYmxlXG4gICAgICAgICAgICBNUDQuYm94KE1QNC50eXBlcy5zdHRzLCBNUDQuY29uc3RhbnRzLlNUVFMpLCAvLyBUaW1lLVRvLVNhbXBsZSAgICDlm6DkuLpzdHRz55qEZW50cnkgY291bnQg5Li6MFxuICAgICAgICAgICAgLy8g5omA5Lul5rKh5pyJ5YWz6ZSu5binaW5kZXgg55qEc3Rzc1xuICAgICAgICAgICAgLy8g5Lmf5rKh5pyJQ1RUUyBib3ggQ1RUU+aYr+iusOW9leWBj+enu+mHj1xuICAgICAgICAgICAgTVA0LmJveChNUDQudHlwZXMuc3RzYywgTVA0LmNvbnN0YW50cy5TVFNDKSwgLy8gU2FtcGxlLVRvLUNodW5rXG4gICAgICAgICAgICBNUDQuYm94KE1QNC50eXBlcy5zdHN6LCBNUDQuY29uc3RhbnRzLlNUU1opLCAvLyBTYW1wbGUgc2l6ZVxuICAgICAgICAgICAgTVA0LmJveChNUDQudHlwZXMuc3RjbywgTVA0LmNvbnN0YW50cy5TVENPKSAvLyBDaHVuayBvZmZzZXRcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcblx0XHQgKiBTYW1wbGUgRGVzY3JpcHRpb24gQm9477yIc3RzZO+8iVxuwqDCoMKgwqBcdFx0Ym94IGhlYWRlcuWSjHZlcnNpb27lrZfmrrXlkI7kvJrmnInkuIDkuKplbnRyeSBjb3VudOWtl+aute+8jFxuICogXHRcdFx05qC55o2uZW50cnnnmoTkuKrmlbDvvIzmr4/kuKplbnRyeeS8muaciXR5cGXkv6Hmga/vvIzlpoLigJx2aWRl4oCd44CB4oCcc3VuZOKAneetie+8jFxuICogXHRcdOagueaNrnR5cGXkuI3lkIxzYW1wbGUgZGVzY3JpcHRpb27kvJrmj5DkvpvkuI3lkIznmoTkv6Hmga/vvIzkvovlpoLlr7nkuo52aWRlbyB0cmFja++8jFxuICog5Lya5pyJ4oCcVmlzdWFsU2FtcGxlRW50cnnigJ3nsbvlnovkv6Hmga/vvIzlr7nkuo5hdWRpbyB0cmFja+S8muacieKAnEF1ZGlvU2FtcGxlRW50cnnigJ3nsbvlnovkv6Hmga/jgIJcblxuXHRcdCAqICogXHRcdFx0XHRzdHNkXG5cdFx0XHQqIFx0XHRcdFx0XHRtcDRhXG5cdFx0XHQqIFx0XHRcdFx0XHRcdGVzZHNcblx0XHRcdCAqXG5cdFx0XHQgKlxuXHRcdFx0ICpcblx0XHRcdCAqXG5cdFx0XHQgKiBcdFx0IDQgYnl0ZXMgLSBsZW5ndGggaW4gdG90YWxcblx0XHRcdFx0XHQgNCBieXRlcyAtIDQgY2hhciBjb2RlIG9mIHNhbXBsZSBkZXNjcmlwdGlvbiB0YWJsZSAoc3RzZClcblx0XHRcdFx0XHQgNCBieXRlcyAtIHZlcnNpb24gJiBmbGFnc1xuXHRcdFx0XHRcdCA0IGJ5dGVzIC0gbnVtYmVyIG9mIHNhbXBsZSBlbnRyaWVzIChudW1fc2FtcGxlX2VudHJpZXMpXG5cdFx0XHRcdFx0XHQgW1xuXHRcdFx0XHRcdFx0ICAgIDQgYnl0ZXMgLSBsZW5ndGggb2Ygc2FtcGxlIGVudHJ5IChsZW5fc2FtcGxlX2VudHJ5KVxuXHRcdFx0XHRcdFx0ICAgIDQgYnl0ZXMgLSA0IGNoYXIgY29kZSBvZiBzYW1wbGUgZW50cnlcblx0XHRcdFx0XHRcdCAgICAoJ2xlbl9zYW1wbGVfZW50cnknIC0gOCkgYnl0ZXMgb2YgZGF0YVxuXHRcdFx0XHRcdFx0IF0gKHJlcGVhdGVkICdudW1fc2FtcGxlX2VudHJpZXMnIHRpbWVzKVxuXHRcdFx0XHRcdCg0IGJ5dGVzIC0gb3B0aW9uYWwgMHgwMDAwMDAwMCBhcyBlbmQgb2YgYm94IG1hcmtlciApXG5cdFx0ICovXG4gICAgc3RhdGljIHN0c2QobWV0YSkge1xuICAgICAgICBpZiAobWV0YS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LmNvbnN0YW50cy5TVFNEX1BSRUZJWCwgTVA0Lm1wNGEobWV0YSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5jb25zdGFudHMuU1RTRF9QUkVGSVgsIE1QNC5hdmMxKG1ldGEpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBtcDRhKG1ldGEpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbENvdW50ID0gbWV0YS5jaGFubmVsQ291bnQ7XG4gICAgICAgIGNvbnN0IHNhbXBsZVJhdGUgPSBtZXRhLmF1ZGlvU2FtcGxlUmF0ZTtcblxuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWQoNCkgNuS4quWtl+iKgu+8jOiuvue9ruS4ujDvvJtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIHJlc2VydmVkKDIpICsgZGF0YV9yZWZlcmVuY2VfaW5kZXgoMilcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkOiAyICogNCBieXRlcyDkv53nlZnkvY1cbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCBjaGFubmVsQ291bnQsIC8vIGNoYW5uZWxDb3VudCgyKSDljZXlo7DpgZPov5jmmK/lj4zlo7DpgZNcbiAgICAgICAgICAgIDB4MDAsIDB4MTAsIC8vIHNhbXBsZVNpemUoMilcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkKDQpIDTlrZfoioLkv53nlZnkvY1cbiAgICAgICAgICAgIChzYW1wbGVSYXRlID4+PiA4KSAmIDB4RkYsIC8vIEF1ZGlvIHNhbXBsZSByYXRlIOaYvueEtuimgeWPs+enuzE25L2N5omN5pyJ5oSP5LmJXHR0ZW1wbGF0ZSB1bnNpZ25lZCBpbnQoMzIpIHNhbXBsZXJhdGUgPSB7dGltZXNjYWxlIG9mIG1lZGlhfTw8MTY7XG4gICAgICAgICAgICAoc2FtcGxlUmF0ZSkgJiAweEZGLFxuICAgICAgICAgICAgMHgwMCwgMHgwMFxuICAgICAgICBdKTtcblxuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXA0YSwgZGF0YSwgTVA0LmVzZHMobWV0YSkpO1xuICAgIH1cblxuICAgIHN0YXRpYyBlc2RzKG1ldGEpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gbWV0YS5jb25maWc7XG4gICAgICAgIGNvbnN0IGNvbmZpZ1NpemUgPSBjb25maWcubGVuZ3RoO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdmVyc2lvbiAwICsgZmxhZ3NcblxuICAgICAgICAgICAgMHgwMywgLy8gZGVzY3JpcHRvcl90eXBlICAgIE1QNEVTRGVzY3JUYWdcbiAgICAgICAgICAgIDB4MTcgKyBjb25maWdTaXplLCAvLyBsZW5ndGgzXG4gICAgICAgICAgICAweDAwLCAweDAxLCAvLyBlc19pZFxuICAgICAgICAgICAgMHgwMCwgLy8gc3RyZWFtX3ByaW9yaXR5XG5cbiAgICAgICAgICAgIDB4MDQsIC8vIGRlc2NyaXB0b3JfdHlwZSAgICBNUDREZWNDb25maWdEZXNjclRhZ1xuICAgICAgICAgICAgMHgwRiArIGNvbmZpZ1NpemUsIC8vIGxlbmd0aFxuICAgICAgICAgICAgMHg0MCwgLy8gY29kZWM6IG1wZWc0X2F1ZGlvXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAq5b2Tb2JqZWN0VHlwZUluZGljYXRpb27kuLoweDQw5pe277yM5Li6TVBFRy00IEF1ZGlv77yITVBFRy00IEF1ZGlvIGdlbmVyYWxseSBpcyB0aG91Z2h0IG9mIGFzIEFBQ1xuICAgICAgICAgICAgICogYnV0IHRoZXJlIGlzIGEgd2hvbGUgZnJhbWV3b3JrIG9mIGF1ZGlvIGNvZGVjcyB0aGF0IGNhbiBHbyBpbiBNUEVHLTQgQXVkaW8gaW5jbHVkaW5nIEFBQywgQlNBQywgQUxTLCBDRUxQLFxuICAgICAgICAgICAgICogYW5kIHNvbWV0aGluZyBjYWxsZWQgTVAzT24077yJ77yM5aaC5p6c5oOz5pu057uG5YiGZm9ybWF05Li6YWFj6L+Y5pivbXAz77yMXG4gICAgICAgICAgICAgKiDlj6/ku6Xor7vlj5ZNUDREZWNTcGVjaWZpY0Rlc2Ny5bGCZGF0YVswXeeahOWJjeS6lOS9jVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAweDE1LCAvLyBzdHJlYW1fdHlwZTogQXVkaW9cbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGJ1ZmZlcl9zaXplXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtYXhCaXRyYXRlXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBhdmdCaXRyYXRlXG5cbiAgICAgICAgICAgIDB4MDUgLy8gZGVzY3JpcHRvcl90eXBlIE1QNERlY1NwZWNpZmljRGVzY3JUYWdcbiAgICAgICAgXS5jb25jYXQoW1xuICAgICAgICAgICAgY29uZmlnU2l6ZVxuICAgICAgICBdKS5jb25jYXQoXG4gICAgICAgICAgICBjb25maWdcbiAgICAgICAgKS5jb25jYXQoW1xuICAgICAgICAgICAgMHgwNiwgMHgwMSwgMHgwMiAvLyBHQVNwZWNpZmljQ29uZmlnXG4gICAgICAgIF0pKTtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmVzZHMsIGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaUueeJiFxuICAgICAqc3RzZOS4i+eahGF2YzHop4bpopHop6PmnpBcbiAgICAgKi9cbiAgICBzdGF0aWMgYXZjMShtZXRhKSB7XG4gICAgICAgIGNvbnN0IGF2Y2MgPSBtZXRhLmF2Y2M7XG4gICAgICAgIGxldCB3aWR0aCA9IG1ldGEuY29kZWNXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IG1ldGEuY29kZWNIZWlnaHQ7XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIC8vIHJlc2VydmVkKDQpICAgIDbkuKrCoOS/neeVmeS9jVx0UmVzZXJ2ZWTvvJo25Liq5a2X6IqC77yM6K6+572u5Li6MO+8m1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gcmVzZXJ2ZWQoMikgKyB7e3t7ZGF0YV9yZWZlcmVuY2VfaW5kZXgoMikgIOaVsOaNruW8leeUqOe0ouW8lX19fX1cbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkKDIpICsgcmVzZXJ2ZWQoMilcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkOiAzICogNCBieXRlcyAgMyo05Liq5a2X6IqC55qE5L+d55WZ5L2NXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgICh3aWR0aCA+Pj4gOCkgJiAweEZGLCAvLyB3aWR0aDogMiBieXRlc1xuICAgICAgICAgICAgKHdpZHRoKSAmIDB4RkYsXG4gICAgICAgICAgICAoaGVpZ2h0ID4+PiA4KSAmIDB4RkYsIC8vIGhlaWdodDogMiBieXRlc1xuICAgICAgICAgICAgKGhlaWdodCkgJiAweEZGLFxuICAgICAgICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCwgLy8gaG9yaXpyZXNvbHV0aW9uOiA0IGJ5dGVzIOW4uOaVsFxuICAgICAgICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCwgLy8gdmVydHJlc29sdXRpb246IDQgYnl0ZXMg5bi45pWwXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDogNCBieXRlcyDkv53nlZnkvY1cbiAgICAgICAgICAgIDB4MDAsIDB4MDEsIC8vIGZyYW1lX2NvdW50XG4gICAgICAgICAgICAvLyBmcmFtZV9jb3VudOihqOaYjuWkmuWwkeW4p+WOi+e8qeinhumikeWtmOWCqOWcqOavj+S4quagt+acrOOAgum7mOiupOaYrzEs5q+P5qC35LiA5binO+Wug+WPr+iDvei2hei/hzHmr4/kuKrmoLfmnKznmoTlpJrkuKrluKfmlbBcbiAgICAgICAgICAgIDB4MDQsIC8vXHRzdHJsZW4gY29tcHJlc3Nvcm5hbWU6IDMyIGJ5dGVzXHRcdFx0U3RyaW5nWzMyXVxuICAgICAgICAgICAgLy8gMzLkuKo4IGJpdCAgICDnrKzkuIDkuKo4Yml06KGo56S66ZW/5bqmLOWJqeS4izMx5LiqOGJpdOihqOekuuWGheWuuVxuICAgICAgICAgICAgMHg2NywgMHgzMSwgMHgzMSwgMHgzMSwgLy8gY29tcHJlc3Nvcm5hbWU6IDMyIGJ5dGVzICAgIOe/u+ivkei/h+adpeaYr2cxMTFcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvL1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDE4LCAvLyBkZXB0aCDpopzoibLmt7HluqZcbiAgICAgICAgICAgIDB4RkYsIDB4RkYgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmF2YzEsIGRhdGEsIE1QNC5ib3goTVA0LnR5cGVzLmF2Y0MsIGF2Y2MpKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZpZSBFeHRlbmRzIGJveFxuICAgIHN0YXRpYyBtdmV4KG1ldGEpIHtcbiAgICAgICAgaWYgKG1ldGEubGVuZ3RoID4gMSkgeyByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXZleCwgTVA0LnRyZXgobWV0YVswXSksIE1QNC50cmV4KG1ldGFbMV0pKTsgfSBlbHNlIHsgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm12ZXgsIE1QNC50cmV4KG1ldGFbMF0pKTsgfVxuICAgIH1cblxuICAgIC8vIFRyYWNrIEV4dGVuZHMgYm94XG4gICAgc3RhdGljIHRyZXgobWV0YSkge1xuICAgICAgICBjb25zdCB0cmFja0lkID0gbWV0YS5pZDtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHZlcnNpb24oMCkgKyBmbGFnc1xuICAgICAgICAgICAgKHRyYWNrSWQgPj4+IDI0KSAmIDB4RkYsIC8vIHRyYWNrX0lEXG4gICAgICAgICAgICAodHJhY2tJZCA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgICh0cmFja0lkID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICAodHJhY2tJZCkgJiAweEZGLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9zaXplXG4gICAgICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAxIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBpZiAobWV0YS50eXBlICE9PSAndmlkZW8nKSB7XG4gICAgICAgIC8vICAgICBkYXRhW2RhdGEubGVuZ3RoIC0gMV0gPSAweDAwO1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmV4LCBkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZpZSBmcmFnbWVudCBib3hcbiAgICBzdGF0aWMgbW9vZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubW9vZiwgTVA0Lm1maGQodHJhY2suc2VxdWVuY2VOdW1iZXIpLCBNUDQudHJhZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkpO1xuICAgIH1cblxuICAgIHN0YXRpYyBtZmhkKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgKHNlcXVlbmNlTnVtYmVyID4+PiAyNCkgJiAweEZGLCAvLyBzZXF1ZW5jZV9udW1iZXI6IGludDMyXG4gICAgICAgICAgICAoc2VxdWVuY2VOdW1iZXIgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAoc2VxdWVuY2VOdW1iZXIgPj4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIChzZXF1ZW5jZU51bWJlcikgJiAweEZGXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWZoZCwgZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgZnJhZ21lbnQgYm94XG4gICAgc3RhdGljIHRyYWYodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpIHtcbiAgICAgICAgY29uc3QgdHJhY2tJZCA9IHRyYWNrLmlkO1xuXG4gICAgICAgIC8vIFRyYWNrIGZyYWdtZW50IGhlYWRlciBib3hcbiAgICAgICAgY29uc3QgdGZoZCA9IE1QNC5ib3goTVA0LnR5cGVzLnRmaGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHZlcnNpb24oMCkgJiBmbGFnc1xuICAgICAgICAgICAgKHRyYWNrSWQgPj4+IDI0KSAmIDB4RkYsIC8vIHRyYWNrX0lEXG4gICAgICAgICAgICAodHJhY2tJZCA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgICh0cmFja0lkID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICAodHJhY2tJZCkgJiAweEZGXG4gICAgICAgIF0pKTtcbiAgICAgICAgLy8gVHJhY2sgRnJhZ21lbnQgRGVjb2RlIFRpbWVcbiAgICAgICAgY29uc3QgdGZkdCA9IE1QNC5ib3goTVA0LnR5cGVzLnRmZHQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHZlcnNpb24oMCkgJiBmbGFnc1xuICAgICAgICAgICAgKGJhc2VNZWRpYURlY29kZVRpbWUgPj4+IDI0KSAmIDB4RkYsIC8vIGJhc2VNZWRpYURlY29kZVRpbWU6IGludDMyXG4gICAgICAgICAgICAoYmFzZU1lZGlhRGVjb2RlVGltZSA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgIChiYXNlTWVkaWFEZWNvZGVUaW1lID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICAoYmFzZU1lZGlhRGVjb2RlVGltZSkgJiAweEZGXG4gICAgICAgIF0pKTtcbiAgICAgICAgY29uc3Qgc2R0cCA9IE1QNC5zZHRwKHRyYWNrKTtcbiAgICAgICAgY29uc3QgdHJ1biA9IE1QNC50cnVuKHRyYWNrLCBzZHRwLmJ5dGVMZW5ndGggKyAxNiArIDE2ICsgOCArIDE2ICsgOCArIDgpO1xuXG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFmLCB0ZmhkLCB0ZmR0LCB0cnVuLCBzZHRwKTtcbiAgICB9XG5cbiAgICAvLyBTYW1wbGUgRGVwZW5kZW5jeSBUeXBlIGJveFxuICAgIHN0YXRpYyBzZHRwKHRyYWNrKSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdO1xuICAgICAgICBjb25zdCBzYW1wbGVDb3VudCA9IHNhbXBsZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoNCArIHNhbXBsZUNvdW50KTtcbiAgICAgICAgLy8gMH40IGJ5dGVzOiB2ZXJzaW9uKDApICYgZmxhZ3NcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IHNhbXBsZXNbaV0uZmxhZ3M7XG4gICAgICAgICAgICBkYXRhW2kgKyA0XSA9IChmbGFncy5pc0xlYWRpbmcgPDwgNikgLy8gaXNfbGVhZGluZzogMiAoYml0KVxuICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAoZmxhZ3MuZGVwZW5kc09uIDw8IDQpIC8vIHNhbXBsZV9kZXBlbmRzX29uXG4gICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgIChmbGFncy5pc0RlcGVuZGVkT24gPDwgMikgLy8gc2FtcGxlX2lzX2RlcGVuZGVkX29uXG4gICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgIChmbGFncy5oYXNSZWR1bmRhbmN5KTsgLy8gc2FtcGxlX2hhc19yZWR1bmRhbmN5XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnNkdHAsIGRhdGEpO1xuICAgIH1cblxuICAgIC8vIFRyYWNrIGZyYWdtZW50IHJ1biBib3hcbiAgICBzdGF0aWMgdHJ1bih0cmFjaywgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdO1xuICAgICAgICBjb25zdCBzYW1wbGVDb3VudCA9IHNhbXBsZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBkYXRhU2l6ZSA9IDEyICsgMTYgKiBzYW1wbGVDb3VudDtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGFTaXplKTtcbiAgICAgICAgb2Zmc2V0ICs9IDggKyBkYXRhU2l6ZTtcblxuICAgICAgICBkYXRhLnNldChbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDBGLCAweDAxLCAvLyB2ZXJzaW9uKDApICYgZmxhZ3NcbiAgICAgICAgICAgIChzYW1wbGVDb3VudCA+Pj4gMjQpICYgMHhGRiwgLy8gc2FtcGxlX2NvdW50XG4gICAgICAgICAgICAoc2FtcGxlQ291bnQgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAoc2FtcGxlQ291bnQgPj4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIChzYW1wbGVDb3VudCkgJiAweEZGLFxuICAgICAgICAgICAgKG9mZnNldCA+Pj4gMjQpICYgMHhGRiwgLy8gZGF0YV9vZmZzZXRcbiAgICAgICAgICAgIChvZmZzZXQgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAob2Zmc2V0ID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICAob2Zmc2V0KSAmIDB4RkZcbiAgICAgICAgXSwgMCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVDb3VudDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gc2FtcGxlc1tpXS5kdXJhdGlvbjtcblxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHNhbXBsZXNbaV0uc2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gc2FtcGxlc1tpXS5mbGFncztcbiAgICAgICAgICAgIGNvbnN0IGN0cyA9IHNhbXBsZXNbaV0uY3RzO1xuICAgICAgICAgICAgZGF0YS5zZXQoW1xuICAgICAgICAgICAgICAgIChkdXJhdGlvbiA+Pj4gMjQpICYgMHhGRiwgLy8gc2FtcGxlX2R1cmF0aW9uXG4gICAgICAgICAgICAgICAgKGR1cmF0aW9uID4+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgICAgIChkdXJhdGlvbiA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgICAgIChkdXJhdGlvbikgJiAweEZGLFxuICAgICAgICAgICAgICAgIChzaXplID4+PiAyNCkgJiAweEZGLCAvLyBzYW1wbGVfc2l6ZVxuICAgICAgICAgICAgICAgIChzaXplID4+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgICAgIChzaXplID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICAgICAgKHNpemUpICYgMHhGRixcbiAgICAgICAgICAgICAgICAoZmxhZ3MuaXNMZWFkaW5nIDw8IDIpIHwgZmxhZ3MuZGVwZW5kc09uLCAvLyBzYW1wbGVfZmxhZ3NcbiAgICAgICAgICAgICAgICAoZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDYpIHwgKGZsYWdzLmhhc1JlZHVuZGFuY3kgPDwgNCkgfCBmbGFncy5pc05vblN5bmMsXG4gICAgICAgICAgICAgICAgMHgwMCwgMHgwMCwgLy8gc2FtcGxlX2RlZ3JhZGF0aW9uX3ByaW9yaXR5XG4gICAgICAgICAgICAgICAgKGN0cyA+Pj4gMjQpICYgMHhGRiwgLy8gc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICAgICAgICAgICAgKGN0cyA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgICAgICAoY3RzID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICAgICAgKGN0cykgJiAweEZGXG4gICAgICAgICAgICBdLCAxMiArIDE2ICogaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRydW4sIGRhdGEpO1xuICAgIH1cblxuICAgIHN0YXRpYyBtZGF0KGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kYXQsIGRhdGEpO1xuICAgIH1cblxufVxuXG5NUDQuaW5pdCgpO1xuXG5leHBvcnQgZGVmYXVsdCBNUDQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvbXA0L21wNHJlbXV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _chimeeFlv2fmp = __webpack_require__(5);\n\nvar _chimeeFlv2fmp2 = _interopRequireDefault(_chimeeFlv2fmp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar temp = new _chimeeFlv2fmp2.default(); /* eslint-disable */\n\nwindow.flvParse = {\n    mp4File: null,\n    succ: null,\n    // ftyp_moov:null,\n    tracks: [],\n    baseTime: 0,\n    setFlv: function setFlv(uint8, baseTime) {\n        if (flvParse.baseTime != baseTime) {\n            flvParse.baseTime = baseTime;\n            temp.seek(baseTime);\n        }\n        if (window.mp4Init) {\n            temp.onInitSegment = window.mp4Init;\n        }\n        if (window.onMediaSegment) {\n            temp.onMediaSegment = window.onMediaSegment;\n        }\n        if (window.seekCallBack) {\n            // temp.seekCallBack = window.se\n            temp.seekCallBack = window.seekCallBack;\n        }\n        if (window.onMediaInfo) {\n            temp.onMediaInfo = window.onMediaInfo;\n        }\n        return temp.setflv(uint8.buffer, baseTime);\n\n        // 用来获取moov\n    },\n    setLocFlv: function setLocFlv(uin8) {\n        return temp.setflvloc(uin8);\n    }\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9mbHZFbnRlci5qcz9iZGJiIl0sIm5hbWVzIjpbInRlbXAiLCJ3aW5kb3ciLCJmbHZQYXJzZSIsIm1wNEZpbGUiLCJzdWNjIiwidHJhY2tzIiwiYmFzZVRpbWUiLCJzZXRGbHYiLCJ1aW50OCIsInNlZWsiLCJtcDRJbml0Iiwib25Jbml0U2VnbWVudCIsIm9uTWVkaWFTZWdtZW50Iiwic2Vla0NhbGxCYWNrIiwib25NZWRpYUluZm8iLCJzZXRmbHYiLCJidWZmZXIiLCJzZXRMb2NGbHYiLCJ1aW44Iiwic2V0Zmx2bG9jIl0sIm1hcHBpbmdzIjoiOztBQUVBOzs7Ozs7QUFFQSxJQUFNQSxPQUFPLDZCQUFiLEMsQ0FKQTs7QUFNQUMsT0FBT0MsUUFBUCxHQUFrQjtBQUNkQyxhQUFTLElBREs7QUFFZEMsVUFBTSxJQUZRO0FBR2Q7QUFDQUMsWUFBUSxFQUpNO0FBS2RDLGNBQVUsQ0FMSTtBQU1kQyxVQU5jLGtCQU1QQyxLQU5PLEVBTUFGLFFBTkEsRUFNVTtBQUNwQixZQUFJSixTQUFTSSxRQUFULElBQXFCQSxRQUF6QixFQUFtQztBQUMvQkoscUJBQVNJLFFBQVQsR0FBb0JBLFFBQXBCO0FBQ0FOLGlCQUFLUyxJQUFMLENBQVVILFFBQVY7QUFDSDtBQUNELFlBQUlMLE9BQU9TLE9BQVgsRUFBb0I7QUFDaEJWLGlCQUFLVyxhQUFMLEdBQXFCVixPQUFPUyxPQUE1QjtBQUNIO0FBQ0QsWUFBSVQsT0FBT1csY0FBWCxFQUEyQjtBQUN2QlosaUJBQUtZLGNBQUwsR0FBc0JYLE9BQU9XLGNBQTdCO0FBQ0g7QUFDRCxZQUFJWCxPQUFPWSxZQUFYLEVBQXlCO0FBQ3JCO0FBQ0FiLGlCQUFLYSxZQUFMLEdBQW9CWixPQUFPWSxZQUEzQjtBQUNIO0FBQ0QsWUFBSVosT0FBT2EsV0FBWCxFQUF3QjtBQUNwQmQsaUJBQUtjLFdBQUwsR0FBbUJiLE9BQU9hLFdBQTFCO0FBQ0g7QUFDRCxlQUFPZCxLQUFLZSxNQUFMLENBQVlQLE1BQU1RLE1BQWxCLEVBQTBCVixRQUExQixDQUFQOztBQUVBO0FBRUgsS0E1QmE7QUE2QmRXLGFBN0JjLHFCQTZCSkMsSUE3QkksRUE2QkU7QUFDWixlQUFPbEIsS0FBS21CLFNBQUwsQ0FBZUQsSUFBZixDQUFQO0FBQ0g7QUEvQmEsQ0FBbEIiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5cbmltcG9ydCBmMm0gZnJvbSAnY2hpbWVlLWZsdjJmbXA0JztcblxuY29uc3QgdGVtcCA9IG5ldyBmMm0oKTtcblxud2luZG93LmZsdlBhcnNlID0ge1xuICAgIG1wNEZpbGU6IG51bGwsXG4gICAgc3VjYzogbnVsbCxcbiAgICAvLyBmdHlwX21vb3Y6bnVsbCxcbiAgICB0cmFja3M6IFtdLFxuICAgIGJhc2VUaW1lOiAwLFxuICAgIHNldEZsdih1aW50OCwgYmFzZVRpbWUpIHtcbiAgICAgICAgaWYgKGZsdlBhcnNlLmJhc2VUaW1lICE9IGJhc2VUaW1lKSB7XG4gICAgICAgICAgICBmbHZQYXJzZS5iYXNlVGltZSA9IGJhc2VUaW1lO1xuICAgICAgICAgICAgdGVtcC5zZWVrKGJhc2VUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2luZG93Lm1wNEluaXQpIHtcbiAgICAgICAgICAgIHRlbXAub25Jbml0U2VnbWVudCA9IHdpbmRvdy5tcDRJbml0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aW5kb3cub25NZWRpYVNlZ21lbnQpIHtcbiAgICAgICAgICAgIHRlbXAub25NZWRpYVNlZ21lbnQgPSB3aW5kb3cub25NZWRpYVNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbmRvdy5zZWVrQ2FsbEJhY2spIHtcbiAgICAgICAgICAgIC8vIHRlbXAuc2Vla0NhbGxCYWNrID0gd2luZG93LnNlXG4gICAgICAgICAgICB0ZW1wLnNlZWtDYWxsQmFjayA9IHdpbmRvdy5zZWVrQ2FsbEJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbmRvdy5vbk1lZGlhSW5mbykge1xuICAgICAgICAgICAgdGVtcC5vbk1lZGlhSW5mbyA9IHdpbmRvdy5vbk1lZGlhSW5mbztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVtcC5zZXRmbHYodWludDguYnVmZmVyLCBiYXNlVGltZSk7XG5cbiAgICAgICAgLy8g55So5p2l6I635Y+WbW9vdlxuXG4gICAgfSxcbiAgICBzZXRMb2NGbHYodWluOCkge1xuICAgICAgICByZXR1cm4gdGVtcC5zZXRmbHZsb2ModWluOCk7XG4gICAgfVxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9qcy9mbHZFbnRlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_flv2fmp4_js__ = __webpack_require__(12);\n\n// module.ex cpu;\nmodule.exports=__WEBPACK_IMPORTED_MODULE_0__lib_flv2fmp4_js__[\"a\" /* default */];\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(18)(module)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9pbmRleC5qcz9kYzdiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBLGlGIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3B1IGZyb20gJy4vbGliL2ZsdjJmbXA0LmpzJztcbi8vIG1vZHVsZS5leCBjcHU7XG5tb2R1bGUuZXhwb3J0cz1jcHU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NoaW1lZS1mbHYyZm1wNC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* eslint-disable */\nfunction decodeUTF8(uint8array) {\n    const out = [];\n    const input = uint8array;\n    let i = 0;\n    const length = uint8array.length;\n\n    while (i < length) {\n        if (input[i] < 0x80) {\n            out.push(String.fromCharCode(input[i]));\n            ++i;\n            continue;\n        } else if (input[i] < 0xC0) {\n            // fallthrough\n        } else if (input[i] < 0xE0) {\n            if (checkContinuation(input, i, 1)) {\n                const ucs4 = (input[i] & 0x1F) << 6 | (input[i + 1] & 0x3F);\n                if (ucs4 >= 0x80) {\n                    out.push(String.fromCharCode(ucs4 & 0xFFFF));\n                    i += 2;\n                    continue;\n                }\n            }\n        } else if (input[i] < 0xF0) {\n            if (checkContinuation(input, i, 2)) {\n                const ucs4 = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F;\n                if (ucs4 >= 0x800 && (ucs4 & 0xF800) !== 0xD800) {\n                    out.push(String.fromCharCode(ucs4 & 0xFFFF));\n                    i += 3;\n                    continue;\n                }\n            }\n        } else if (input[i] < 0xF8) {\n            if (checkContinuation(input, i, 3)) {\n                let ucs4 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12 |\n                    (input[i + 2] & 0x3F) << 6 | (input[i + 3] & 0x3F);\n                if (ucs4 > 0x10000 && ucs4 < 0x110000) {\n                    ucs4 -= 0x10000;\n                    out.push(String.fromCharCode((ucs4 >>> 10) | 0xD800));\n                    out.push(String.fromCharCode((ucs4 & 0x3FF) | 0xDC00));\n                    i += 4;\n                    continue;\n                }\n            }\n        }\n        out.push(String.fromCharCode(0xFFFD));\n        ++i;\n    }\n\n    return out.join('');\n}\n\nfunction checkContinuation(uint8array, start, checkLength) {\n    let array = uint8array;\n    if (start + checkLength < array.length) {\n        while (checkLength--) {\n            if ((array[++start] & 0xC0) !== 0x80)\n                return false;\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n/* harmony default export */ __webpack_exports__[\"a\"] = (decodeUTF8);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvZGVjb2RlVVRGOC5qcz85ZDVmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuZnVuY3Rpb24gZGVjb2RlVVRGOCh1aW50OGFycmF5KSB7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgY29uc3QgaW5wdXQgPSB1aW50OGFycmF5O1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsZW5ndGggPSB1aW50OGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChpbnB1dFtpXSA8IDB4ODApIHtcbiAgICAgICAgICAgIG91dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaW5wdXRbaV0pKTtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0W2ldIDwgMHhDMCkge1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dFtpXSA8IDB4RTApIHtcbiAgICAgICAgICAgIGlmIChjaGVja0NvbnRpbnVhdGlvbihpbnB1dCwgaSwgMSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1Y3M0ID0gKGlucHV0W2ldICYgMHgxRikgPDwgNiB8IChpbnB1dFtpICsgMV0gJiAweDNGKTtcbiAgICAgICAgICAgICAgICBpZiAodWNzNCA+PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUodWNzNCAmIDB4RkZGRikpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dFtpXSA8IDB4RjApIHtcbiAgICAgICAgICAgIGlmIChjaGVja0NvbnRpbnVhdGlvbihpbnB1dCwgaSwgMikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1Y3M0ID0gKGlucHV0W2ldICYgMHhGKSA8PCAxMiB8IChpbnB1dFtpICsgMV0gJiAweDNGKSA8PCA2IHwgaW5wdXRbaSArIDJdICYgMHgzRjtcbiAgICAgICAgICAgICAgICBpZiAodWNzNCA+PSAweDgwMCAmJiAodWNzNCAmIDB4RjgwMCkgIT09IDB4RDgwMCkge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHVjczQgJiAweEZGRkYpKTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRbaV0gPCAweEY4KSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tDb250aW51YXRpb24oaW5wdXQsIGksIDMpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHVjczQgPSAoaW5wdXRbaV0gJiAweDcpIDw8IDE4IHwgKGlucHV0W2kgKyAxXSAmIDB4M0YpIDw8IDEyIHxcbiAgICAgICAgICAgICAgICAgICAgKGlucHV0W2kgKyAyXSAmIDB4M0YpIDw8IDYgfCAoaW5wdXRbaSArIDNdICYgMHgzRik7XG4gICAgICAgICAgICAgICAgaWYgKHVjczQgPiAweDEwMDAwICYmIHVjczQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICB1Y3M0IC09IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoKHVjczQgPj4+IDEwKSB8IDB4RDgwMCkpO1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKCh1Y3M0ICYgMHgzRkYpIHwgMHhEQzAwKSk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSk7XG4gICAgICAgICsraTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBjaGVja0NvbnRpbnVhdGlvbih1aW50OGFycmF5LCBzdGFydCwgY2hlY2tMZW5ndGgpIHtcbiAgICBsZXQgYXJyYXkgPSB1aW50OGFycmF5O1xuICAgIGlmIChzdGFydCArIGNoZWNrTGVuZ3RoIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChjaGVja0xlbmd0aC0tKSB7XG4gICAgICAgICAgICBpZiAoKGFycmF5Wysrc3RhcnRdICYgMHhDMCkgIT09IDB4ODApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBkZWNvZGVVVEY4O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jaGltZWUtZmx2MmZtcDQvbGliL2RlY29kZVVURjguanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/**\n * reference flv.js\n */\n/* eslint-disable */\n// Exponential-Golomb buffer decoder\nclass ExpGolomb {\n\n    constructor(uint8array) {\n        this.TAG = this.constructor.name;\n\n        this._buffer = uint8array;\n        this._buffer_index = 0;\n        this._total_bytes = uint8array.byteLength;\n        this._total_bits = uint8array.byteLength * 8;\n        this._current_word = 0;\n        this._current_word_bits_left = 0;\n    }\n\n    destroy() {\n        this._buffer = null;\n    }\n\n    _fillCurrentWord() {\n        const buffer_bytes_left = this._total_bytes - this._buffer_index;\n        if (buffer_bytes_left <= 0) { throw new IllegalStateException('ExpGolomb: _fillCurrentWord() but no bytes available'); }\n\n        const bytes_read = Math.min(4, buffer_bytes_left);\n        const word = new Uint8Array(4);\n        word.set(this._buffer.subarray(this._buffer_index, this._buffer_index + bytes_read));\n        this._current_word = new DataView(word.buffer).getUint32(0, false);\n\n        this._buffer_index += bytes_read;\n        this._current_word_bits_left = bytes_read * 8;\n    }\n\n    readBits(bits) {\n        if (bits > 32) { throw new InvalidArgumentException('ExpGolomb: readBits() bits exceeded max 32bits!'); }\n\n        if (bits <= this._current_word_bits_left) {\n            const result = this._current_word >>> (32 - bits);\n            this._current_word <<= bits;\n            this._current_word_bits_left -= bits;\n            return result;\n        }\n\n        let result = this._current_word_bits_left ? this._current_word : 0;\n        result = result >>> (32 - this._current_word_bits_left);\n        const bits_need_left = bits - this._current_word_bits_left;\n\n        this._fillCurrentWord();\n        const bits_read_next = Math.min(bits_need_left, this._current_word_bits_left);\n\n        const result2 = this._current_word >>> (32 - bits_read_next);\n        this._current_word <<= bits_read_next;\n        this._current_word_bits_left -= bits_read_next;\n\n        result = (result << bits_read_next) | result2;\n        return result;\n    }\n\n    readBool() {\n        return this.readBits(1) === 1;\n    }\n\n    readByte() {\n        return this.readBits(8);\n    }\n\n    _skipLeadingZero() {\n        let zero_count;\n        for (zero_count = 0; zero_count < this._current_word_bits_left; zero_count++) {\n            if ((this._current_word & (0x80000000 >>> zero_count)) !== 0) {\n                this._current_word <<= zero_count;\n                this._current_word_bits_left -= zero_count;\n                return zero_count;\n            }\n        }\n        this._fillCurrentWord();\n        return zero_count + this._skipLeadingZero();\n    }\n\n    readUEG() { // unsigned exponential golomb\n        const leading_zeros = this._skipLeadingZero();\n        return this.readBits(leading_zeros + 1) - 1;\n    }\n\n    readSEG() { // signed exponential golomb\n        const value = this.readUEG();\n        if (value & 0x01) {\n            return (value + 1) >>> 1;\n        } else {\n            return -1 * (value >>> 1);\n        }\n    }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ExpGolomb);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvZmx2L2V4cC1nb2xvbWIuanM/MTQ2YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyx5RkFBeUY7O0FBRTlIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qix1RkFBdUY7O0FBRS9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QiwyQ0FBMkM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcmVmZXJlbmNlIGZsdi5qc1xuICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gRXhwb25lbnRpYWwtR29sb21iIGJ1ZmZlciBkZWNvZGVyXG5jbGFzcyBFeHBHb2xvbWIge1xuXG4gICAgY29uc3RydWN0b3IodWludDhhcnJheSkge1xuICAgICAgICB0aGlzLlRBRyA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcblxuICAgICAgICB0aGlzLl9idWZmZXIgPSB1aW50OGFycmF5O1xuICAgICAgICB0aGlzLl9idWZmZXJfaW5kZXggPSAwO1xuICAgICAgICB0aGlzLl90b3RhbF9ieXRlcyA9IHVpbnQ4YXJyYXkuYnl0ZUxlbmd0aDtcbiAgICAgICAgdGhpcy5fdG90YWxfYml0cyA9IHVpbnQ4YXJyYXkuYnl0ZUxlbmd0aCAqIDg7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRfd29yZCA9IDA7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRfd29yZF9iaXRzX2xlZnQgPSAwO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG4gICAgfVxuXG4gICAgX2ZpbGxDdXJyZW50V29yZCgpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyX2J5dGVzX2xlZnQgPSB0aGlzLl90b3RhbF9ieXRlcyAtIHRoaXMuX2J1ZmZlcl9pbmRleDtcbiAgICAgICAgaWYgKGJ1ZmZlcl9ieXRlc19sZWZ0IDw9IDApIHsgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbignRXhwR29sb21iOiBfZmlsbEN1cnJlbnRXb3JkKCkgYnV0IG5vIGJ5dGVzIGF2YWlsYWJsZScpOyB9XG5cbiAgICAgICAgY29uc3QgYnl0ZXNfcmVhZCA9IE1hdGgubWluKDQsIGJ1ZmZlcl9ieXRlc19sZWZ0KTtcbiAgICAgICAgY29uc3Qgd29yZCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICB3b3JkLnNldCh0aGlzLl9idWZmZXIuc3ViYXJyYXkodGhpcy5fYnVmZmVyX2luZGV4LCB0aGlzLl9idWZmZXJfaW5kZXggKyBieXRlc19yZWFkKSk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRfd29yZCA9IG5ldyBEYXRhVmlldyh3b3JkLmJ1ZmZlcikuZ2V0VWludDMyKDAsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLl9idWZmZXJfaW5kZXggKz0gYnl0ZXNfcmVhZDtcbiAgICAgICAgdGhpcy5fY3VycmVudF93b3JkX2JpdHNfbGVmdCA9IGJ5dGVzX3JlYWQgKiA4O1xuICAgIH1cblxuICAgIHJlYWRCaXRzKGJpdHMpIHtcbiAgICAgICAgaWYgKGJpdHMgPiAzMikgeyB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKCdFeHBHb2xvbWI6IHJlYWRCaXRzKCkgYml0cyBleGNlZWRlZCBtYXggMzJiaXRzIScpOyB9XG5cbiAgICAgICAgaWYgKGJpdHMgPD0gdGhpcy5fY3VycmVudF93b3JkX2JpdHNfbGVmdCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fY3VycmVudF93b3JkID4+PiAoMzIgLSBiaXRzKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRfd29yZCA8PD0gYml0cztcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRfd29yZF9iaXRzX2xlZnQgLT0gYml0cztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fY3VycmVudF93b3JkX2JpdHNfbGVmdCA/IHRoaXMuX2N1cnJlbnRfd29yZCA6IDA7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCA+Pj4gKDMyIC0gdGhpcy5fY3VycmVudF93b3JkX2JpdHNfbGVmdCk7XG4gICAgICAgIGNvbnN0IGJpdHNfbmVlZF9sZWZ0ID0gYml0cyAtIHRoaXMuX2N1cnJlbnRfd29yZF9iaXRzX2xlZnQ7XG5cbiAgICAgICAgdGhpcy5fZmlsbEN1cnJlbnRXb3JkKCk7XG4gICAgICAgIGNvbnN0IGJpdHNfcmVhZF9uZXh0ID0gTWF0aC5taW4oYml0c19uZWVkX2xlZnQsIHRoaXMuX2N1cnJlbnRfd29yZF9iaXRzX2xlZnQpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdDIgPSB0aGlzLl9jdXJyZW50X3dvcmQgPj4+ICgzMiAtIGJpdHNfcmVhZF9uZXh0KTtcbiAgICAgICAgdGhpcy5fY3VycmVudF93b3JkIDw8PSBiaXRzX3JlYWRfbmV4dDtcbiAgICAgICAgdGhpcy5fY3VycmVudF93b3JkX2JpdHNfbGVmdCAtPSBiaXRzX3JlYWRfbmV4dDtcblxuICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IGJpdHNfcmVhZF9uZXh0KSB8IHJlc3VsdDI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVhZEJvb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDEpID09PSAxO1xuICAgIH1cblxuICAgIHJlYWRCeXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkQml0cyg4KTtcbiAgICB9XG5cbiAgICBfc2tpcExlYWRpbmdaZXJvKCkge1xuICAgICAgICBsZXQgemVyb19jb3VudDtcbiAgICAgICAgZm9yICh6ZXJvX2NvdW50ID0gMDsgemVyb19jb3VudCA8IHRoaXMuX2N1cnJlbnRfd29yZF9iaXRzX2xlZnQ7IHplcm9fY291bnQrKykge1xuICAgICAgICAgICAgaWYgKCh0aGlzLl9jdXJyZW50X3dvcmQgJiAoMHg4MDAwMDAwMCA+Pj4gemVyb19jb3VudCkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudF93b3JkIDw8PSB6ZXJvX2NvdW50O1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRfd29yZF9iaXRzX2xlZnQgLT0gemVyb19jb3VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb19jb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maWxsQ3VycmVudFdvcmQoKTtcbiAgICAgICAgcmV0dXJuIHplcm9fY291bnQgKyB0aGlzLl9za2lwTGVhZGluZ1plcm8oKTtcbiAgICB9XG5cbiAgICByZWFkVUVHKCkgeyAvLyB1bnNpZ25lZCBleHBvbmVudGlhbCBnb2xvbWJcbiAgICAgICAgY29uc3QgbGVhZGluZ196ZXJvcyA9IHRoaXMuX3NraXBMZWFkaW5nWmVybygpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkQml0cyhsZWFkaW5nX3plcm9zICsgMSkgLSAxO1xuICAgIH1cblxuICAgIHJlYWRTRUcoKSB7IC8vIHNpZ25lZCBleHBvbmVudGlhbCBnb2xvbWJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlYWRVRUcoKTtcbiAgICAgICAgaWYgKHZhbHVlICYgMHgwMSkge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSArIDEpID4+PiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xICogKHZhbHVlID4+PiAxKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBFeHBHb2xvbWI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvZmx2L2V4cC1nb2xvbWIuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flvTag_js__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tagdemux__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_error__ = __webpack_require__(0);\n/* eslint-disable */\n\n\n\nclass FlvParse {\n    constructor() {\n        this.tempUint8 = new Uint8Array();\n        this.arrTag = [];\n        this.index = 0;\n        this.tempArr = [];\n        this.stop = false;\n        this.offset = 0;\n        this.frist = true;\n        this._hasAudio = false;\n        this._hasVideo = false;\n    }\n\n    /**\n     * 接受 外部的flv二进制数据\n     */\n    setFlv(uint8) {\n        this.stop = false;\n        this.arrTag = [];\n        this.index = 0;\n        this.tempUint8 = uint8;\n        if (this.tempUint8.length > 13 && this.tempUint8[0] == 70 && this.tempUint8[1] == 76 && this.tempUint8[2] == 86) {\n            this.probe(this.tempUint8.buffer);\n            this.read(9); // 略掉9个字节的flv header tag\n            this.read(4); // 略掉第一个4字节的 tag size\n            this.parse();\n            this.frist = false;\n            return this.offset;\n        } else if (!this.frist) {\n            return this.parse();\n        } else {\n            return this.offset;\n        }\n    }\n    probe(buffer) {\n        const data = new Uint8Array(buffer);\n        const mismatch = { match: false };\n\n        if (data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01) {\n            return mismatch;\n        }\n\n        const hasAudio = ((data[4] & 4) >>> 2) !== 0;\n        const hasVideo = (data[4] & 1) !== 0;\n\n        if (!hasAudio && !hasVideo) {\n            return mismatch;\n        }\n        this._hasAudio = __WEBPACK_IMPORTED_MODULE_1__tagdemux__[\"a\" /* default */]._hasAudio = hasAudio;\n        this._hasVideo = __WEBPACK_IMPORTED_MODULE_1__tagdemux__[\"a\" /* default */]._hasVideo = hasVideo;\n        return {\n            match: true,\n            hasAudioTrack: hasAudio,\n            hasVideoTrack: hasVideo\n        };\n    }\n\n    /**\n     * 开始解析\n     */\n    parse() {\n\n        while (this.index < this.tempUint8.length && !this.stop) {\n            this.offset = this.index;\n\n            const t = new __WEBPACK_IMPORTED_MODULE_0__flvTag_js__[\"a\" /* default */]();\n            if (this.tempUint8.length - this.index >= 11) {\n                t.tagType = (this.read(1)[0]); // 取出tag类型\n                t.dataSize = this.read(3); // 取出包体大小\n                t.Timestamp = this.read(4); // 取出解码时间\n                t.StreamID = this.read(3); // 取出stream id\n            } else {\n                this.stop = true;\n                continue;\n            }\n            if (t.tagType == 18 || t.tagType == 8 || t.tagType == 9) {\n\n            } else {\n                throw new __WEBPACK_IMPORTED_MODULE_2__utils_error__[\"a\" /* default */]('wrong tagType' + t.tagType);\n            }\n            if (this.tempUint8.length - this.index >= (this.getBodySum(t.dataSize) + 4)) {\n                t.body = this.read(this.getBodySum(t.dataSize)); // 取出body\n                if (t.tagType == 9 && this._hasVideo) {\n                    this.arrTag.push(t);\n                }\n                if (t.tagType == 8 && this._hasAudio) {\n                    this.arrTag.push(t);\n                }\n                if (t.tagType == 18) {\n                    this.arrTag.push(t);\n                }\n                this.read(4);\n            } else {\n                this.stop = true;\n                continue;\n            }\n            this.offset = this.index;\n        }\n\n        return this.offset;\n    }\n    read(length) {\n        // let u8a = new Uint8Array(length);\n        // u8a.set(this.tempUint8.subarray(this.index, this.index + length), 0);\n        const u8a = this.tempUint8.slice(this.index, this.index + length);\n        this.index += length;\n        return u8a;\n    }\n\n    /**\n     * 计算tag包体大小\n     */\n    getBodySum(arr) {\n        let _str = '';\n        _str += (arr[0].toString(16).length == 1 ? '0' + arr[0].toString(16) : arr[0].toString(16));\n        _str += (arr[1].toString(16).length == 1 ? '0' + arr[1].toString(16) : arr[1].toString(16));\n        _str += (arr[2].toString(16).length == 1 ? '0' + arr[2].toString(16) : arr[2].toString(16));\n        return parseInt(_str, 16);\n    }\n}\n/* harmony default export */ __webpack_exports__[\"a\"] = (new FlvParse());//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvZmx2L2ZsdlBhcnNlLmpzPzY4YTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQywwQ0FBMEM7QUFDMUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHRhZyBmcm9tICcuL2ZsdlRhZy5qcyc7XG5pbXBvcnQgdGFnZGVtdXggZnJvbSAnLi90YWdkZW11eCc7XG5pbXBvcnQgZXJyb3IgZnJvbSAnLi4vdXRpbHMvZXJyb3InXG5jbGFzcyBGbHZQYXJzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudGVtcFVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgdGhpcy5hcnJUYWcgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMudGVtcEFyciA9IFtdO1xuICAgICAgICB0aGlzLnN0b3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmZyaXN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faGFzQXVkaW8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGFzVmlkZW8gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmjqXlj5cg5aSW6YOo55qEZmx25LqM6L+b5Yi25pWw5o2uXG4gICAgICovXG4gICAgc2V0Rmx2KHVpbnQ4KSB7XG4gICAgICAgIHRoaXMuc3RvcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFyclRhZyA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy50ZW1wVWludDggPSB1aW50ODtcbiAgICAgICAgaWYgKHRoaXMudGVtcFVpbnQ4Lmxlbmd0aCA+IDEzICYmIHRoaXMudGVtcFVpbnQ4WzBdID09IDcwICYmIHRoaXMudGVtcFVpbnQ4WzFdID09IDc2ICYmIHRoaXMudGVtcFVpbnQ4WzJdID09IDg2KSB7XG4gICAgICAgICAgICB0aGlzLnByb2JlKHRoaXMudGVtcFVpbnQ4LmJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLnJlYWQoOSk7IC8vIOeVpeaOiTnkuKrlrZfoioLnmoRmbHYgaGVhZGVyIHRhZ1xuICAgICAgICAgICAgdGhpcy5yZWFkKDQpOyAvLyDnlaXmjonnrKzkuIDkuKo05a2X6IqC55qEIHRhZyBzaXplXG4gICAgICAgICAgICB0aGlzLnBhcnNlKCk7XG4gICAgICAgICAgICB0aGlzLmZyaXN0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuZnJpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvYmUoYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICBjb25zdCBtaXNtYXRjaCA9IHsgbWF0Y2g6IGZhbHNlIH07XG5cbiAgICAgICAgaWYgKGRhdGFbMF0gIT09IDB4NDYgfHwgZGF0YVsxXSAhPT0gMHg0QyB8fCBkYXRhWzJdICE9PSAweDU2IHx8IGRhdGFbM10gIT09IDB4MDEpIHtcbiAgICAgICAgICAgIHJldHVybiBtaXNtYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhhc0F1ZGlvID0gKChkYXRhWzRdICYgNCkgPj4+IDIpICE9PSAwO1xuICAgICAgICBjb25zdCBoYXNWaWRlbyA9IChkYXRhWzRdICYgMSkgIT09IDA7XG5cbiAgICAgICAgaWYgKCFoYXNBdWRpbyAmJiAhaGFzVmlkZW8pIHtcbiAgICAgICAgICAgIHJldHVybiBtaXNtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oYXNBdWRpbyA9IHRhZ2RlbXV4Ll9oYXNBdWRpbyA9IGhhc0F1ZGlvO1xuICAgICAgICB0aGlzLl9oYXNWaWRlbyA9IHRhZ2RlbXV4Ll9oYXNWaWRlbyA9IGhhc1ZpZGVvO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF0Y2g6IHRydWUsXG4gICAgICAgICAgICBoYXNBdWRpb1RyYWNrOiBoYXNBdWRpbyxcbiAgICAgICAgICAgIGhhc1ZpZGVvVHJhY2s6IGhhc1ZpZGVvXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5byA5aeL6Kej5p6QXG4gICAgICovXG4gICAgcGFyc2UoKSB7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRlbXBVaW50OC5sZW5ndGggJiYgIXRoaXMuc3RvcCkge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLmluZGV4O1xuXG4gICAgICAgICAgICBjb25zdCB0ID0gbmV3IHRhZygpO1xuICAgICAgICAgICAgaWYgKHRoaXMudGVtcFVpbnQ4Lmxlbmd0aCAtIHRoaXMuaW5kZXggPj0gMTEpIHtcbiAgICAgICAgICAgICAgICB0LnRhZ1R5cGUgPSAodGhpcy5yZWFkKDEpWzBdKTsgLy8g5Y+W5Ye6dGFn57G75Z6LXG4gICAgICAgICAgICAgICAgdC5kYXRhU2l6ZSA9IHRoaXMucmVhZCgzKTsgLy8g5Y+W5Ye65YyF5L2T5aSn5bCPXG4gICAgICAgICAgICAgICAgdC5UaW1lc3RhbXAgPSB0aGlzLnJlYWQoNCk7IC8vIOWPluWHuuino+eggeaXtumXtFxuICAgICAgICAgICAgICAgIHQuU3RyZWFtSUQgPSB0aGlzLnJlYWQoMyk7IC8vIOWPluWHunN0cmVhbSBpZFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQudGFnVHlwZSA9PSAxOCB8fCB0LnRhZ1R5cGUgPT0gOCB8fCB0LnRhZ1R5cGUgPT0gOSkge1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcignd3JvbmcgdGFnVHlwZScgKyB0LnRhZ1R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudGVtcFVpbnQ4Lmxlbmd0aCAtIHRoaXMuaW5kZXggPj0gKHRoaXMuZ2V0Qm9keVN1bSh0LmRhdGFTaXplKSArIDQpKSB7XG4gICAgICAgICAgICAgICAgdC5ib2R5ID0gdGhpcy5yZWFkKHRoaXMuZ2V0Qm9keVN1bSh0LmRhdGFTaXplKSk7IC8vIOWPluWHumJvZHlcbiAgICAgICAgICAgICAgICBpZiAodC50YWdUeXBlID09IDkgJiYgdGhpcy5faGFzVmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnJUYWcucHVzaCh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQudGFnVHlwZSA9PSA4ICYmIHRoaXMuX2hhc0F1ZGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJyVGFnLnB1c2godCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0LnRhZ1R5cGUgPT0gMTgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnJUYWcucHVzaCh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkKDQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLmluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0O1xuICAgIH1cbiAgICByZWFkKGxlbmd0aCkge1xuICAgICAgICAvLyBsZXQgdThhID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICAgICAgLy8gdThhLnNldCh0aGlzLnRlbXBVaW50OC5zdWJhcnJheSh0aGlzLmluZGV4LCB0aGlzLmluZGV4ICsgbGVuZ3RoKSwgMCk7XG4gICAgICAgIGNvbnN0IHU4YSA9IHRoaXMudGVtcFVpbnQ4LnNsaWNlKHRoaXMuaW5kZXgsIHRoaXMuaW5kZXggKyBsZW5ndGgpO1xuICAgICAgICB0aGlzLmluZGV4ICs9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHU4YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpd0YWfljIXkvZPlpKflsI9cbiAgICAgKi9cbiAgICBnZXRCb2R5U3VtKGFycikge1xuICAgICAgICBsZXQgX3N0ciA9ICcnO1xuICAgICAgICBfc3RyICs9IChhcnJbMF0udG9TdHJpbmcoMTYpLmxlbmd0aCA9PSAxID8gJzAnICsgYXJyWzBdLnRvU3RyaW5nKDE2KSA6IGFyclswXS50b1N0cmluZygxNikpO1xuICAgICAgICBfc3RyICs9IChhcnJbMV0udG9TdHJpbmcoMTYpLmxlbmd0aCA9PSAxID8gJzAnICsgYXJyWzFdLnRvU3RyaW5nKDE2KSA6IGFyclsxXS50b1N0cmluZygxNikpO1xuICAgICAgICBfc3RyICs9IChhcnJbMl0udG9TdHJpbmcoMTYpLmxlbmd0aCA9PSAxID8gJzAnICsgYXJyWzJdLnRvU3RyaW5nKDE2KSA6IGFyclsyXS50b1N0cmluZygxNikpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoX3N0ciwgMTYpO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IG5ldyBGbHZQYXJzZSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jaGltZWUtZmx2MmZtcDQvbGliL2Zsdi9mbHZQYXJzZS5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* eslint-disable */\nclass FlvTag {\n    constructor() {\n        this.tagType = -1;\n        this.dataSize = -1;\n        this.Timestamp = -1;\n        this.StreamID = -1;\n        this.body = -1;\n        this.time = -1;\n        this.arr = [];\n    }\n    getTime() {\n        // this.Timestamp.pop();\n        this.arr = [];\n        for (let i = 0; i < this.Timestamp.length; i++) {\n            this.arr.push((this.Timestamp[i].toString(16).length == 1 ? '0' + this.Timestamp[i].toString(16) : this.Timestamp[i].toString(16)));\n        }\n        this.arr.pop();\n        const time = this.arr.join('');\n        this.time = parseInt(time, 16);\n        return parseInt(time, 16);\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = FlvTag;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvZmx2L2ZsdlRhZy5qcz9mYWFhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQyIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZsdlRhZyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudGFnVHlwZSA9IC0xO1xuICAgICAgICB0aGlzLmRhdGFTaXplID0gLTE7XG4gICAgICAgIHRoaXMuVGltZXN0YW1wID0gLTE7XG4gICAgICAgIHRoaXMuU3RyZWFtSUQgPSAtMTtcbiAgICAgICAgdGhpcy5ib2R5ID0gLTE7XG4gICAgICAgIHRoaXMudGltZSA9IC0xO1xuICAgICAgICB0aGlzLmFyciA9IFtdO1xuICAgIH1cbiAgICBnZXRUaW1lKCkge1xuICAgICAgICAvLyB0aGlzLlRpbWVzdGFtcC5wb3AoKTtcbiAgICAgICAgdGhpcy5hcnIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLlRpbWVzdGFtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hcnIucHVzaCgodGhpcy5UaW1lc3RhbXBbaV0udG9TdHJpbmcoMTYpLmxlbmd0aCA9PSAxID8gJzAnICsgdGhpcy5UaW1lc3RhbXBbaV0udG9TdHJpbmcoMTYpIDogdGhpcy5UaW1lc3RhbXBbaV0udG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcnIucG9wKCk7XG4gICAgICAgIGNvbnN0IHRpbWUgPSB0aGlzLmFyci5qb2luKCcnKTtcbiAgICAgICAgdGhpcy50aW1lID0gcGFyc2VJbnQodGltZSwgMTYpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGltZSwgMTYpO1xuICAgIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY2hpbWVlLWZsdjJmbXA0L2xpYi9mbHYvZmx2VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__decodeUTF8__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sps_parser__ = __webpack_require__(1);\n/* eslint-disable */\n\n\nconst le = (function() {\n    const buf = new ArrayBuffer(2);\n    (new DataView(buf)).setInt16(0, 256, true); // little-endian write\n    return (new Int16Array(buf))[0] === 256; // platform-spec read, if equal then LE\n})();\nclass flvDemux {\n\n    constructor() {\n\n    }\n    static parseObject(arrayBuffer, dataOffset, dataSize) {\n\n        const name = flvDemux.parseString(arrayBuffer, dataOffset, dataSize);\n        const value = flvDemux.parseScript(arrayBuffer, dataOffset + name.size);\n        const isObjectEnd = value.objectEnd;\n\n        return {\n            data: {\n                name: name.data,\n                value: value.data\n            },\n            size: value.size,\n            objectEnd: isObjectEnd\n        };\n    }\n\n    static parseVariable(arrayBuffer, dataOffset, dataSize) {\n        return flvDemux.parseObject(arrayBuffer, dataOffset, dataSize);\n    }\n    static parseLongString(arrayBuffer, dataOffset, dataSize) {\n\n        const v = new DataView(arrayBuffer, dataOffset);\n        const length = v.getUint32(0, !le);\n\n        let str;\n        if (length > 0) {\n            str = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__decodeUTF8__[\"a\" /* default */])(new Uint8Array(arrayBuffer, dataOffset + 4, length));\n        } else {\n            str = '';\n        }\n\n        return {\n            data: str,\n            size: 4 + length\n        };\n    }\n    static parseDate(arrayBuffer, dataOffset, dataSize) {\n\n        const v = new DataView(arrayBuffer, dataOffset);\n        let timestamp = v.getFloat64(0, !le);\n        const localTimeOffset = v.getInt16(8, !le);\n        timestamp += localTimeOffset * 60 * 1000; // get UTC time\n\n        return {\n            data: new Date(timestamp),\n            size: 8 + 2\n        };\n    }\n    static parseString(arrayBuffer, dataOffset, dataSize) {\n        const v = new DataView(arrayBuffer, dataOffset);\n        const length = v.getUint16(0, !le);\n        let str;\n        if (length > 0) {\n            str = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__decodeUTF8__[\"a\" /* default */])(new Uint8Array(arrayBuffer, dataOffset + 2, length));\n        } else {\n            str = '';\n        }\n        return {\n            data: str,\n            size: 2 + length\n        };\n    }\n\n    /**\n     * 解析metadata\n     */\n    static parseMetadata(arr) {\n        const name = flvDemux.parseScript(arr, 0);\n        const value = flvDemux.parseScript(arr, name.size, arr.length - name.size);\n        // return {}\n        const data = {};\n        data[name.data] = value.data;\n        return data;\n    }\n\n    static parseScript(arr, offset, dataSize) {\n        let dataOffset = offset;\n        const object = {};\n        const uint8 = new Uint8Array(arr);\n        const buffer = uint8.buffer;\n        const dv = new DataView(buffer, 0, dataSize);\n        let value = null;\n        let objectEnd = false;\n        const type = (dv.getUint8(dataOffset));\n        dataOffset += 1;\n\n        switch (type) {\n            case 0: // Number(Double) type\n                value = dv.getFloat64(dataOffset, !le);\n                dataOffset += 8;\n                break;\n            case 1:\n                { // Boolean type\n                    const b = dv.getUint8(dataOffset);\n                    value = !!b;\n                    dataOffset += 1;\n                    break;\n                }\n            case 2:\n                { // String type\n                    // dataOffset += 1;\n                    const amfstr = flvDemux.parseString(buffer, dataOffset);\n                    value = amfstr.data;\n                    dataOffset += amfstr.size;\n                    break;\n                }\n            case 3:\n\n                { // Object(s) type\n                    value = {};\n                    let terminal = 0; // workaround for malformed Objects which has missing ScriptDataObjectEnd\n                    if ((dv.getUint32(dataSize - 4, !le) & 0x00FFFFFF) === 9) {\n                        terminal = 3;\n                    }\n                    while (dataOffset < dataSize - 4) { // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\n                        const amfobj = flvDemux.parseObject(buffer, dataOffset, dataSize - offset - terminal);\n\n                        if (amfobj.objectEnd) { break; }\n                        value[amfobj.data.name] = amfobj.data.value;\n                        // dataOffset += amfobj.size;\n                        dataOffset = amfobj.size;\n                    }\n                    if (dataOffset <= dataSize - 3) {\n                        const marker = v.getUint32(dataOffset - 1, !le) & 0x00FFFFFF;\n                        if (marker === 9) {\n                            dataOffset += 3;\n                        }\n                    }\n                    break;\n                }\n            case 8:\n                { // ECMA array type (Mixed array)\n                    value = {};\n                    // dataOffset += 1;\n                    dataOffset += 4; // ECMAArrayLength(UI32)\n                    let terminal = 0; // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\n                    if ((dv.getUint32(dataSize - 4, !le) & 0x00FFFFFF) === 9) {\n                        terminal = 3;\n                    }\n                    while (dataOffset < dataSize - 8) { // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\n                        const amfvar = flvDemux.parseVariable(buffer, dataOffset);\n\n                        if (amfvar.objectEnd) { break; }\n                        value[amfvar.data.name] = amfvar.data.value;\n                        dataOffset = amfvar.size;\n                    }\n                    if (dataOffset <= dataSize - 3) {\n                        const marker = dv.getUint32(dataOffset - 1, !le) & 0x00FFFFFF;\n                        if (marker === 9) {\n                            dataOffset += 3;\n                        }\n                    }\n                    break;\n                }\n            case 9: // ScriptDataObjectEnd\n                value = undefined;\n                dataOffset = 1;\n                objectEnd = true;\n                break;\n            case 10:\n                { // Strict array type\n                    // ScriptDataValue[n]. NOTE: according to video_file_format_spec_v10_1.pdf\n                    value = [];\n                    const strictArrayLength = dv.getUint32(dataOffset, !le);\n                    dataOffset += 4;\n                    for (let i = 0; i < strictArrayLength; i++) {\n                        const val = flvDemux.parseScript(buffer, dataOffset);\n                        value.push(val.data);\n                        dataOffset = val.size;\n                    }\n                    break;\n                }\n            case 11:\n                { // Date type\n                    const date = flvDemux.parseDate(buffer, dataOffset + 1, dataSize - 1);\n                    value = date.data;\n                    dataOffset += date.size;\n                    break;\n                }\n            case 12:\n                { // Long string type\n                    const amfLongStr = flvDemux.parseString(buffer, dataOffset + 1, dataSize - 1);\n                    value = amfLongStr.data;\n                    dataOffset += amfLongStr.size;\n                    break;\n                }\n            default:\n                // ignore and skip\n                dataOffset = dataSize;\n                console.log('AMF', 'Unsupported AMF value type ' + type);\n        }\n        return {\n            data: value,\n            size: dataOffset,\n        };\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = flvDemux;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvZmx2L2ZsdmRlbXV4LmpzPzFmOTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyw0Q0FBNEM7QUFDNUMsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1QkFBdUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEMiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IGRlY29kZVVURjggZnJvbSAnLi4vZGVjb2RlVVRGOCc7XG5pbXBvcnQgU1BTUGFyc2VyIGZyb20gJy4vc3BzLXBhcnNlcic7XG5jb25zdCBsZSA9IChmdW5jdGlvbigpIHtcbiAgICBjb25zdCBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMik7XG4gICAgKG5ldyBEYXRhVmlldyhidWYpKS5zZXRJbnQxNigwLCAyNTYsIHRydWUpOyAvLyBsaXR0bGUtZW5kaWFuIHdyaXRlXG4gICAgcmV0dXJuIChuZXcgSW50MTZBcnJheShidWYpKVswXSA9PT0gMjU2OyAvLyBwbGF0Zm9ybS1zcGVjIHJlYWQsIGlmIGVxdWFsIHRoZW4gTEVcbn0pKCk7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBmbHZEZW11eCB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VPYmplY3QoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKSB7XG5cbiAgICAgICAgY29uc3QgbmFtZSA9IGZsdkRlbXV4LnBhcnNlU3RyaW5nKGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0LCBkYXRhU2l6ZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZmx2RGVtdXgucGFyc2VTY3JpcHQoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQgKyBuYW1lLnNpemUpO1xuICAgICAgICBjb25zdCBpc09iamVjdEVuZCA9IHZhbHVlLm9iamVjdEVuZDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUuZGF0YSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUuZGF0YVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpemU6IHZhbHVlLnNpemUsXG4gICAgICAgICAgICBvYmplY3RFbmQ6IGlzT2JqZWN0RW5kXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlVmFyaWFibGUoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKSB7XG4gICAgICAgIHJldHVybiBmbHZEZW11eC5wYXJzZU9iamVjdChhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCwgZGF0YVNpemUpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VMb25nU3RyaW5nKGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0LCBkYXRhU2l6ZSkge1xuXG4gICAgICAgIGNvbnN0IHYgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB2LmdldFVpbnQzMigwLCAhbGUpO1xuXG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzdHIgPSBkZWNvZGVVVEY4KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0ICsgNCwgbGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBzdHIsXG4gICAgICAgICAgICBzaXplOiA0ICsgbGVuZ3RoXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZURhdGUoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplKSB7XG5cbiAgICAgICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB2LmdldEZsb2F0NjQoMCwgIWxlKTtcbiAgICAgICAgY29uc3QgbG9jYWxUaW1lT2Zmc2V0ID0gdi5nZXRJbnQxNig4LCAhbGUpO1xuICAgICAgICB0aW1lc3RhbXAgKz0gbG9jYWxUaW1lT2Zmc2V0ICogNjAgKiAxMDAwOyAvLyBnZXQgVVRDIHRpbWVcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogbmV3IERhdGUodGltZXN0YW1wKSxcbiAgICAgICAgICAgIHNpemU6IDggKyAyXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZVN0cmluZyhhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCwgZGF0YVNpemUpIHtcbiAgICAgICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHYuZ2V0VWludDE2KDAsICFsZSk7XG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzdHIgPSBkZWNvZGVVVEY4KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0ICsgMiwgbGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogc3RyLFxuICAgICAgICAgICAgc2l6ZTogMiArIGxlbmd0aFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOino+aekG1ldGFkYXRhXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlTWV0YWRhdGEoYXJyKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmbHZEZW11eC5wYXJzZVNjcmlwdChhcnIsIDApO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGZsdkRlbXV4LnBhcnNlU2NyaXB0KGFyciwgbmFtZS5zaXplLCBhcnIubGVuZ3RoIC0gbmFtZS5zaXplKTtcbiAgICAgICAgLy8gcmV0dXJuIHt9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICAgICAgZGF0YVtuYW1lLmRhdGFdID0gdmFsdWUuZGF0YTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlU2NyaXB0KGFyciwgb2Zmc2V0LCBkYXRhU2l6ZSkge1xuICAgICAgICBsZXQgZGF0YU9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0ge307XG4gICAgICAgIGNvbnN0IHVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDguYnVmZmVyO1xuICAgICAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhidWZmZXIsIDAsIGRhdGFTaXplKTtcbiAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgbGV0IG9iamVjdEVuZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0eXBlID0gKGR2LmdldFVpbnQ4KGRhdGFPZmZzZXQpKTtcbiAgICAgICAgZGF0YU9mZnNldCArPSAxO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwOiAvLyBOdW1iZXIoRG91YmxlKSB0eXBlXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkdi5nZXRGbG9hdDY0KGRhdGFPZmZzZXQsICFsZSk7XG4gICAgICAgICAgICAgICAgZGF0YU9mZnNldCArPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHsgLy8gQm9vbGVhbiB0eXBlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBkdi5nZXRVaW50OChkYXRhT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAhIWI7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHsgLy8gU3RyaW5nIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZGF0YU9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbWZzdHIgPSBmbHZEZW11eC5wYXJzZVN0cmluZyhidWZmZXIsIGRhdGFPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFtZnN0ci5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0ICs9IGFtZnN0ci5zaXplO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDM6XG5cbiAgICAgICAgICAgICAgICB7IC8vIE9iamVjdChzKSB0eXBlXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtaW5hbCA9IDA7IC8vIHdvcmthcm91bmQgZm9yIG1hbGZvcm1lZCBPYmplY3RzIHdoaWNoIGhhcyBtaXNzaW5nIFNjcmlwdERhdGFPYmplY3RFbmRcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkdi5nZXRVaW50MzIoZGF0YVNpemUgLSA0LCAhbGUpICYgMHgwMEZGRkZGRikgPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsID0gMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGF0YU9mZnNldCA8IGRhdGFTaXplIC0gNCkgeyAvLyA0ID09PSB0eXBlKFVJOCkgKyBTY3JpcHREYXRhT2JqZWN0RW5kKFVJMjQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbWZvYmogPSBmbHZEZW11eC5wYXJzZU9iamVjdChidWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFTaXplIC0gb2Zmc2V0IC0gdGVybWluYWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW1mb2JqLm9iamVjdEVuZCkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbYW1mb2JqLmRhdGEubmFtZV0gPSBhbWZvYmouZGF0YS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGFPZmZzZXQgKz0gYW1mb2JqLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0ID0gYW1mb2JqLnNpemU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFPZmZzZXQgPD0gZGF0YVNpemUgLSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXIgPSB2LmdldFVpbnQzMihkYXRhT2Zmc2V0IC0gMSwgIWxlKSAmIDB4MDBGRkZGRkY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFya2VyID09PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YU9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICB7IC8vIEVDTUEgYXJyYXkgdHlwZSAoTWl4ZWQgYXJyYXkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgICAgICAgICAgICAgIC8vIGRhdGFPZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YU9mZnNldCArPSA0OyAvLyBFQ01BQXJyYXlMZW5ndGgoVUkzMilcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlcm1pbmFsID0gMDsgLy8gd29ya2Fyb3VuZCBmb3IgbWFsZm9ybWVkIE1peGVkQXJyYXlzIHdoaWNoIGhhcyBtaXNzaW5nIFNjcmlwdERhdGFPYmplY3RFbmRcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkdi5nZXRVaW50MzIoZGF0YVNpemUgLSA0LCAhbGUpICYgMHgwMEZGRkZGRikgPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsID0gMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGF0YU9mZnNldCA8IGRhdGFTaXplIC0gOCkgeyAvLyA4ID09PSB0eXBlKFVJOCkgKyBFQ01BQXJyYXlMZW5ndGgoVUkzMikgKyBTY3JpcHREYXRhVmFyaWFibGVFbmQoVUkyNClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFtZnZhciA9IGZsdkRlbXV4LnBhcnNlVmFyaWFibGUoYnVmZmVyLCBkYXRhT2Zmc2V0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFtZnZhci5vYmplY3RFbmQpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2FtZnZhci5kYXRhLm5hbWVdID0gYW1mdmFyLmRhdGEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0ID0gYW1mdmFyLnNpemU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFPZmZzZXQgPD0gZGF0YVNpemUgLSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBkdi5nZXRVaW50MzIoZGF0YU9mZnNldCAtIDEsICFsZSkgJiAweDAwRkZGRkZGO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtlciA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDk6IC8vIFNjcmlwdERhdGFPYmplY3RFbmRcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgICBvYmplY3RFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICB7IC8vIFN0cmljdCBhcnJheSB0eXBlXG4gICAgICAgICAgICAgICAgICAgIC8vIFNjcmlwdERhdGFWYWx1ZVtuXS4gTk9URTogYWNjb3JkaW5nIHRvIHZpZGVvX2ZpbGVfZm9ybWF0X3NwZWNfdjEwXzEucGRmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmljdEFycmF5TGVuZ3RoID0gZHYuZ2V0VWludDMyKGRhdGFPZmZzZXQsICFsZSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpY3RBcnJheUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBmbHZEZW11eC5wYXJzZVNjcmlwdChidWZmZXIsIGRhdGFPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucHVzaCh2YWwuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0ID0gdmFsLnNpemU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICB7IC8vIERhdGUgdHlwZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gZmx2RGVtdXgucGFyc2VEYXRlKGJ1ZmZlciwgZGF0YU9mZnNldCArIDEsIGRhdGFTaXplIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGF0ZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0ICs9IGRhdGUuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICB7IC8vIExvbmcgc3RyaW5nIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW1mTG9uZ1N0ciA9IGZsdkRlbXV4LnBhcnNlU3RyaW5nKGJ1ZmZlciwgZGF0YU9mZnNldCArIDEsIGRhdGFTaXplIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYW1mTG9uZ1N0ci5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0ICs9IGFtZkxvbmdTdHIuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgYW5kIHNraXBcbiAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0ID0gZGF0YVNpemU7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FNRicsICdVbnN1cHBvcnRlZCBBTUYgdmFsdWUgdHlwZSAnICsgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHZhbHVlLFxuICAgICAgICAgICAgc2l6ZTogZGF0YU9mZnNldCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvZmx2L2ZsdmRlbXV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/**\n * reference flv.js\n */\n/* eslint-disable */\nclass MediaInfo {\n\n    constructor() {\n        this.mimeType = null;\n        this.duration = null;\n\n        this.hasAudio = null;\n        this.hasVideo = null;\n        this.audioCodec = null;\n        this.videoCodec = null;\n        this.audioDataRate = null;\n        this.videoDataRate = null;\n\n        this.audioSampleRate = null;\n        this.audioChannelCount = null;\n\n        this.width = null;\n        this.height = null;\n        this.fps = null;\n        this.profile = null;\n        this.level = null;\n        this.chromaFormat = null;\n        this.sarNum = null;\n        this.sarDen = null;\n\n        this.metadata = null;\n        this.segments = null; // MediaInfo[]\n        this.segmentCount = null;\n        this.hasKeyframesIndex = null;\n        this.keyframesIndex = null;\n    }\n\n    isComplete() {\n        const audioInfoComplete = (this.hasAudio === false) ||\n            (this.hasAudio === true &&\n                this.audioCodec != null &&\n                this.audioSampleRate != null &&\n                this.audioChannelCount != null);\n\n        const videoInfoComplete = (this.hasVideo === false) ||\n            (this.hasVideo === true &&\n                this.videoCodec != null &&\n                this.width != null &&\n                this.height != null &&\n                this.fps != null &&\n                this.profile != null &&\n                this.level != null &&\n                this.chromaFormat != null &&\n                this.sarNum != null &&\n                this.sarDen != null);\n\n        // keyframesIndex may not be present\n        return this.mimeType != null &&\n            this.duration != null &&\n            this.metadata != null &&\n            this.hasKeyframesIndex != null &&\n            audioInfoComplete &&\n            videoInfoComplete;\n    }\n\n    isSeekable() {\n        return this.hasKeyframesIndex === true;\n    }\n\n\n\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (MediaInfo);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvZmx2L21lZGlhLWluZm8uanM/YjVmMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUEiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHJlZmVyZW5jZSBmbHYuanNcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNsYXNzIE1lZGlhSW5mbyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5taW1lVHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBudWxsO1xuXG4gICAgICAgIHRoaXMuaGFzQXVkaW8gPSBudWxsO1xuICAgICAgICB0aGlzLmhhc1ZpZGVvID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdWRpb0NvZGVjID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWRlb0NvZGVjID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdWRpb0RhdGFSYXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWRlb0RhdGFSYXRlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmF1ZGlvU2FtcGxlUmF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYXVkaW9DaGFubmVsQ291bnQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMud2lkdGggPSBudWxsO1xuICAgICAgICB0aGlzLmhlaWdodCA9IG51bGw7XG4gICAgICAgIHRoaXMuZnBzID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9maWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sZXZlbCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hyb21hRm9ybWF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYXJOdW0gPSBudWxsO1xuICAgICAgICB0aGlzLnNhckRlbiA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBudWxsOyAvLyBNZWRpYUluZm9bXVxuICAgICAgICB0aGlzLnNlZ21lbnRDb3VudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzS2V5ZnJhbWVzSW5kZXggPSBudWxsO1xuICAgICAgICB0aGlzLmtleWZyYW1lc0luZGV4ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpc0NvbXBsZXRlKCkge1xuICAgICAgICBjb25zdCBhdWRpb0luZm9Db21wbGV0ZSA9ICh0aGlzLmhhc0F1ZGlvID09PSBmYWxzZSkgfHxcbiAgICAgICAgICAgICh0aGlzLmhhc0F1ZGlvID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0NvZGVjICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvU2FtcGxlUmF0ZSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0NoYW5uZWxDb3VudCAhPSBudWxsKTtcblxuICAgICAgICBjb25zdCB2aWRlb0luZm9Db21wbGV0ZSA9ICh0aGlzLmhhc1ZpZGVvID09PSBmYWxzZSkgfHxcbiAgICAgICAgICAgICh0aGlzLmhhc1ZpZGVvID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgdGhpcy52aWRlb0NvZGVjICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5mcHMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMucHJvZmlsZSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5sZXZlbCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jaHJvbWFGb3JtYXQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2FyTnVtICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNhckRlbiAhPSBudWxsKTtcblxuICAgICAgICAvLyBrZXlmcmFtZXNJbmRleCBtYXkgbm90IGJlIHByZXNlbnRcbiAgICAgICAgcmV0dXJuIHRoaXMubWltZVR5cGUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiAhPSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhICE9IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMuaGFzS2V5ZnJhbWVzSW5kZXggIT0gbnVsbCAmJlxuICAgICAgICAgICAgYXVkaW9JbmZvQ29tcGxldGUgJiZcbiAgICAgICAgICAgIHZpZGVvSW5mb0NvbXBsZXRlO1xuICAgIH1cblxuICAgIGlzU2Vla2FibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0tleWZyYW1lc0luZGV4ID09PSB0cnVlO1xuICAgIH1cblxuXG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWVkaWFJbmZvO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jaGltZWUtZmx2MmZtcDQvbGliL2Zsdi9tZWRpYS1pbmZvLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flv_flvParse__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flv_tagdemux__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mp4_mp4remux__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mp4_mp4moof__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_chimee_helper__ = __webpack_require__(17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_chimee_helper___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_chimee_helper__);\n/* eslint-disable */\n\n\n\n\n\nclass flv2fmp4 {\n\n    /**\n     * Creates an instance of flv2fmp4.\n     * config 里面有_isLive属性,是否是直播\n     * @param {any} config\n     *\n     * @memberof flv2fmp4\n     */\n    constructor(config) {\n        this._config = { _isLive: false };\n        this._config = Object.assign(this._config, config);\n\n        // 外部方法赋值\n        this.onInitSegment = null;\n        this.onMediaSegment = null;\n        this.onMediaInfo = null;\n        this.seekCallBack = null;\n\n        // 内部使用\n        this.loadmetadata = false;\n        this.ftyp_moov = null;\n        this.metaSuccRun = false;\n        this.metas = [];\n        this.parseChunk = null;\n        this.hasVideo = false;\n        this.hasAudio = false;\n        this._error=null;\n        // 临时记录seek时间\n        this._pendingResolveSeekPoint = -1;\n\n        // 临时记录flv数据起始时间\n        this._tempBaseTime = 0;\n\n        // 处理flv数据入口\n        this.setflvBase = this.setflvBasefrist;\n\n        __WEBPACK_IMPORTED_MODULE_1__flv_tagdemux__[\"a\" /* default */]._onTrackMetadata = this.Metadata.bind(this);\n        __WEBPACK_IMPORTED_MODULE_1__flv_tagdemux__[\"a\" /* default */]._onMediaInfo = this.metaSucc.bind(this);\n        __WEBPACK_IMPORTED_MODULE_1__flv_tagdemux__[\"a\" /* default */]._onDataAvailable = this.onDataAvailable.bind(this);\n        __WEBPACK_IMPORTED_MODULE_1__flv_tagdemux__[\"a\" /* default */]._onError=this.error.bind(this);\n        this.m4mof = new __WEBPACK_IMPORTED_MODULE_3__mp4_mp4moof__[\"a\" /* default */](this._config);\n        this.m4mof.onMediaSegment = this.onMdiaSegment.bind(this);\n    }\n    seek(baseTime) {\n        this.setflvBase = this.setflvBasefrist;\n        if (baseTime == undefined || baseTime == 0) {\n            baseTime = 0;\n            this._pendingResolveSeekPoint = -1;\n        }\n        if (this._tempBaseTime != baseTime) {\n            this._tempBaseTime = baseTime;\n            __WEBPACK_IMPORTED_MODULE_1__flv_tagdemux__[\"a\" /* default */]._timestampBase = baseTime;\n            this.m4mof.seek(baseTime);\n            this.m4mof.insertDiscontinuity();\n            this._pendingResolveSeekPoint = baseTime;\n        }\n    }\n\n    /**\n     * 不要主动调用这个接口!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n     * 第一次接受数据,和seek时候接受数据入口,\n     *\n     * @param {any} arraybuff\n     * @param {any} baseTime\n     * @returns\n     *\n     * @memberof flv2fmp4\n     */\n    setflvBasefrist(arraybuff, baseTime) {\n        let offset = 0;\n        try {\n            offset = __WEBPACK_IMPORTED_MODULE_0__flv_flvParse__[\"a\" /* default */].setFlv(new Uint8Array(arraybuff));\n        } catch (error) {\n            this.error(error);\n        }\n\n        if (__WEBPACK_IMPORTED_MODULE_0__flv_flvParse__[\"a\" /* default */].arrTag.length > 0) {\n            this.hasAudio = __WEBPACK_IMPORTED_MODULE_0__flv_flvParse__[\"a\" /* default */]._hasAudio;\n            this.hasVideo = __WEBPACK_IMPORTED_MODULE_0__flv_flvParse__[\"a\" /* default */]._hasVideo;\n            if (this._tempBaseTime != 0 && this._tempBaseTime == __WEBPACK_IMPORTED_MODULE_0__flv_flvParse__[\"a\" /* default */].arrTag[0].getTime()) {\n                __WEBPACK_IMPORTED_MODULE_1__flv_tagdemux__[\"a\" /* default */]._timestampBase = 0;\n            }\n            try {\n                __WEBPACK_IMPORTED_MODULE_1__flv_tagdemux__[\"a\" /* default */].moofTag(__WEBPACK_IMPORTED_MODULE_0__flv_flvParse__[\"a\" /* default */].arrTag);\n            } catch (error) {\n                this.error(error);\n            }\n\n            this.setflvBase = this.setflvBaseUsually;\n        }\n\n        return offset;\n    }\n\n    /**\n     * 不要主动调用这个接口!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n     * 后续接受数据接口\n     * @param {any} arraybuff\n     * @param {any} baseTime\n     * @returns\n     *\n     * @memberof flv2fmp4\n     */\n    setflvBaseUsually(arraybuff, baseTime) {\n        let offset = 0;\n        try {\n            offset = __WEBPACK_IMPORTED_MODULE_0__flv_flvParse__[\"a\" /* default */].setFlv(new Uint8Array(arraybuff));\n        } catch (error) {\n            this.error(error);\n        }\n        if (__WEBPACK_IMPORTED_MODULE_0__flv_flvParse__[\"a\" /* default */].arrTag.length > 0) {\n            try {\n                __WEBPACK_IMPORTED_MODULE_1__flv_tagdemux__[\"a\" /* default */].moofTag(__WEBPACK_IMPORTED_MODULE_0__flv_flvParse__[\"a\" /* default */].arrTag);\n            } catch (error) {\n                this.error(error);\n            }\n        }\n\n        return offset;\n    }\n\n    /**\n     * 不要主动调用这个接口!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n     * moof回调\n     *\n     * @param {any} track\n     * @param {any} value\n     *\n     * @memberof flv2fmp4\n     */\n    onMdiaSegment(track, value) {\n\n        if (this.onMediaSegment) {\n            this.onMediaSegment(new Uint8Array(value.data));\n        }\n        if (this._pendingResolveSeekPoint != -1 && track == 'video') {\n            let seekpoint = this._pendingResolveSeekPoint;\n            this._pendingResolveSeekPoint = -1;\n            if (this.seekCallBack) {\n                this.seekCallBack(seekpoint);\n            }\n        }\n    }\n\n    /**\n     *\n     * 音频和视频的初始化tag\n     *\n     * @param {any} type\n     * @param {any} meta\n     *\n     * @memberof flv2fmp4\n     */\n    Metadata(type, meta) {\n        switch (type) {\n            case 'video':\n                this.metas.push(meta);\n                this.m4mof._videoMeta = meta;\n                if (this.hasVideo && !this.hasAudio) {\n                    this.metaSucc();\n                    return;\n                }\n                break;\n            case 'audio':\n                this.metas.push(meta);\n                this.m4mof._audioMeta = meta;\n                if (!this.hasVideo && this.hasAudio) {\n                    this.metaSucc();\n                    return;\n                }\n                break;\n        }\n        if (this.hasVideo && this.hasAudio && this.metaSuccRun && this.metas.length > 1) {\n            this.metaSucc();\n        }\n    }\n\n    /**\n     * metadata解读成功后触发及第一个视频tag和第一个音频tag\n     *\n     * @param {any} mi\n     * @returns\n     *\n     * @memberof flv2fmp4\n     */\n    metaSucc(mi) {\n        if (this.onMediaInfo) {\n            this.onMediaInfo(mi, { hasAudio: this.hasAudio, hasVideo: this.hasVideo });\n        }\n        // 获取ftyp和moov\n        if (this.metas.length == 0) {\n            this.metaSuccRun = true;\n            return;\n        }\n\n        this.ftyp_moov = __WEBPACK_IMPORTED_MODULE_2__mp4_mp4remux__[\"a\" /* default */].generateInitSegment(this.metas);\n        if (this.onInitSegment && this.loadmetadata == false) {\n\n            this.onInitSegment(this.ftyp_moov);\n            this.loadmetadata = true;\n        }\n    }\n\n    onDataAvailable(audiotrack, videotrack) {\n        try{\n            this.m4mof.remux(audiotrack, videotrack);\n        }catch(e){\n            this.error(e);\n        }\n        \n    }\n\n    /**\n     * 传入flv的二进制数据\n     * 统一入口\n     * @param {any} arraybuff\n     * @param {any} baseTime flv数据开始时间\n     * @returns\n     *\n     * @memberof flv2fmp4\n     */\n    setflv(arraybuff, baseTime) {\n        return this.setflvBase(arraybuff, baseTime);\n    }\n\n    /**\n     *\n     * 本地调试代码,不用理会\n     * @param {any} arraybuff\n     * @returns\n     *\n     * @memberof flv2fmp4\n     */\n    setflvloc(arraybuff) {\n        const offset = __WEBPACK_IMPORTED_MODULE_0__flv_flvParse__[\"a\" /* default */].setFlv(new Uint8Array(arraybuff));\n\n        if (__WEBPACK_IMPORTED_MODULE_0__flv_flvParse__[\"a\" /* default */].arrTag.length > 0) {\n            return __WEBPACK_IMPORTED_MODULE_0__flv_flvParse__[\"a\" /* default */].arrTag;\n        }\n    }\n\n\n    /**\n     * \n     *  异常抛出处理\n     * @param {any} e \n     * @memberof flv2fmp4\n     */\n    error(e) {\n        if(this._error){\n            this._error(e);\n        }\n    }\n    \n}\n\n/**\n * 封装的对外类,有些方法不想对外暴露,所以封装这么一个类\n *\n * @class foreign\n */\nclass foreign extends __WEBPACK_IMPORTED_MODULE_4_chimee_helper__[\"CustEvent\"] {\n    constructor(config) {\n        super();\n        this.f2m = new flv2fmp4(config);\n        this.f2m._error=this.error;\n        // 外部方法赋值\n        this._onInitSegment = null;\n        this._onMediaSegment = null;\n        this._onMediaInfo = null;\n        this._seekCallBack = null;\n    }\n\n    error(e){\n        this.emit('error',e.type);\n    }\n    /**\n     *\n     * 跳转\n     * @param {any} basetime  跳转时间\n     *\n     * @memberof foreign\n     */\n    seek(basetime) {\n        this.f2m.seek(basetime);\n    }\n\n    /**\n     * 传入flv的二进制数据\n     * 统一入口\n     * @param {any} arraybuff\n     * @returns\n     *\n     * @memberof flv2fmp4\n     */\n    setflv(arraybuff) {\n        return this.f2m.setflv(arraybuff, 0);\n    }\n\n    /**\n     *\n     * 本地调试代码,不用理会\n     * @param {any} arraybuff\n     * @returns\n     *\n     * @memberof flv2fmp4\n     */\n    setflvloc(arraybuff) {\n        return this.f2m.setflvloc(arraybuff);\n    }\n\n    /**\n     * 赋值初始化seg接受方法\n     *\n     *\n     * @memberof foreign\n     */\n    set onInitSegment(fun) {\n        this._onInitSegment = fun;\n        this.f2m.onInitSegment = fun;\n    }\n\n    /**\n     * 赋值moof接受方法\n     *\n     *\n     * @memberof foreign\n     */\n    set onMediaSegment(fun) {\n        this._onMediaSegment = fun;\n        this.f2m.onMediaSegment = fun;\n    }\n\n    /**\n     * 赋值metadata接受方法\n     *\n     *\n     * @memberof foreign\n     */\n    set onMediaInfo(fun) {\n        this._onMediaInfo = fun;\n        this.f2m.onMediaInfo = fun;\n    }\n\n    /**\n     * 赋值是否跳转回调接受方法\n     *\n     *\n     * @memberof foreign\n     */\n    set seekCallBack(fun) {\n        this._seekCallBack = fun;\n        this.f2m.seekCallBack = fun;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (foreign);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvZmx2MmZtcDQuanM/OTJkZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxJQUFJO0FBQ25CLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLElBQUk7QUFDbkIsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQixlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQixlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1EQUFtRDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLElBQUk7QUFDbkIsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgZmx2cGFyc2UgZnJvbSAnLi9mbHYvZmx2UGFyc2UnO1xuaW1wb3J0IHRhZ2RlbXV4IGZyb20gJy4vZmx2L3RhZ2RlbXV4JztcbmltcG9ydCBtcDRyZW11eCBmcm9tICcuL21wNC9tcDRyZW11eCc7XG5pbXBvcnQgbXA0bW9vZiBmcm9tICcuL21wNC9tcDRtb29mJztcbmltcG9ydCB7IEN1c3RFdmVudCB9IGZyb20gJ2NoaW1lZS1oZWxwZXInO1xuY2xhc3MgZmx2MmZtcDQge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmbHYyZm1wNC5cbiAgICAgKiBjb25maWcg6YeM6Z2i5pyJX2lzTGl2ZeWxnuaApyzmmK/lkKbmmK/nm7Tmkq1cbiAgICAgKiBAcGFyYW0ge2FueX0gY29uZmlnXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZmx2MmZtcDRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnID0geyBfaXNMaXZlOiBmYWxzZSB9O1xuICAgICAgICB0aGlzLl9jb25maWcgPSBPYmplY3QuYXNzaWduKHRoaXMuX2NvbmZpZywgY29uZmlnKTtcblxuICAgICAgICAvLyDlpJbpg6jmlrnms5XotYvlgLxcbiAgICAgICAgdGhpcy5vbkluaXRTZWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbk1lZGlhU2VnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMub25NZWRpYUluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLnNlZWtDYWxsQmFjayA9IG51bGw7XG5cbiAgICAgICAgLy8g5YaF6YOo5L2/55SoXG4gICAgICAgIHRoaXMubG9hZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnR5cF9tb292ID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZXRhU3VjY1J1biA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1ldGFzID0gW107XG4gICAgICAgIHRoaXMucGFyc2VDaHVuayA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzVmlkZW8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNBdWRpbyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lcnJvcj1udWxsO1xuICAgICAgICAvLyDkuLTml7borrDlvZVzZWVr5pe26Ze0XG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZXNvbHZlU2Vla1BvaW50ID0gLTE7XG5cbiAgICAgICAgLy8g5Li05pe26K6w5b2VZmx25pWw5o2u6LW35aeL5pe26Ze0XG4gICAgICAgIHRoaXMuX3RlbXBCYXNlVGltZSA9IDA7XG5cbiAgICAgICAgLy8g5aSE55CGZmx25pWw5o2u5YWl5Y+jXG4gICAgICAgIHRoaXMuc2V0Zmx2QmFzZSA9IHRoaXMuc2V0Zmx2QmFzZWZyaXN0O1xuXG4gICAgICAgIHRhZ2RlbXV4Ll9vblRyYWNrTWV0YWRhdGEgPSB0aGlzLk1ldGFkYXRhLmJpbmQodGhpcyk7XG4gICAgICAgIHRhZ2RlbXV4Ll9vbk1lZGlhSW5mbyA9IHRoaXMubWV0YVN1Y2MuYmluZCh0aGlzKTtcbiAgICAgICAgdGFnZGVtdXguX29uRGF0YUF2YWlsYWJsZSA9IHRoaXMub25EYXRhQXZhaWxhYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRhZ2RlbXV4Ll9vbkVycm9yPXRoaXMuZXJyb3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tNG1vZiA9IG5ldyBtcDRtb29mKHRoaXMuX2NvbmZpZyk7XG4gICAgICAgIHRoaXMubTRtb2Yub25NZWRpYVNlZ21lbnQgPSB0aGlzLm9uTWRpYVNlZ21lbnQuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgc2VlayhiYXNlVGltZSkge1xuICAgICAgICB0aGlzLnNldGZsdkJhc2UgPSB0aGlzLnNldGZsdkJhc2VmcmlzdDtcbiAgICAgICAgaWYgKGJhc2VUaW1lID09IHVuZGVmaW5lZCB8fCBiYXNlVGltZSA9PSAwKSB7XG4gICAgICAgICAgICBiYXNlVGltZSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZVNlZWtQb2ludCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90ZW1wQmFzZVRpbWUgIT0gYmFzZVRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBCYXNlVGltZSA9IGJhc2VUaW1lO1xuICAgICAgICAgICAgdGFnZGVtdXguX3RpbWVzdGFtcEJhc2UgPSBiYXNlVGltZTtcbiAgICAgICAgICAgIHRoaXMubTRtb2Yuc2VlayhiYXNlVGltZSk7XG4gICAgICAgICAgICB0aGlzLm00bW9mLmluc2VydERpc2NvbnRpbnVpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZXNvbHZlU2Vla1BvaW50ID0gYmFzZVRpbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDkuI3opoHkuLvliqjosIPnlKjov5nkuKrmjqXlj6MhISEhISEhISEhISEhISEhISEhISEhISEhISEhXG4gICAgICog56ys5LiA5qyh5o6l5Y+X5pWw5o2uLOWSjHNlZWvml7blgJnmjqXlj5fmlbDmja7lhaXlj6MsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gYXJyYXlidWZmXG4gICAgICogQHBhcmFtIHthbnl9IGJhc2VUaW1lXG4gICAgICogQHJldHVybnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBmbHYyZm1wNFxuICAgICAqL1xuICAgIHNldGZsdkJhc2VmcmlzdChhcnJheWJ1ZmYsIGJhc2VUaW1lKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZmx2cGFyc2Uuc2V0Rmx2KG5ldyBVaW50OEFycmF5KGFycmF5YnVmZikpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmx2cGFyc2UuYXJyVGFnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQXVkaW8gPSBmbHZwYXJzZS5faGFzQXVkaW87XG4gICAgICAgICAgICB0aGlzLmhhc1ZpZGVvID0gZmx2cGFyc2UuX2hhc1ZpZGVvO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RlbXBCYXNlVGltZSAhPSAwICYmIHRoaXMuX3RlbXBCYXNlVGltZSA9PSBmbHZwYXJzZS5hcnJUYWdbMF0uZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgICAgdGFnZGVtdXguX3RpbWVzdGFtcEJhc2UgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0YWdkZW11eC5tb29mVGFnKGZsdnBhcnNlLmFyclRhZyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldGZsdkJhc2UgPSB0aGlzLnNldGZsdkJhc2VVc3VhbGx5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDkuI3opoHkuLvliqjosIPnlKjov5nkuKrmjqXlj6MhISEhISEhISEhISEhISEhISEhISEhISEhISEhXG4gICAgICog5ZCO57ut5o6l5Y+X5pWw5o2u5o6l5Y+jXG4gICAgICogQHBhcmFtIHthbnl9IGFycmF5YnVmZlxuICAgICAqIEBwYXJhbSB7YW55fSBiYXNlVGltZVxuICAgICAqIEByZXR1cm5zXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZmx2MmZtcDRcbiAgICAgKi9cbiAgICBzZXRmbHZCYXNlVXN1YWxseShhcnJheWJ1ZmYsIGJhc2VUaW1lKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZmx2cGFyc2Uuc2V0Rmx2KG5ldyBVaW50OEFycmF5KGFycmF5YnVmZikpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsdnBhcnNlLmFyclRhZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRhZ2RlbXV4Lm1vb2ZUYWcoZmx2cGFyc2UuYXJyVGFnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOS4jeimgeS4u+WKqOiwg+eUqOi/meS4quaOpeWPoyEhISEhISEhISEhISEhISEhISEhISEhISEhISFcbiAgICAgKiBtb29m5Zue6LCDXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gdHJhY2tcbiAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBmbHYyZm1wNFxuICAgICAqL1xuICAgIG9uTWRpYVNlZ21lbnQodHJhY2ssIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub25NZWRpYVNlZ21lbnQpIHtcbiAgICAgICAgICAgIHRoaXMub25NZWRpYVNlZ21lbnQobmV3IFVpbnQ4QXJyYXkodmFsdWUuZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nUmVzb2x2ZVNlZWtQb2ludCAhPSAtMSAmJiB0cmFjayA9PSAndmlkZW8nKSB7XG4gICAgICAgICAgICBsZXQgc2Vla3BvaW50ID0gdGhpcy5fcGVuZGluZ1Jlc29sdmVTZWVrUG9pbnQ7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZVNlZWtQb2ludCA9IC0xO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Vla0NhbGxCYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWVrQ2FsbEJhY2soc2Vla3BvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICog6Z+z6aKR5ZKM6KeG6aKR55qE5Yid5aeL5YyWdGFnXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gdHlwZVxuICAgICAqIEBwYXJhbSB7YW55fSBtZXRhXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZmx2MmZtcDRcbiAgICAgKi9cbiAgICBNZXRhZGF0YSh0eXBlLCBtZXRhKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0YXMucHVzaChtZXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLm00bW9mLl92aWRlb01ldGEgPSBtZXRhO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1ZpZGVvICYmICF0aGlzLmhhc0F1ZGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YVN1Y2MoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFzLnB1c2gobWV0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tNG1vZi5fYXVkaW9NZXRhID0gbWV0YTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzVmlkZW8gJiYgdGhpcy5oYXNBdWRpbykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFTdWNjKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzVmlkZW8gJiYgdGhpcy5oYXNBdWRpbyAmJiB0aGlzLm1ldGFTdWNjUnVuICYmIHRoaXMubWV0YXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5tZXRhU3VjYygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWV0YWRhdGHop6Por7vmiJDlip/lkI7op6blj5Hlj4rnrKzkuIDkuKrop4bpopF0YWflkoznrKzkuIDkuKrpn7PpopF0YWdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSBtaVxuICAgICAqIEByZXR1cm5zXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZmx2MmZtcDRcbiAgICAgKi9cbiAgICBtZXRhU3VjYyhtaSkge1xuICAgICAgICBpZiAodGhpcy5vbk1lZGlhSW5mbykge1xuICAgICAgICAgICAgdGhpcy5vbk1lZGlhSW5mbyhtaSwgeyBoYXNBdWRpbzogdGhpcy5oYXNBdWRpbywgaGFzVmlkZW86IHRoaXMuaGFzVmlkZW8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8g6I635Y+WZnR5cOWSjG1vb3ZcbiAgICAgICAgaWYgKHRoaXMubWV0YXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMubWV0YVN1Y2NSdW4gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mdHlwX21vb3YgPSBtcDRyZW11eC5nZW5lcmF0ZUluaXRTZWdtZW50KHRoaXMubWV0YXMpO1xuICAgICAgICBpZiAodGhpcy5vbkluaXRTZWdtZW50ICYmIHRoaXMubG9hZG1ldGFkYXRhID09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgIHRoaXMub25Jbml0U2VnbWVudCh0aGlzLmZ0eXBfbW9vdik7XG4gICAgICAgICAgICB0aGlzLmxvYWRtZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkRhdGFBdmFpbGFibGUoYXVkaW90cmFjaywgdmlkZW90cmFjaykge1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICB0aGlzLm00bW9mLnJlbXV4KGF1ZGlvdHJhY2ssIHZpZGVvdHJhY2spO1xuICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOS8oOWFpWZsdueahOS6jOi/m+WItuaVsOaNrlxuICAgICAqIOe7n+S4gOWFpeWPo1xuICAgICAqIEBwYXJhbSB7YW55fSBhcnJheWJ1ZmZcbiAgICAgKiBAcGFyYW0ge2FueX0gYmFzZVRpbWUgZmx25pWw5o2u5byA5aeL5pe26Ze0XG4gICAgICogQHJldHVybnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBmbHYyZm1wNFxuICAgICAqL1xuICAgIHNldGZsdihhcnJheWJ1ZmYsIGJhc2VUaW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldGZsdkJhc2UoYXJyYXlidWZmLCBiYXNlVGltZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiDmnKzlnLDosIPor5Xku6PnoIEs5LiN55So55CG5LyaXG4gICAgICogQHBhcmFtIHthbnl9IGFycmF5YnVmZlxuICAgICAqIEByZXR1cm5zXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZmx2MmZtcDRcbiAgICAgKi9cbiAgICBzZXRmbHZsb2MoYXJyYXlidWZmKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGZsdnBhcnNlLnNldEZsdihuZXcgVWludDhBcnJheShhcnJheWJ1ZmYpKTtcblxuICAgICAgICBpZiAoZmx2cGFyc2UuYXJyVGFnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmbHZwYXJzZS5hcnJUYWc7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqICDlvILluLjmipvlh7rlpITnkIZcbiAgICAgKiBAcGFyYW0ge2FueX0gZSBcbiAgICAgKiBAbWVtYmVyb2YgZmx2MmZtcDRcbiAgICAgKi9cbiAgICBlcnJvcihlKSB7XG4gICAgICAgIGlmKHRoaXMuX2Vycm9yKXtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxufVxuXG4vKipcbiAqIOWwgeijheeahOWvueWkluexuyzmnInkupvmlrnms5XkuI3mg7Plr7nlpJbmmrTpnLIs5omA5Lul5bCB6KOF6L+Z5LmI5LiA5Liq57G7XG4gKlxuICogQGNsYXNzIGZvcmVpZ25cbiAqL1xuY2xhc3MgZm9yZWlnbiBleHRlbmRzIEN1c3RFdmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZjJtID0gbmV3IGZsdjJmbXA0KGNvbmZpZyk7XG4gICAgICAgIHRoaXMuZjJtLl9lcnJvcj10aGlzLmVycm9yO1xuICAgICAgICAvLyDlpJbpg6jmlrnms5XotYvlgLxcbiAgICAgICAgdGhpcy5fb25Jbml0U2VnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uTWVkaWFTZWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb25NZWRpYUluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLl9zZWVrQ2FsbEJhY2sgPSBudWxsO1xuICAgIH1cblxuICAgIGVycm9yKGUpe1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJyxlLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIOi3s+i9rFxuICAgICAqIEBwYXJhbSB7YW55fSBiYXNldGltZSAg6Lez6L2s5pe26Ze0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZm9yZWlnblxuICAgICAqL1xuICAgIHNlZWsoYmFzZXRpbWUpIHtcbiAgICAgICAgdGhpcy5mMm0uc2VlayhiYXNldGltZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Lyg5YWlZmx255qE5LqM6L+b5Yi25pWw5o2uXG4gICAgICog57uf5LiA5YWl5Y+jXG4gICAgICogQHBhcmFtIHthbnl9IGFycmF5YnVmZlxuICAgICAqIEByZXR1cm5zXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZmx2MmZtcDRcbiAgICAgKi9cbiAgICBzZXRmbHYoYXJyYXlidWZmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmYybS5zZXRmbHYoYXJyYXlidWZmLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIOacrOWcsOiwg+ivleS7o+eggSzkuI3nlKjnkIbkvJpcbiAgICAgKiBAcGFyYW0ge2FueX0gYXJyYXlidWZmXG4gICAgICogQHJldHVybnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBmbHYyZm1wNFxuICAgICAqL1xuICAgIHNldGZsdmxvYyhhcnJheWJ1ZmYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZjJtLnNldGZsdmxvYyhhcnJheWJ1ZmYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOi1i+WAvOWIneWni+WMlnNlZ+aOpeWPl+aWueazlVxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZm9yZWlnblxuICAgICAqL1xuICAgIHNldCBvbkluaXRTZWdtZW50KGZ1bikge1xuICAgICAgICB0aGlzLl9vbkluaXRTZWdtZW50ID0gZnVuO1xuICAgICAgICB0aGlzLmYybS5vbkluaXRTZWdtZW50ID0gZnVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOi1i+WAvG1vb2bmjqXlj5fmlrnms5VcbiAgICAgKlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIGZvcmVpZ25cbiAgICAgKi9cbiAgICBzZXQgb25NZWRpYVNlZ21lbnQoZnVuKSB7XG4gICAgICAgIHRoaXMuX29uTWVkaWFTZWdtZW50ID0gZnVuO1xuICAgICAgICB0aGlzLmYybS5vbk1lZGlhU2VnbWVudCA9IGZ1bjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDotYvlgLxtZXRhZGF0YeaOpeWPl+aWueazlVxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZm9yZWlnblxuICAgICAqL1xuICAgIHNldCBvbk1lZGlhSW5mbyhmdW4pIHtcbiAgICAgICAgdGhpcy5fb25NZWRpYUluZm8gPSBmdW47XG4gICAgICAgIHRoaXMuZjJtLm9uTWVkaWFJbmZvID0gZnVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOi1i+WAvOaYr+WQpui3s+i9rOWbnuiwg+aOpeWPl+aWueazlVxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgZm9yZWlnblxuICAgICAqL1xuICAgIHNldCBzZWVrQ2FsbEJhY2soZnVuKSB7XG4gICAgICAgIHRoaXMuX3NlZWtDYWxsQmFjayA9IGZ1bjtcbiAgICAgICAgdGhpcy5mMm0uc2Vla0NhbGxCYWNrID0gZnVuO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9yZWlnbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY2hpbWVlLWZsdjJmbXA0L2xpYi9mbHYyZm1wNC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/**\n * reference flv.js\n */\n/* eslint-disable */\nclass AAC {\n\n    static getSilentFrame(channelCount) {\n        if (channelCount === 1) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n        } else if (channelCount === 2) {\n            return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n        } else if (channelCount === 3) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n        } else if (channelCount === 4) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n        } else if (channelCount === 5) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n        } else if (channelCount === 6) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n        }\n        return null;\n    }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AAC);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvbXA0L2FhYy1zaWxlbnQuanM/NGQxZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcmVmZXJlbmNlIGZsdi5qc1xuICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY2xhc3MgQUFDIHtcblxuICAgIHN0YXRpYyBnZXRTaWxlbnRGcmFtZShjaGFubmVsQ291bnQpIHtcbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIzLCAweDgwXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MjEsIDB4MDAsIDB4NDksIDB4OTAsIDB4MDIsIDB4MTksIDB4MDAsIDB4MjMsIDB4ODBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4ZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgwLCAweDJjLCAweDgwLCAweDA4LCAweDAyLCAweDM4XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MzhdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgwMCwgMHhiMiwgMHgwMCwgMHgyMCwgMHgwOCwgMHhlMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBQUM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvbXA0L2FhYy1zaWxlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/**\n * reference flv.js\n */\n/* eslint-disable */\n// Represents an media sample (audio / video)\nclass SampleInfo {\n\n    constructor(dts, pts, duration, originalDts, isSync) {\n        this.dts = dts;\n        this.pts = pts;\n        this.duration = duration;\n        this.originalDts = originalDts;\n        this.isSyncPoint = isSync;\n        this.fileposition = null;\n    }\n\n}\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = SampleInfo;\n\n\n// Media Segment concept is defined in Media Source Extensions spec.\n// Particularly in ISO BMFF format, an Media Segment contains a moof box followed by a mdat box.\nclass MediaSegmentInfo {\n\n    constructor() {\n        this.beginDts = 0;\n        this.endDts = 0;\n        this.beginPts = 0;\n        this.endPts = 0;\n        this.originalBeginDts = 0;\n        this.originalEndDts = 0;\n        this.syncPoints = []; // SampleInfo[n], for video IDR frames only\n        this.firstSample = null; // SampleInfo\n        this.lastSample = null; // SampleInfo\n    }\n\n    appendSyncPoint(sampleInfo) { // also called Random Access Point\n        sampleInfo.isSyncPoint = true;\n        this.syncPoints.push(sampleInfo);\n    }\n\n}\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = MediaSegmentInfo;\n\n\n// Ordered list for recording video IDR frames, sorted by originalDts\nclass IDRSampleList {\n\n    constructor() {\n        this._list = [];\n    }\n\n    clear() {\n        this._list = [];\n    }\n\n    appendArray(syncPoints) {\n        const list = this._list;\n\n        if (syncPoints.length === 0) {\n            return;\n        }\n\n        if (list.length > 0 && syncPoints[0].originalDts < list[list.length - 1].originalDts) {\n            this.clear();\n        }\n\n        Array.prototype.push.apply(list, syncPoints);\n    }\n\n    getLastSyncPointBeforeDts(dts) {\n        if (this._list.length == 0) {\n            return null;\n        }\n\n        const list = this._list;\n        let idx = 0;\n        const last = list.length - 1;\n        let mid = 0;\n        let lbound = 0;\n        let ubound = last;\n\n        if (dts < list[0].dts) {\n            idx = 0;\n            lbound = ubound + 1;\n        }\n\n        while (lbound <= ubound) {\n            mid = lbound + Math.floor((ubound - lbound) / 2);\n            if (mid === last || (dts >= list[mid].dts && dts < list[mid + 1].dts)) {\n                idx = mid;\n                break;\n            } else if (list[mid].dts < dts) {\n                lbound = mid + 1;\n            } else {\n                ubound = mid - 1;\n            }\n        }\n        return this._list[idx];\n    }\n\n}\n/* unused harmony export IDRSampleList */\n\n\n// Data structure for recording information of media segments in single track.\nclass MediaSegmentInfoList {\n\n    constructor(type) {\n        this._type = type;\n        this._list = [];\n        this._lastAppendLocation = -1; // cached last insert location\n    }\n\n    get type() {\n        return this._type;\n    }\n\n    get length() {\n        return this._list.length;\n    }\n\n    isEmpty() {\n        return this._list.length === 0;\n    }\n\n    clear() {\n        this._list = [];\n        this._lastAppendLocation = -1;\n    }\n\n    _searchNearestSegmentBefore(originalBeginDts) {\n        const list = this._list;\n        if (list.length === 0) {\n            return -2;\n        }\n        const last = list.length - 1;\n        let mid = 0;\n        let lbound = 0;\n        let ubound = last;\n\n        let idx = 0;\n\n        if (originalBeginDts < list[0].originalBeginDts) {\n            idx = -1;\n            return idx;\n        }\n\n        while (lbound <= ubound) {\n            mid = lbound + Math.floor((ubound - lbound) / 2);\n            if (mid === last || (originalBeginDts > list[mid].lastSample.originalDts &&\n                    (originalBeginDts < list[mid + 1].originalBeginDts))) {\n                idx = mid;\n                break;\n            } else if (list[mid].originalBeginDts < originalBeginDts) {\n                lbound = mid + 1;\n            } else {\n                ubound = mid - 1;\n            }\n        }\n        return idx;\n    }\n\n    _searchNearestSegmentAfter(originalBeginDts) {\n        return this._searchNearestSegmentBefore(originalBeginDts) + 1;\n    }\n\n    append(mediaSegmentInfo) {\n        const list = this._list;\n        const msi = mediaSegmentInfo;\n        const lastAppendIdx = this._lastAppendLocation;\n        let insertIdx = 0;\n\n        if (lastAppendIdx !== -1 && lastAppendIdx < list.length &&\n            msi.originalBeginDts >= list[lastAppendIdx].lastSample.originalDts &&\n            ((lastAppendIdx === list.length - 1) ||\n                (lastAppendIdx < list.length - 1 &&\n                    msi.originalBeginDts < list[lastAppendIdx + 1].originalBeginDts))) {\n            insertIdx = lastAppendIdx + 1; // use cached location idx\n        } else {\n            if (list.length > 0) {\n                insertIdx = this._searchNearestSegmentBefore(msi.originalBeginDts) + 1;\n            }\n        }\n\n        this._lastAppendLocation = insertIdx;\n        this._list.splice(insertIdx, 0, msi);\n    }\n\n    getLastSegmentBefore(originalBeginDts) {\n        const idx = this._searchNearestSegmentBefore(originalBeginDts);\n        if (idx >= 0) {\n            return this._list[idx];\n        } else { // -1\n            return null;\n        }\n    }\n\n    getLastSampleBefore(originalBeginDts) {\n        const segment = this.getLastSegmentBefore(originalBeginDts);\n        if (segment != null) {\n            return segment.lastSample;\n        } else {\n            return null;\n        }\n    }\n\n    getLastSyncPointBefore(originalBeginDts) {\n        let segmentIdx = this._searchNearestSegmentBefore(originalBeginDts);\n        let syncPoints = this._list[segmentIdx].syncPoints;\n        while (syncPoints.length === 0 && segmentIdx > 0) {\n            segmentIdx--;\n            syncPoints = this._list[segmentIdx].syncPoints;\n        }\n        if (syncPoints.length > 0) {\n            return syncPoints[syncPoints.length - 1];\n        } else {\n            return null;\n        }\n    }\n\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = MediaSegmentInfoList;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvbXA0L21lZGlhLXNlZ21lbnQtaW5mby5qcz85MzQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQjs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsQyIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcmVmZXJlbmNlIGZsdi5qc1xuICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gUmVwcmVzZW50cyBhbiBtZWRpYSBzYW1wbGUgKGF1ZGlvIC8gdmlkZW8pXG5leHBvcnQgY2xhc3MgU2FtcGxlSW5mbyB7XG5cbiAgICBjb25zdHJ1Y3RvcihkdHMsIHB0cywgZHVyYXRpb24sIG9yaWdpbmFsRHRzLCBpc1N5bmMpIHtcbiAgICAgICAgdGhpcy5kdHMgPSBkdHM7XG4gICAgICAgIHRoaXMucHRzID0gcHRzO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHRoaXMub3JpZ2luYWxEdHMgPSBvcmlnaW5hbER0cztcbiAgICAgICAgdGhpcy5pc1N5bmNQb2ludCA9IGlzU3luYztcbiAgICAgICAgdGhpcy5maWxlcG9zaXRpb24gPSBudWxsO1xuICAgIH1cblxufVxuXG4vLyBNZWRpYSBTZWdtZW50IGNvbmNlcHQgaXMgZGVmaW5lZCBpbiBNZWRpYSBTb3VyY2UgRXh0ZW5zaW9ucyBzcGVjLlxuLy8gUGFydGljdWxhcmx5IGluIElTTyBCTUZGIGZvcm1hdCwgYW4gTWVkaWEgU2VnbWVudCBjb250YWlucyBhIG1vb2YgYm94IGZvbGxvd2VkIGJ5IGEgbWRhdCBib3guXG5leHBvcnQgY2xhc3MgTWVkaWFTZWdtZW50SW5mbyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5iZWdpbkR0cyA9IDA7XG4gICAgICAgIHRoaXMuZW5kRHRzID0gMDtcbiAgICAgICAgdGhpcy5iZWdpblB0cyA9IDA7XG4gICAgICAgIHRoaXMuZW5kUHRzID0gMDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEJlZ2luRHRzID0gMDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVuZER0cyA9IDA7XG4gICAgICAgIHRoaXMuc3luY1BvaW50cyA9IFtdOyAvLyBTYW1wbGVJbmZvW25dLCBmb3IgdmlkZW8gSURSIGZyYW1lcyBvbmx5XG4gICAgICAgIHRoaXMuZmlyc3RTYW1wbGUgPSBudWxsOyAvLyBTYW1wbGVJbmZvXG4gICAgICAgIHRoaXMubGFzdFNhbXBsZSA9IG51bGw7IC8vIFNhbXBsZUluZm9cbiAgICB9XG5cbiAgICBhcHBlbmRTeW5jUG9pbnQoc2FtcGxlSW5mbykgeyAvLyBhbHNvIGNhbGxlZCBSYW5kb20gQWNjZXNzIFBvaW50XG4gICAgICAgIHNhbXBsZUluZm8uaXNTeW5jUG9pbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN5bmNQb2ludHMucHVzaChzYW1wbGVJbmZvKTtcbiAgICB9XG5cbn1cblxuLy8gT3JkZXJlZCBsaXN0IGZvciByZWNvcmRpbmcgdmlkZW8gSURSIGZyYW1lcywgc29ydGVkIGJ5IG9yaWdpbmFsRHRzXG5leHBvcnQgY2xhc3MgSURSU2FtcGxlTGlzdCB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbGlzdCA9IFtdO1xuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9saXN0ID0gW107XG4gICAgfVxuXG4gICAgYXBwZW5kQXJyYXkoc3luY1BvaW50cykge1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5fbGlzdDtcblxuICAgICAgICBpZiAoc3luY1BvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA+IDAgJiYgc3luY1BvaW50c1swXS5vcmlnaW5hbER0cyA8IGxpc3RbbGlzdC5sZW5ndGggLSAxXS5vcmlnaW5hbER0cykge1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdCwgc3luY1BvaW50cyk7XG4gICAgfVxuXG4gICAgZ2V0TGFzdFN5bmNQb2ludEJlZm9yZUR0cyhkdHMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xpc3QubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgICAgIGxldCBpZHggPSAwO1xuICAgICAgICBjb25zdCBsYXN0ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgICAgICBsZXQgbWlkID0gMDtcbiAgICAgICAgbGV0IGxib3VuZCA9IDA7XG4gICAgICAgIGxldCB1Ym91bmQgPSBsYXN0O1xuXG4gICAgICAgIGlmIChkdHMgPCBsaXN0WzBdLmR0cykge1xuICAgICAgICAgICAgaWR4ID0gMDtcbiAgICAgICAgICAgIGxib3VuZCA9IHVib3VuZCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAobGJvdW5kIDw9IHVib3VuZCkge1xuICAgICAgICAgICAgbWlkID0gbGJvdW5kICsgTWF0aC5mbG9vcigodWJvdW5kIC0gbGJvdW5kKSAvIDIpO1xuICAgICAgICAgICAgaWYgKG1pZCA9PT0gbGFzdCB8fCAoZHRzID49IGxpc3RbbWlkXS5kdHMgJiYgZHRzIDwgbGlzdFttaWQgKyAxXS5kdHMpKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gbWlkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaXN0W21pZF0uZHRzIDwgZHRzKSB7XG4gICAgICAgICAgICAgICAgbGJvdW5kID0gbWlkICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdWJvdW5kID0gbWlkIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbGlzdFtpZHhdO1xuICAgIH1cblxufVxuXG4vLyBEYXRhIHN0cnVjdHVyZSBmb3IgcmVjb3JkaW5nIGluZm9ybWF0aW9uIG9mIG1lZGlhIHNlZ21lbnRzIGluIHNpbmdsZSB0cmFjay5cbmV4cG9ydCBjbGFzcyBNZWRpYVNlZ21lbnRJbmZvTGlzdCB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9saXN0ID0gW107XG4gICAgICAgIHRoaXMuX2xhc3RBcHBlbmRMb2NhdGlvbiA9IC0xOyAvLyBjYWNoZWQgbGFzdCBpbnNlcnQgbG9jYXRpb25cbiAgICB9XG5cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3QubGVuZ3RoO1xuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saXN0Lmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9sYXN0QXBwZW5kTG9jYXRpb24gPSAtMTtcbiAgICB9XG5cbiAgICBfc2VhcmNoTmVhcmVzdFNlZ21lbnRCZWZvcmUob3JpZ2luYWxCZWdpbkR0cykge1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgbGV0IG1pZCA9IDA7XG4gICAgICAgIGxldCBsYm91bmQgPSAwO1xuICAgICAgICBsZXQgdWJvdW5kID0gbGFzdDtcblxuICAgICAgICBsZXQgaWR4ID0gMDtcblxuICAgICAgICBpZiAob3JpZ2luYWxCZWdpbkR0cyA8IGxpc3RbMF0ub3JpZ2luYWxCZWdpbkR0cykge1xuICAgICAgICAgICAgaWR4ID0gLTE7XG4gICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGxib3VuZCA8PSB1Ym91bmQpIHtcbiAgICAgICAgICAgIG1pZCA9IGxib3VuZCArIE1hdGguZmxvb3IoKHVib3VuZCAtIGxib3VuZCkgLyAyKTtcbiAgICAgICAgICAgIGlmIChtaWQgPT09IGxhc3QgfHwgKG9yaWdpbmFsQmVnaW5EdHMgPiBsaXN0W21pZF0ubGFzdFNhbXBsZS5vcmlnaW5hbER0cyAmJlxuICAgICAgICAgICAgICAgICAgICAob3JpZ2luYWxCZWdpbkR0cyA8IGxpc3RbbWlkICsgMV0ub3JpZ2luYWxCZWdpbkR0cykpKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gbWlkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaXN0W21pZF0ub3JpZ2luYWxCZWdpbkR0cyA8IG9yaWdpbmFsQmVnaW5EdHMpIHtcbiAgICAgICAgICAgICAgICBsYm91bmQgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1Ym91bmQgPSBtaWQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuXG4gICAgX3NlYXJjaE5lYXJlc3RTZWdtZW50QWZ0ZXIob3JpZ2luYWxCZWdpbkR0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VhcmNoTmVhcmVzdFNlZ21lbnRCZWZvcmUob3JpZ2luYWxCZWdpbkR0cykgKyAxO1xuICAgIH1cblxuICAgIGFwcGVuZChtZWRpYVNlZ21lbnRJbmZvKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLl9saXN0O1xuICAgICAgICBjb25zdCBtc2kgPSBtZWRpYVNlZ21lbnRJbmZvO1xuICAgICAgICBjb25zdCBsYXN0QXBwZW5kSWR4ID0gdGhpcy5fbGFzdEFwcGVuZExvY2F0aW9uO1xuICAgICAgICBsZXQgaW5zZXJ0SWR4ID0gMDtcblxuICAgICAgICBpZiAobGFzdEFwcGVuZElkeCAhPT0gLTEgJiYgbGFzdEFwcGVuZElkeCA8IGxpc3QubGVuZ3RoICYmXG4gICAgICAgICAgICBtc2kub3JpZ2luYWxCZWdpbkR0cyA+PSBsaXN0W2xhc3RBcHBlbmRJZHhdLmxhc3RTYW1wbGUub3JpZ2luYWxEdHMgJiZcbiAgICAgICAgICAgICgobGFzdEFwcGVuZElkeCA9PT0gbGlzdC5sZW5ndGggLSAxKSB8fFxuICAgICAgICAgICAgICAgIChsYXN0QXBwZW5kSWR4IDwgbGlzdC5sZW5ndGggLSAxICYmXG4gICAgICAgICAgICAgICAgICAgIG1zaS5vcmlnaW5hbEJlZ2luRHRzIDwgbGlzdFtsYXN0QXBwZW5kSWR4ICsgMV0ub3JpZ2luYWxCZWdpbkR0cykpKSB7XG4gICAgICAgICAgICBpbnNlcnRJZHggPSBsYXN0QXBwZW5kSWR4ICsgMTsgLy8gdXNlIGNhY2hlZCBsb2NhdGlvbiBpZHhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRJZHggPSB0aGlzLl9zZWFyY2hOZWFyZXN0U2VnbWVudEJlZm9yZShtc2kub3JpZ2luYWxCZWdpbkR0cykgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGFzdEFwcGVuZExvY2F0aW9uID0gaW5zZXJ0SWR4O1xuICAgICAgICB0aGlzLl9saXN0LnNwbGljZShpbnNlcnRJZHgsIDAsIG1zaSk7XG4gICAgfVxuXG4gICAgZ2V0TGFzdFNlZ21lbnRCZWZvcmUob3JpZ2luYWxCZWdpbkR0cykge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9zZWFyY2hOZWFyZXN0U2VnbWVudEJlZm9yZShvcmlnaW5hbEJlZ2luRHRzKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlzdFtpZHhdO1xuICAgICAgICB9IGVsc2UgeyAvLyAtMVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRMYXN0U2FtcGxlQmVmb3JlKG9yaWdpbmFsQmVnaW5EdHMpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHRoaXMuZ2V0TGFzdFNlZ21lbnRCZWZvcmUob3JpZ2luYWxCZWdpbkR0cyk7XG4gICAgICAgIGlmIChzZWdtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50Lmxhc3RTYW1wbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldExhc3RTeW5jUG9pbnRCZWZvcmUob3JpZ2luYWxCZWdpbkR0cykge1xuICAgICAgICBsZXQgc2VnbWVudElkeCA9IHRoaXMuX3NlYXJjaE5lYXJlc3RTZWdtZW50QmVmb3JlKG9yaWdpbmFsQmVnaW5EdHMpO1xuICAgICAgICBsZXQgc3luY1BvaW50cyA9IHRoaXMuX2xpc3Rbc2VnbWVudElkeF0uc3luY1BvaW50cztcbiAgICAgICAgd2hpbGUgKHN5bmNQb2ludHMubGVuZ3RoID09PSAwICYmIHNlZ21lbnRJZHggPiAwKSB7XG4gICAgICAgICAgICBzZWdtZW50SWR4LS07XG4gICAgICAgICAgICBzeW5jUG9pbnRzID0gdGhpcy5fbGlzdFtzZWdtZW50SWR4XS5zeW5jUG9pbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzeW5jUG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzeW5jUG9pbnRzW3N5bmNQb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jaGltZWUtZmx2MmZtcDQvbGliL21wNC9tZWRpYS1zZWdtZW50LWluZm8uanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__aac_silent_js__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_browser_js__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mp4remux__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__media_segment_info_js__ = __webpack_require__(14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_error__ = __webpack_require__(0);\n/**\n * reference flv.js\n */\n/* eslint-disable */\n\n\n\n\n\n// Fragmented mp4 remuxer\nclass MP4Remuxer {\n\n    constructor(config) {\n        this.TAG = this.constructor.name;\n\n        this._config = config;\n        this._isLive = (config.isLive === true);\n\n        this._dtsBase = -1;\n        this._dtsBaseInited = false;\n        this._audioDtsBase = Infinity;\n        this._videoDtsBase = Infinity;\n        this._audioNextDts = undefined;\n        this._videoNextDts = undefined;\n\n        this._audioMeta = null;\n        this._videoMeta = null;\n\n        this._audioSegmentInfoList = new __WEBPACK_IMPORTED_MODULE_3__media_segment_info_js__[\"a\" /* MediaSegmentInfoList */]('audio');\n        this._videoSegmentInfoList = new __WEBPACK_IMPORTED_MODULE_3__media_segment_info_js__[\"a\" /* MediaSegmentInfoList */]('video');\n\n        this._onInitSegment = null;\n        this._onMediaSegment = null;\n\n        // Workaround for chrome < 50: Always force first sample as a Random Access Point in media segment\n        // see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n        this._forceFirstIDR = !!((__WEBPACK_IMPORTED_MODULE_1__utils_browser_js__[\"a\" /* default */].chrome &&\n            (__WEBPACK_IMPORTED_MODULE_1__utils_browser_js__[\"a\" /* default */].version.major < 50 ||\n                (__WEBPACK_IMPORTED_MODULE_1__utils_browser_js__[\"a\" /* default */].version.major === 50 && __WEBPACK_IMPORTED_MODULE_1__utils_browser_js__[\"a\" /* default */].version.build < 2661))));\n\n        // Workaround for IE11/Edge: Fill silent aac frame after keyframe-seeking\n        // Make audio beginDts equals with video beginDts, in order to fix seek freeze\n        this._fillSilentAfterSeek = (__WEBPACK_IMPORTED_MODULE_1__utils_browser_js__[\"a\" /* default */].msedge || __WEBPACK_IMPORTED_MODULE_1__utils_browser_js__[\"a\" /* default */].msie);\n    }\n\n    destroy() {\n        this._dtsBase = -1;\n        this._dtsBaseInited = false;\n        this._audioMeta = null;\n        this._videoMeta = null;\n        this._audioSegmentInfoList.clear();\n        this._audioSegmentInfoList = null;\n        this._videoSegmentInfoList.clear();\n        this._videoSegmentInfoList = null;\n        this._onInitSegment = null;\n        this._onMediaSegment = null;\n    }\n\n    bindDataSource(producer) {\n        producer.onDataAvailable = this.remux.bind(this);\n        producer.onTrackMetadata = this._onTrackMetadataReceived.bind(this);\n        return this;\n    }\n\n    /* prototype: function onInitSegment(type: string, initSegment: ArrayBuffer): void\n       InitSegment: {\n           type: string,\n           data: ArrayBuffer,\n           codec: string,\n           container: string\n       }\n    */\n    get onInitSegment() {\n        return this._onInitSegment;\n    }\n\n    set onInitSegment(callback) {\n        this._onInitSegment = callback;\n    }\n\n    /* prototype: function onMediaSegment(type: string, mediaSegment: MediaSegment): void\n       MediaSegment: {\n           type: string,\n           data: ArrayBuffer,\n           sampleCount: int32\n           info: MediaSegmentInfo\n       }\n    */\n    get onMediaSegment() {\n        return this._onMediaSegment;\n    }\n\n    set onMediaSegment(callback) {\n        this._onMediaSegment = callback;\n    }\n\n    insertDiscontinuity() {\n        this._audioNextDts = this._videoNextDts = undefined;\n    }\n\n    seek(originalDts) {\n        this._videoSegmentInfoList.clear();\n        this._audioSegmentInfoList.clear();\n    }\n\n    remux(audioTrack, videoTrack) {\n        if (!this._onMediaSegment) {\n            throw new __WEBPACK_IMPORTED_MODULE_4__utils_error__[\"a\" /* default */]('MP4Remuxer: onMediaSegment callback must be specificed!');\n        }\n        if (!this._dtsBaseInited) {\n            this._calculateDtsBase(audioTrack, videoTrack);\n        }\n        this._remuxVideo(videoTrack);\n        this._remuxAudio(audioTrack);\n    }\n\n    _onTrackMetadataReceived(type, metadata) {\n        let metabox = null;\n\n        if (type === 'audio') {\n            this._audioMeta = metadata;\n            metabox = __WEBPACK_IMPORTED_MODULE_2__mp4remux__[\"a\" /* default */].generateInitSegment(metadata);\n            console.log('msg+audio', metadata);\n        } else if (type === 'video') {\n            this._videoMeta = metadata;\n            metabox = __WEBPACK_IMPORTED_MODULE_2__mp4remux__[\"a\" /* default */].generateInitSegment(metadata);\n            console.log('msg+video', metadata);\n        } else {\n            return;\n        }\n\n        // dispatch metabox (Initialization Segment)\n        if (!this._onInitSegment) {\n            throw new __WEBPACK_IMPORTED_MODULE_4__utils_error__[\"a\" /* default */]('MP4Remuxer: onInitSegment callback must be specified!');\n        }\n        this._onInitSegment(type, {\n            type,\n            data: metabox.buffer,\n            codec: metadata.codec,\n            container: `${type}/mp4`\n        });\n    }\n\n    _calculateDtsBase(audioTrack, videoTrack) {\n        if (this._dtsBaseInited) {\n            return;\n        }\n\n        if (audioTrack.samples && audioTrack.samples.length) {\n            this._audioDtsBase = audioTrack.samples[0].dts;\n        }\n        if (videoTrack.samples && videoTrack.samples.length) {\n            this._videoDtsBase = videoTrack.samples[0].dts;\n        }\n\n        this._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase);\n        this._dtsBaseInited = true;\n    }\n\n    _remuxAudio(audioTrack) {\n        const track = audioTrack;\n        const samples = track.samples;\n        let dtsCorrection;\n        let firstDts = -1,\n            lastDts = -1,\n            lastPts = -1;\n\n        let remuxSilentFrame = false;\n        let silentFrameDuration = -1;\n\n        if (!samples || samples.length === 0) {\n            return;\n        }\n\n        let bytes = 8 + track.length;\n        let mdatbox = new Uint8Array(bytes);\n        mdatbox[0] = (bytes >>> 24) & 0xFF;\n        mdatbox[1] = (bytes >>> 16) & 0xFF;\n        mdatbox[2] = (bytes >>> 8) & 0xFF;\n        mdatbox[3] = (bytes) & 0xFF;\n\n        mdatbox.set(__WEBPACK_IMPORTED_MODULE_2__mp4remux__[\"a\" /* default */].types.mdat, 4);\n\n        let offset = 8; // size + type\n        const mp4Samples = [];\n\n        while (samples.length) {\n            const aacSample = samples.shift();\n            const unit = aacSample.unit;\n            const originalDts = aacSample.dts - this._dtsBase;\n\n            if (dtsCorrection == undefined) {\n                if (this._audioNextDts == undefined) {\n                    if (this._audioSegmentInfoList.isEmpty()) {\n                        dtsCorrection = 0;\n                        if (this._fillSilentAfterSeek && !this._videoSegmentInfoList.isEmpty()) {\n                            remuxSilentFrame = true;\n                        }\n                    } else {\n                        const lastSample = this._audioSegmentInfoList.getLastSampleBefore(originalDts);\n                        if (lastSample != null) {\n                            let distance = (originalDts - (lastSample.originalDts + lastSample.duration));\n                            if (distance <= 3) {\n                                distance = 0;\n                            }\n                            const expectedDts = lastSample.dts + lastSample.duration + distance;\n                            dtsCorrection = originalDts - expectedDts;\n                        } else { // lastSample == null\n                            dtsCorrection = 0;\n                        }\n                    }\n                } else {\n                    dtsCorrection = originalDts - this._audioNextDts;\n                }\n            }\n\n            let dts = originalDts - dtsCorrection;\n            if (remuxSilentFrame) {\n                // align audio segment beginDts to match with current video segment's beginDts\n                const videoSegment = this._videoSegmentInfoList.getLastSegmentBefore(originalDts);\n                if (videoSegment != null && videoSegment.beginDts < dts) {\n                    silentFrameDuration = dts - videoSegment.beginDts;\n                    dts = videoSegment.beginDts;\n                } else {\n                    remuxSilentFrame = false;\n                }\n            }\n            if (firstDts === -1) {\n                firstDts = dts;\n            }\n\n            if (remuxSilentFrame) {\n                remuxSilentFrame = false;\n                samples.unshift(aacSample);\n\n                const frame = this._generateSilentAudio(dts, silentFrameDuration);\n                if (frame == null) {\n                    continue;\n                }\n                const mp4Sample = frame.mp4Sample;\n                const unit = frame.unit;\n\n                mp4Samples.push(mp4Sample);\n\n                // re-allocate mdatbox buffer with new size, to fit with this silent frame\n                bytes += unit.byteLength;\n                mdatbox = new Uint8Array(bytes);\n                mdatbox[0] = (bytes >>> 24) & 0xFF;\n                mdatbox[1] = (bytes >>> 16) & 0xFF;\n                mdatbox[2] = (bytes >>> 8) & 0xFF;\n                mdatbox[3] = (bytes) & 0xFF;\n                mdatbox.set(__WEBPACK_IMPORTED_MODULE_2__mp4remux__[\"a\" /* default */].types.mdat, 4);\n\n                // fill data now\n                mdatbox.set(unit, offset);\n                offset += unit.byteLength;\n                continue;\n            }\n\n            let sampleDuration = 0;\n\n            if (samples.length >= 1) {\n                const nextDts = samples[0].dts - this._dtsBase - dtsCorrection;\n                sampleDuration = nextDts - dts;\n            } else {\n                if (mp4Samples.length >= 1) { // use second last sample duration\n                    sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n                } else { // the only one sample, use reference sample duration\n                    sampleDuration = this._audioMeta.refSampleDuration;\n                }\n            }\n\n            const mp4Sample = {\n                dts,\n                pts: dts,\n                cts: 0,\n                size: unit.byteLength,\n                duration: sampleDuration,\n                originalDts,\n                flags: {\n                    isLeading: 0,\n                    dependsOn: 1,\n                    isDependedOn: 0,\n                    hasRedundancy: 0\n                }\n            };\n            mp4Samples.push(mp4Sample);\n            mdatbox.set(unit, offset);\n            offset += unit.byteLength;\n        }\n        const latest = mp4Samples[mp4Samples.length - 1];\n        lastDts = latest.dts + latest.duration;\n        this._audioNextDts = lastDts;\n\n        // fill media segment info & add to info list\n        const info = new __WEBPACK_IMPORTED_MODULE_3__media_segment_info_js__[\"b\" /* MediaSegmentInfo */]();\n        info.beginDts = firstDts;\n        info.endDts = lastDts;\n        info.beginPts = firstDts;\n        info.endPts = lastDts;\n        info.originalBeginDts = mp4Samples[0].originalDts;\n        info.originalEndDts = latest.originalDts + latest.duration;\n        info.firstSample = new __WEBPACK_IMPORTED_MODULE_3__media_segment_info_js__[\"c\" /* SampleInfo */](mp4Samples[0].dts,\n            mp4Samples[0].pts,\n            mp4Samples[0].duration,\n            mp4Samples[0].originalDts,\n            false);\n        info.lastSample = new __WEBPACK_IMPORTED_MODULE_3__media_segment_info_js__[\"c\" /* SampleInfo */](latest.dts,\n            latest.pts,\n            latest.duration,\n            latest.originalDts,\n            false);\n        if (!this._isLive) {\n            this._audioSegmentInfoList.append(info);\n        }\n\n        track.samples = mp4Samples;\n        track.sequenceNumber += track.addcoefficient;\n\n        const moofbox = __WEBPACK_IMPORTED_MODULE_2__mp4remux__[\"a\" /* default */].moof(track, firstDts);\n        track.samples = [];\n        track.length = 0;\n\n        this._onMediaSegment('audio', {\n            type: 'audio',\n            data: this._mergeBoxes(moofbox, mdatbox).buffer,\n            sampleCount: mp4Samples.length,\n            info\n        });\n    }\n\n    _generateSilentAudio(dts, frameDuration) {\n        console.log(this.TAG, `GenerateSilentAudio: dts = ${dts}, duration = ${frameDuration}`);\n\n        const unit = __WEBPACK_IMPORTED_MODULE_0__aac_silent_js__[\"a\" /* default */].getSilentFrame(this._audioMeta.channelCount);\n        if (unit == null) {\n            console.log(this.TAG, `Cannot generate silent aac frame for channelCount = ${this._audioMeta.channelCount}`);\n            return null;\n        }\n\n        const mp4Sample = {\n            dts,\n            pts: dts,\n            cts: 0,\n            size: unit.byteLength,\n            duration: frameDuration,\n            originalDts: dts,\n            flags: {\n                isLeading: 0,\n                dependsOn: 1,\n                isDependedOn: 0,\n                hasRedundancy: 0\n            }\n        };\n\n        return {\n            unit,\n            mp4Sample\n        };\n    }\n\n    _remuxVideo(videoTrack) {\n        const track = videoTrack;\n        const samples = track.samples;\n        let dtsCorrection;\n        let firstDts = -1,\n            lastDts = -1;\n        let firstPts = -1,\n            lastPts = -1;\n\n        if (!samples || samples.length === 0) {\n            return;\n        }\n\n        const bytes = 8 + videoTrack.length;\n        const mdatbox = new Uint8Array(bytes);\n        mdatbox[0] = (bytes >>> 24) & 0xFF;\n        mdatbox[1] = (bytes >>> 16) & 0xFF;\n        mdatbox[2] = (bytes >>> 8) & 0xFF;\n        mdatbox[3] = (bytes) & 0xFF;\n        mdatbox.set(__WEBPACK_IMPORTED_MODULE_2__mp4remux__[\"a\" /* default */].types.mdat, 4);\n\n        let offset = 8;\n        const mp4Samples = [];\n        const info = new __WEBPACK_IMPORTED_MODULE_3__media_segment_info_js__[\"b\" /* MediaSegmentInfo */]();\n\n        while (samples.length) {\n            const avcSample = samples.shift();\n            const keyframe = avcSample.isKeyframe;\n            const originalDts = avcSample.dts - this._dtsBase;\n\n            if (dtsCorrection == undefined) {\n                if (this._videoNextDts == undefined) {\n                    if (this._videoSegmentInfoList.isEmpty()) {\n                        dtsCorrection = 0;\n                    } else {\n                        const lastSample = this._videoSegmentInfoList.getLastSampleBefore(originalDts);\n                        if (lastSample != null) {\n                            let distance = (originalDts - (lastSample.originalDts + lastSample.duration));\n                            if (distance <= 3) {\n                                distance = 0;\n                            }\n                            const expectedDts = lastSample.dts + lastSample.duration + distance;\n                            dtsCorrection = originalDts - expectedDts;\n                        } else { // lastSample == null\n                            dtsCorrection = 0;\n                        }\n                    }\n                } else {\n                    dtsCorrection = originalDts - this._videoNextDts;\n                }\n            }\n\n            const dts = originalDts - dtsCorrection;\n            const cts = avcSample.cts;\n            const pts = dts + cts;\n\n            if (firstDts === -1) {\n                firstDts = dts;\n                firstPts = pts;\n            }\n\n            // fill mdat box\n            let sampleSize = 0;\n            while (avcSample.units.length) {\n                const unit = avcSample.units.shift();\n                const data = unit.data;\n                mdatbox.set(data, offset);\n                offset += data.byteLength;\n                sampleSize += data.byteLength;\n            }\n\n            let sampleDuration = 0;\n\n            if (samples.length >= 1) {\n                const nextDts = samples[0].dts - this._dtsBase - dtsCorrection;\n                sampleDuration = nextDts - dts;\n            } else {\n                if (mp4Samples.length >= 1) { // lastest sample, use second last duration\n                    sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n                } else { // the only one sample, use reference duration\n                    sampleDuration = this._videoMeta.refSampleDuration;\n                }\n            }\n\n            if (keyframe) {\n                const syncPoint = new __WEBPACK_IMPORTED_MODULE_3__media_segment_info_js__[\"c\" /* SampleInfo */](dts, pts, sampleDuration, avcSample.dts, true);\n                syncPoint.fileposition = avcSample.fileposition;\n                info.appendSyncPoint(syncPoint);\n            }\n\n            const mp4Sample = {\n                dts,\n                pts,\n                cts,\n                size: sampleSize,\n                isKeyframe: keyframe,\n                duration: sampleDuration,\n                originalDts,\n                flags: {\n                    isLeading: 0,\n                    dependsOn: keyframe ? 2 : 1,\n                    isDependedOn: keyframe ? 1 : 0,\n                    hasRedundancy: 0,\n                    isNonSync: keyframe ? 0 : 1\n                }\n            };\n\n            mp4Samples.push(mp4Sample);\n        }\n        const latest = mp4Samples[mp4Samples.length - 1];\n        lastDts = latest.dts + latest.duration;\n        lastPts = latest.pts + latest.duration;\n        this._videoNextDts = lastDts;\n\n        // fill media segment info & add to info list\n        info.beginDts = firstDts;\n        info.endDts = lastDts;\n        info.beginPts = firstPts;\n        info.endPts = lastPts;\n        info.originalBeginDts = mp4Samples[0].originalDts;\n        info.originalEndDts = latest.originalDts + latest.duration;\n        info.firstSample = new __WEBPACK_IMPORTED_MODULE_3__media_segment_info_js__[\"c\" /* SampleInfo */](mp4Samples[0].dts,\n            mp4Samples[0].pts,\n            mp4Samples[0].duration,\n            mp4Samples[0].originalDts,\n            mp4Samples[0].isKeyframe);\n        info.lastSample = new __WEBPACK_IMPORTED_MODULE_3__media_segment_info_js__[\"c\" /* SampleInfo */](latest.dts,\n            latest.pts,\n            latest.duration,\n            latest.originalDts,\n            latest.isKeyframe);\n        if (!this._isLive) {\n            this._videoSegmentInfoList.append(info);\n        }\n\n        track.samples = mp4Samples;\n        track.sequenceNumber += track.addcoefficient;\n\n        // workaround for chrome < 50: force first sample as a random access point\n        // see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n        if (this._forceFirstIDR) {\n            const flags = mp4Samples[0].flags;\n            flags.dependsOn = 2;\n            flags.isNonSync = 0;\n        }\n\n        const moofbox = __WEBPACK_IMPORTED_MODULE_2__mp4remux__[\"a\" /* default */].moof(track, firstDts);\n        track.samples = [];\n        track.length = 0;\n\n        this._onMediaSegment('video', {\n            type: 'video',\n            data: this._mergeBoxes(moofbox, mdatbox).buffer,\n            sampleCount: mp4Samples.length,\n            info\n        });\n    }\n\n    _mergeBoxes(moof, mdat) {\n        const result = new Uint8Array(moof.byteLength + mdat.byteLength);\n        result.set(moof, 0);\n        result.set(mdat, moof.byteLength);\n        return result;\n    }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (MP4Remuxer);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvbXA0L21wNG1vb2YuanM/ZjZkNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSztBQUMvQixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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c291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiByZWZlcmVuY2UgZmx2LmpzXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgQUFDIGZyb20gJy4vYWFjLXNpbGVudC5qcyc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi91dGlscy9icm93c2VyLmpzJztcbmltcG9ydCBNUDQgZnJvbSAnLi9tcDRyZW11eCc7XG5pbXBvcnQgeyBTYW1wbGVJbmZvLCBNZWRpYVNlZ21lbnRJbmZvLCBNZWRpYVNlZ21lbnRJbmZvTGlzdCB9IGZyb20gJy4vbWVkaWEtc2VnbWVudC1pbmZvLmpzJztcbmltcG9ydCBlcnJvciBmcm9tICcuLi91dGlscy9lcnJvcidcbi8vIEZyYWdtZW50ZWQgbXA0IHJlbXV4ZXJcbmNsYXNzIE1QNFJlbXV4ZXIge1xuXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuVEFHID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5faXNMaXZlID0gKGNvbmZpZy5pc0xpdmUgPT09IHRydWUpO1xuXG4gICAgICAgIHRoaXMuX2R0c0Jhc2UgPSAtMTtcbiAgICAgICAgdGhpcy5fZHRzQmFzZUluaXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hdWRpb0R0c0Jhc2UgPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5fdmlkZW9EdHNCYXNlID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMuX2F1ZGlvTmV4dER0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdmlkZW9OZXh0RHRzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRoaXMuX2F1ZGlvTWV0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZpZGVvTWV0YSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fYXVkaW9TZWdtZW50SW5mb0xpc3QgPSBuZXcgTWVkaWFTZWdtZW50SW5mb0xpc3QoJ2F1ZGlvJyk7XG4gICAgICAgIHRoaXMuX3ZpZGVvU2VnbWVudEluZm9MaXN0ID0gbmV3IE1lZGlhU2VnbWVudEluZm9MaXN0KCd2aWRlbycpO1xuXG4gICAgICAgIHRoaXMuX29uSW5pdFNlZ21lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9vbk1lZGlhU2VnbWVudCA9IG51bGw7XG5cbiAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgY2hyb21lIDwgNTA6IEFsd2F5cyBmb3JjZSBmaXJzdCBzYW1wbGUgYXMgYSBSYW5kb20gQWNjZXNzIFBvaW50IGluIG1lZGlhIHNlZ21lbnRcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTQxMlxuICAgICAgICB0aGlzLl9mb3JjZUZpcnN0SURSID0gISEoKEJyb3dzZXIuY2hyb21lICYmXG4gICAgICAgICAgICAoQnJvd3Nlci52ZXJzaW9uLm1ham9yIDwgNTAgfHxcbiAgICAgICAgICAgICAgICAoQnJvd3Nlci52ZXJzaW9uLm1ham9yID09PSA1MCAmJiBCcm93c2VyLnZlcnNpb24uYnVpbGQgPCAyNjYxKSkpKTtcblxuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBJRTExL0VkZ2U6IEZpbGwgc2lsZW50IGFhYyBmcmFtZSBhZnRlciBrZXlmcmFtZS1zZWVraW5nXG4gICAgICAgIC8vIE1ha2UgYXVkaW8gYmVnaW5EdHMgZXF1YWxzIHdpdGggdmlkZW8gYmVnaW5EdHMsIGluIG9yZGVyIHRvIGZpeCBzZWVrIGZyZWV6ZVxuICAgICAgICB0aGlzLl9maWxsU2lsZW50QWZ0ZXJTZWVrID0gKEJyb3dzZXIubXNlZGdlIHx8IEJyb3dzZXIubXNpZSk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZHRzQmFzZSA9IC0xO1xuICAgICAgICB0aGlzLl9kdHNCYXNlSW5pdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2F1ZGlvTWV0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZpZGVvTWV0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2F1ZGlvU2VnbWVudEluZm9MaXN0LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2F1ZGlvU2VnbWVudEluZm9MaXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdmlkZW9TZWdtZW50SW5mb0xpc3QuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fdmlkZW9TZWdtZW50SW5mb0xpc3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9vbkluaXRTZWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb25NZWRpYVNlZ21lbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGJpbmREYXRhU291cmNlKHByb2R1Y2VyKSB7XG4gICAgICAgIHByb2R1Y2VyLm9uRGF0YUF2YWlsYWJsZSA9IHRoaXMucmVtdXguYmluZCh0aGlzKTtcbiAgICAgICAgcHJvZHVjZXIub25UcmFja01ldGFkYXRhID0gdGhpcy5fb25UcmFja01ldGFkYXRhUmVjZWl2ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyogcHJvdG90eXBlOiBmdW5jdGlvbiBvbkluaXRTZWdtZW50KHR5cGU6IHN0cmluZywgaW5pdFNlZ21lbnQ6IEFycmF5QnVmZmVyKTogdm9pZFxuICAgICAgIEluaXRTZWdtZW50OiB7XG4gICAgICAgICAgIHR5cGU6IHN0cmluZyxcbiAgICAgICAgICAgZGF0YTogQXJyYXlCdWZmZXIsXG4gICAgICAgICAgIGNvZGVjOiBzdHJpbmcsXG4gICAgICAgICAgIGNvbnRhaW5lcjogc3RyaW5nXG4gICAgICAgfVxuICAgICovXG4gICAgZ2V0IG9uSW5pdFNlZ21lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbkluaXRTZWdtZW50O1xuICAgIH1cblxuICAgIHNldCBvbkluaXRTZWdtZW50KGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uSW5pdFNlZ21lbnQgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICAvKiBwcm90b3R5cGU6IGZ1bmN0aW9uIG9uTWVkaWFTZWdtZW50KHR5cGU6IHN0cmluZywgbWVkaWFTZWdtZW50OiBNZWRpYVNlZ21lbnQpOiB2b2lkXG4gICAgICAgTWVkaWFTZWdtZW50OiB7XG4gICAgICAgICAgIHR5cGU6IHN0cmluZyxcbiAgICAgICAgICAgZGF0YTogQXJyYXlCdWZmZXIsXG4gICAgICAgICAgIHNhbXBsZUNvdW50OiBpbnQzMlxuICAgICAgICAgICBpbmZvOiBNZWRpYVNlZ21lbnRJbmZvXG4gICAgICAgfVxuICAgICovXG4gICAgZ2V0IG9uTWVkaWFTZWdtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25NZWRpYVNlZ21lbnQ7XG4gICAgfVxuXG4gICAgc2V0IG9uTWVkaWFTZWdtZW50KGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uTWVkaWFTZWdtZW50ID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgaW5zZXJ0RGlzY29udGludWl0eSgpIHtcbiAgICAgICAgdGhpcy5fYXVkaW9OZXh0RHRzID0gdGhpcy5fdmlkZW9OZXh0RHRzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHNlZWsob3JpZ2luYWxEdHMpIHtcbiAgICAgICAgdGhpcy5fdmlkZW9TZWdtZW50SW5mb0xpc3QuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fYXVkaW9TZWdtZW50SW5mb0xpc3QuY2xlYXIoKTtcbiAgICB9XG5cbiAgICByZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5fb25NZWRpYVNlZ21lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcignTVA0UmVtdXhlcjogb25NZWRpYVNlZ21lbnQgY2FsbGJhY2sgbXVzdCBiZSBzcGVjaWZpY2VkIScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZHRzQmFzZUluaXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlRHRzQmFzZShhdWRpb1RyYWNrLCB2aWRlb1RyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW11eFZpZGVvKHZpZGVvVHJhY2spO1xuICAgICAgICB0aGlzLl9yZW11eEF1ZGlvKGF1ZGlvVHJhY2spO1xuICAgIH1cblxuICAgIF9vblRyYWNrTWV0YWRhdGFSZWNlaXZlZCh0eXBlLCBtZXRhZGF0YSkge1xuICAgICAgICBsZXQgbWV0YWJveCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvTWV0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgbWV0YWJveCA9IE1QNC5nZW5lcmF0ZUluaXRTZWdtZW50KG1ldGFkYXRhKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdtc2crYXVkaW8nLCBtZXRhZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgdGhpcy5fdmlkZW9NZXRhID0gbWV0YWRhdGE7XG4gICAgICAgICAgICBtZXRhYm94ID0gTVA0LmdlbmVyYXRlSW5pdFNlZ21lbnQobWV0YWRhdGEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ21zZyt2aWRlbycsIG1ldGFkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRpc3BhdGNoIG1ldGFib3ggKEluaXRpYWxpemF0aW9uIFNlZ21lbnQpXG4gICAgICAgIGlmICghdGhpcy5fb25Jbml0U2VnbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yKCdNUDRSZW11eGVyOiBvbkluaXRTZWdtZW50IGNhbGxiYWNrIG11c3QgYmUgc3BlY2lmaWVkIScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29uSW5pdFNlZ21lbnQodHlwZSwge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGRhdGE6IG1ldGFib3guYnVmZmVyLFxuICAgICAgICAgICAgY29kZWM6IG1ldGFkYXRhLmNvZGVjLFxuICAgICAgICAgICAgY29udGFpbmVyOiBgJHt0eXBlfS9tcDRgXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9jYWxjdWxhdGVEdHNCYXNlKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuX2R0c0Jhc2VJbml0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMgJiYgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fYXVkaW9EdHNCYXNlID0gYXVkaW9UcmFjay5zYW1wbGVzWzBdLmR0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzICYmIHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvRHRzQmFzZSA9IHZpZGVvVHJhY2suc2FtcGxlc1swXS5kdHM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kdHNCYXNlID0gTWF0aC5taW4odGhpcy5fYXVkaW9EdHNCYXNlLCB0aGlzLl92aWRlb0R0c0Jhc2UpO1xuICAgICAgICB0aGlzLl9kdHNCYXNlSW5pdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBfcmVtdXhBdWRpbyhhdWRpb1RyYWNrKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gYXVkaW9UcmFjaztcbiAgICAgICAgY29uc3Qgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgICAgIGxldCBkdHNDb3JyZWN0aW9uO1xuICAgICAgICBsZXQgZmlyc3REdHMgPSAtMSxcbiAgICAgICAgICAgIGxhc3REdHMgPSAtMSxcbiAgICAgICAgICAgIGxhc3RQdHMgPSAtMTtcblxuICAgICAgICBsZXQgcmVtdXhTaWxlbnRGcmFtZSA9IGZhbHNlO1xuICAgICAgICBsZXQgc2lsZW50RnJhbWVEdXJhdGlvbiA9IC0xO1xuXG4gICAgICAgIGlmICghc2FtcGxlcyB8fCBzYW1wbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGJ5dGVzID0gOCArIHRyYWNrLmxlbmd0aDtcbiAgICAgICAgbGV0IG1kYXRib3ggPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICAgIG1kYXRib3hbMF0gPSAoYnl0ZXMgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgIG1kYXRib3hbMV0gPSAoYnl0ZXMgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgIG1kYXRib3hbMl0gPSAoYnl0ZXMgPj4+IDgpICYgMHhGRjtcbiAgICAgICAgbWRhdGJveFszXSA9IChieXRlcykgJiAweEZGO1xuXG4gICAgICAgIG1kYXRib3guc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcblxuICAgICAgICBsZXQgb2Zmc2V0ID0gODsgLy8gc2l6ZSArIHR5cGVcbiAgICAgICAgY29uc3QgbXA0U2FtcGxlcyA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgYWFjU2FtcGxlID0gc2FtcGxlcy5zaGlmdCgpO1xuICAgICAgICAgICAgY29uc3QgdW5pdCA9IGFhY1NhbXBsZS51bml0O1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxEdHMgPSBhYWNTYW1wbGUuZHRzIC0gdGhpcy5fZHRzQmFzZTtcblxuICAgICAgICAgICAgaWYgKGR0c0NvcnJlY3Rpb24gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F1ZGlvTmV4dER0cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F1ZGlvU2VnbWVudEluZm9MaXN0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHRzQ29ycmVjdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmlsbFNpbGVudEFmdGVyU2VlayAmJiAhdGhpcy5fdmlkZW9TZWdtZW50SW5mb0xpc3QuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtdXhTaWxlbnRGcmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0U2FtcGxlID0gdGhpcy5fYXVkaW9TZWdtZW50SW5mb0xpc3QuZ2V0TGFzdFNhbXBsZUJlZm9yZShvcmlnaW5hbER0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFNhbXBsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gKG9yaWdpbmFsRHRzIC0gKGxhc3RTYW1wbGUub3JpZ2luYWxEdHMgKyBsYXN0U2FtcGxlLmR1cmF0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDw9IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZER0cyA9IGxhc3RTYW1wbGUuZHRzICsgbGFzdFNhbXBsZS5kdXJhdGlvbiArIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR0c0NvcnJlY3Rpb24gPSBvcmlnaW5hbER0cyAtIGV4cGVjdGVkRHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gbGFzdFNhbXBsZSA9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHRzQ29ycmVjdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkdHNDb3JyZWN0aW9uID0gb3JpZ2luYWxEdHMgLSB0aGlzLl9hdWRpb05leHREdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZHRzID0gb3JpZ2luYWxEdHMgLSBkdHNDb3JyZWN0aW9uO1xuICAgICAgICAgICAgaWYgKHJlbXV4U2lsZW50RnJhbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBhbGlnbiBhdWRpbyBzZWdtZW50IGJlZ2luRHRzIHRvIG1hdGNoIHdpdGggY3VycmVudCB2aWRlbyBzZWdtZW50J3MgYmVnaW5EdHNcbiAgICAgICAgICAgICAgICBjb25zdCB2aWRlb1NlZ21lbnQgPSB0aGlzLl92aWRlb1NlZ21lbnRJbmZvTGlzdC5nZXRMYXN0U2VnbWVudEJlZm9yZShvcmlnaW5hbER0cyk7XG4gICAgICAgICAgICAgICAgaWYgKHZpZGVvU2VnbWVudCAhPSBudWxsICYmIHZpZGVvU2VnbWVudC5iZWdpbkR0cyA8IGR0cykge1xuICAgICAgICAgICAgICAgICAgICBzaWxlbnRGcmFtZUR1cmF0aW9uID0gZHRzIC0gdmlkZW9TZWdtZW50LmJlZ2luRHRzO1xuICAgICAgICAgICAgICAgICAgICBkdHMgPSB2aWRlb1NlZ21lbnQuYmVnaW5EdHM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtdXhTaWxlbnRGcmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdER0cyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmaXJzdER0cyA9IGR0cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbXV4U2lsZW50RnJhbWUpIHtcbiAgICAgICAgICAgICAgICByZW11eFNpbGVudEZyYW1lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2FtcGxlcy51bnNoaWZ0KGFhY1NhbXBsZSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmcmFtZSA9IHRoaXMuX2dlbmVyYXRlU2lsZW50QXVkaW8oZHRzLCBzaWxlbnRGcmFtZUR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbXA0U2FtcGxlID0gZnJhbWUubXA0U2FtcGxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuaXQgPSBmcmFtZS51bml0O1xuXG4gICAgICAgICAgICAgICAgbXA0U2FtcGxlcy5wdXNoKG1wNFNhbXBsZSk7XG5cbiAgICAgICAgICAgICAgICAvLyByZS1hbGxvY2F0ZSBtZGF0Ym94IGJ1ZmZlciB3aXRoIG5ldyBzaXplLCB0byBmaXQgd2l0aCB0aGlzIHNpbGVudCBmcmFtZVxuICAgICAgICAgICAgICAgIGJ5dGVzICs9IHVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBtZGF0Ym94ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgICAgICAgICAgICAgIG1kYXRib3hbMF0gPSAoYnl0ZXMgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgbWRhdGJveFsxXSA9IChieXRlcyA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICBtZGF0Ym94WzJdID0gKGJ5dGVzID4+PiA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgbWRhdGJveFszXSA9IChieXRlcykgJiAweEZGO1xuICAgICAgICAgICAgICAgIG1kYXRib3guc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcblxuICAgICAgICAgICAgICAgIC8vIGZpbGwgZGF0YSBub3dcbiAgICAgICAgICAgICAgICBtZGF0Ym94LnNldCh1bml0LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSB1bml0LmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBzYW1wbGVEdXJhdGlvbiA9IDA7XG5cbiAgICAgICAgICAgIGlmIChzYW1wbGVzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dER0cyA9IHNhbXBsZXNbMF0uZHRzIC0gdGhpcy5fZHRzQmFzZSAtIGR0c0NvcnJlY3Rpb247XG4gICAgICAgICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSBuZXh0RHRzIC0gZHRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobXA0U2FtcGxlcy5sZW5ndGggPj0gMSkgeyAvLyB1c2Ugc2Vjb25kIGxhc3Qgc2FtcGxlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlc1ttcDRTYW1wbGVzLmxlbmd0aCAtIDFdLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZSBvbmx5IG9uZSBzYW1wbGUsIHVzZSByZWZlcmVuY2Ugc2FtcGxlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gdGhpcy5fYXVkaW9NZXRhLnJlZlNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbXA0U2FtcGxlID0ge1xuICAgICAgICAgICAgICAgIGR0cyxcbiAgICAgICAgICAgICAgICBwdHM6IGR0cyxcbiAgICAgICAgICAgICAgICBjdHM6IDAsXG4gICAgICAgICAgICAgICAgc2l6ZTogdW5pdC5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBzYW1wbGVEdXJhdGlvbixcbiAgICAgICAgICAgICAgICBvcmlnaW5hbER0cyxcbiAgICAgICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZHNPbjogMSxcbiAgICAgICAgICAgICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgICAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1wNFNhbXBsZXMucHVzaChtcDRTYW1wbGUpO1xuICAgICAgICAgICAgbWRhdGJveC5zZXQodW5pdCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSB1bml0LmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF0ZXN0ID0gbXA0U2FtcGxlc1ttcDRTYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBsYXN0RHRzID0gbGF0ZXN0LmR0cyArIGxhdGVzdC5kdXJhdGlvbjtcbiAgICAgICAgdGhpcy5fYXVkaW9OZXh0RHRzID0gbGFzdER0cztcblxuICAgICAgICAvLyBmaWxsIG1lZGlhIHNlZ21lbnQgaW5mbyAmIGFkZCB0byBpbmZvIGxpc3RcbiAgICAgICAgY29uc3QgaW5mbyA9IG5ldyBNZWRpYVNlZ21lbnRJbmZvKCk7XG4gICAgICAgIGluZm8uYmVnaW5EdHMgPSBmaXJzdER0cztcbiAgICAgICAgaW5mby5lbmREdHMgPSBsYXN0RHRzO1xuICAgICAgICBpbmZvLmJlZ2luUHRzID0gZmlyc3REdHM7XG4gICAgICAgIGluZm8uZW5kUHRzID0gbGFzdER0cztcbiAgICAgICAgaW5mby5vcmlnaW5hbEJlZ2luRHRzID0gbXA0U2FtcGxlc1swXS5vcmlnaW5hbER0cztcbiAgICAgICAgaW5mby5vcmlnaW5hbEVuZER0cyA9IGxhdGVzdC5vcmlnaW5hbER0cyArIGxhdGVzdC5kdXJhdGlvbjtcbiAgICAgICAgaW5mby5maXJzdFNhbXBsZSA9IG5ldyBTYW1wbGVJbmZvKG1wNFNhbXBsZXNbMF0uZHRzLFxuICAgICAgICAgICAgbXA0U2FtcGxlc1swXS5wdHMsXG4gICAgICAgICAgICBtcDRTYW1wbGVzWzBdLmR1cmF0aW9uLFxuICAgICAgICAgICAgbXA0U2FtcGxlc1swXS5vcmlnaW5hbER0cyxcbiAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgaW5mby5sYXN0U2FtcGxlID0gbmV3IFNhbXBsZUluZm8obGF0ZXN0LmR0cyxcbiAgICAgICAgICAgIGxhdGVzdC5wdHMsXG4gICAgICAgICAgICBsYXRlc3QuZHVyYXRpb24sXG4gICAgICAgICAgICBsYXRlc3Qub3JpZ2luYWxEdHMsXG4gICAgICAgICAgICBmYWxzZSk7XG4gICAgICAgIGlmICghdGhpcy5faXNMaXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9hdWRpb1NlZ21lbnRJbmZvTGlzdC5hcHBlbmQoaW5mbyk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFjay5zYW1wbGVzID0gbXA0U2FtcGxlcztcbiAgICAgICAgdHJhY2suc2VxdWVuY2VOdW1iZXIgKz0gdHJhY2suYWRkY29lZmZpY2llbnQ7XG5cbiAgICAgICAgY29uc3QgbW9vZmJveCA9IE1QNC5tb29mKHRyYWNrLCBmaXJzdER0cyk7XG4gICAgICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICAgICAgdHJhY2subGVuZ3RoID0gMDtcblxuICAgICAgICB0aGlzLl9vbk1lZGlhU2VnbWVudCgnYXVkaW8nLCB7XG4gICAgICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5fbWVyZ2VCb3hlcyhtb29mYm94LCBtZGF0Ym94KS5idWZmZXIsXG4gICAgICAgICAgICBzYW1wbGVDb3VudDogbXA0U2FtcGxlcy5sZW5ndGgsXG4gICAgICAgICAgICBpbmZvXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9nZW5lcmF0ZVNpbGVudEF1ZGlvKGR0cywgZnJhbWVEdXJhdGlvbikge1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLlRBRywgYEdlbmVyYXRlU2lsZW50QXVkaW86IGR0cyA9ICR7ZHRzfSwgZHVyYXRpb24gPSAke2ZyYW1lRHVyYXRpb259YCk7XG5cbiAgICAgICAgY29uc3QgdW5pdCA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0aGlzLl9hdWRpb01ldGEuY2hhbm5lbENvdW50KTtcbiAgICAgICAgaWYgKHVuaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5UQUcsIGBDYW5ub3QgZ2VuZXJhdGUgc2lsZW50IGFhYyBmcmFtZSBmb3IgY2hhbm5lbENvdW50ID0gJHt0aGlzLl9hdWRpb01ldGEuY2hhbm5lbENvdW50fWApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtcDRTYW1wbGUgPSB7XG4gICAgICAgICAgICBkdHMsXG4gICAgICAgICAgICBwdHM6IGR0cyxcbiAgICAgICAgICAgIGN0czogMCxcbiAgICAgICAgICAgIHNpemU6IHVuaXQuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBmcmFtZUR1cmF0aW9uLFxuICAgICAgICAgICAgb3JpZ2luYWxEdHM6IGR0cyxcbiAgICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgICAgICAgIGRlcGVuZHNPbjogMSxcbiAgICAgICAgICAgICAgICBpc0RlcGVuZGVkT246IDAsXG4gICAgICAgICAgICAgICAgaGFzUmVkdW5kYW5jeTogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bml0LFxuICAgICAgICAgICAgbXA0U2FtcGxlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgX3JlbXV4VmlkZW8odmlkZW9UcmFjaykge1xuICAgICAgICBjb25zdCB0cmFjayA9IHZpZGVvVHJhY2s7XG4gICAgICAgIGNvbnN0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgICAgICBsZXQgZHRzQ29ycmVjdGlvbjtcbiAgICAgICAgbGV0IGZpcnN0RHRzID0gLTEsXG4gICAgICAgICAgICBsYXN0RHRzID0gLTE7XG4gICAgICAgIGxldCBmaXJzdFB0cyA9IC0xLFxuICAgICAgICAgICAgbGFzdFB0cyA9IC0xO1xuXG4gICAgICAgIGlmICghc2FtcGxlcyB8fCBzYW1wbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnl0ZXMgPSA4ICsgdmlkZW9UcmFjay5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG1kYXRib3ggPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICAgIG1kYXRib3hbMF0gPSAoYnl0ZXMgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgIG1kYXRib3hbMV0gPSAoYnl0ZXMgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgIG1kYXRib3hbMl0gPSAoYnl0ZXMgPj4+IDgpICYgMHhGRjtcbiAgICAgICAgbWRhdGJveFszXSA9IChieXRlcykgJiAweEZGO1xuICAgICAgICBtZGF0Ym94LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG5cbiAgICAgICAgbGV0IG9mZnNldCA9IDg7XG4gICAgICAgIGNvbnN0IG1wNFNhbXBsZXMgPSBbXTtcbiAgICAgICAgY29uc3QgaW5mbyA9IG5ldyBNZWRpYVNlZ21lbnRJbmZvKCk7XG5cbiAgICAgICAgd2hpbGUgKHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBhdmNTYW1wbGUgPSBzYW1wbGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCBrZXlmcmFtZSA9IGF2Y1NhbXBsZS5pc0tleWZyYW1lO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxEdHMgPSBhdmNTYW1wbGUuZHRzIC0gdGhpcy5fZHRzQmFzZTtcblxuICAgICAgICAgICAgaWYgKGR0c0NvcnJlY3Rpb24gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ZpZGVvTmV4dER0cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ZpZGVvU2VnbWVudEluZm9MaXN0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHRzQ29ycmVjdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0U2FtcGxlID0gdGhpcy5fdmlkZW9TZWdtZW50SW5mb0xpc3QuZ2V0TGFzdFNhbXBsZUJlZm9yZShvcmlnaW5hbER0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFNhbXBsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gKG9yaWdpbmFsRHRzIC0gKGxhc3RTYW1wbGUub3JpZ2luYWxEdHMgKyBsYXN0U2FtcGxlLmR1cmF0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDw9IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZER0cyA9IGxhc3RTYW1wbGUuZHRzICsgbGFzdFNhbXBsZS5kdXJhdGlvbiArIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR0c0NvcnJlY3Rpb24gPSBvcmlnaW5hbER0cyAtIGV4cGVjdGVkRHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gbGFzdFNhbXBsZSA9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHRzQ29ycmVjdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkdHNDb3JyZWN0aW9uID0gb3JpZ2luYWxEdHMgLSB0aGlzLl92aWRlb05leHREdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBkdHMgPSBvcmlnaW5hbER0cyAtIGR0c0NvcnJlY3Rpb247XG4gICAgICAgICAgICBjb25zdCBjdHMgPSBhdmNTYW1wbGUuY3RzO1xuICAgICAgICAgICAgY29uc3QgcHRzID0gZHRzICsgY3RzO1xuXG4gICAgICAgICAgICBpZiAoZmlyc3REdHMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZmlyc3REdHMgPSBkdHM7XG4gICAgICAgICAgICAgICAgZmlyc3RQdHMgPSBwdHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpbGwgbWRhdCBib3hcbiAgICAgICAgICAgIGxldCBzYW1wbGVTaXplID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChhdmNTYW1wbGUudW5pdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5pdCA9IGF2Y1NhbXBsZS51bml0cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB1bml0LmRhdGE7XG4gICAgICAgICAgICAgICAgbWRhdGJveC5zZXQoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHNhbXBsZVNpemUgKz0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc2FtcGxlRHVyYXRpb24gPSAwO1xuXG4gICAgICAgICAgICBpZiAoc2FtcGxlcy5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHREdHMgPSBzYW1wbGVzWzBdLmR0cyAtIHRoaXMuX2R0c0Jhc2UgLSBkdHNDb3JyZWN0aW9uO1xuICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gbmV4dER0cyAtIGR0cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1wNFNhbXBsZXMubGVuZ3RoID49IDEpIHsgLy8gbGFzdGVzdCBzYW1wbGUsIHVzZSBzZWNvbmQgbGFzdCBkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IG1wNFNhbXBsZXNbbXA0U2FtcGxlcy5sZW5ndGggLSAxXS5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyB0aGUgb25seSBvbmUgc2FtcGxlLCB1c2UgcmVmZXJlbmNlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gdGhpcy5fdmlkZW9NZXRhLnJlZlNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGtleWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3luY1BvaW50ID0gbmV3IFNhbXBsZUluZm8oZHRzLCBwdHMsIHNhbXBsZUR1cmF0aW9uLCBhdmNTYW1wbGUuZHRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzeW5jUG9pbnQuZmlsZXBvc2l0aW9uID0gYXZjU2FtcGxlLmZpbGVwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBpbmZvLmFwcGVuZFN5bmNQb2ludChzeW5jUG9pbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBtcDRTYW1wbGUgPSB7XG4gICAgICAgICAgICAgICAgZHRzLFxuICAgICAgICAgICAgICAgIHB0cyxcbiAgICAgICAgICAgICAgICBjdHMsXG4gICAgICAgICAgICAgICAgc2l6ZTogc2FtcGxlU2l6ZSxcbiAgICAgICAgICAgICAgICBpc0tleWZyYW1lOiBrZXlmcmFtZSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogc2FtcGxlRHVyYXRpb24sXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxEdHMsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICBkZXBlbmRzT246IGtleWZyYW1lID8gMiA6IDEsXG4gICAgICAgICAgICAgICAgICAgIGlzRGVwZW5kZWRPbjoga2V5ZnJhbWUgPyAxIDogMCxcbiAgICAgICAgICAgICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcbiAgICAgICAgICAgICAgICAgICAgaXNOb25TeW5jOiBrZXlmcmFtZSA/IDAgOiAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbXA0U2FtcGxlcy5wdXNoKG1wNFNhbXBsZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF0ZXN0ID0gbXA0U2FtcGxlc1ttcDRTYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBsYXN0RHRzID0gbGF0ZXN0LmR0cyArIGxhdGVzdC5kdXJhdGlvbjtcbiAgICAgICAgbGFzdFB0cyA9IGxhdGVzdC5wdHMgKyBsYXRlc3QuZHVyYXRpb247XG4gICAgICAgIHRoaXMuX3ZpZGVvTmV4dER0cyA9IGxhc3REdHM7XG5cbiAgICAgICAgLy8gZmlsbCBtZWRpYSBzZWdtZW50IGluZm8gJiBhZGQgdG8gaW5mbyBsaXN0XG4gICAgICAgIGluZm8uYmVnaW5EdHMgPSBmaXJzdER0cztcbiAgICAgICAgaW5mby5lbmREdHMgPSBsYXN0RHRzO1xuICAgICAgICBpbmZvLmJlZ2luUHRzID0gZmlyc3RQdHM7XG4gICAgICAgIGluZm8uZW5kUHRzID0gbGFzdFB0cztcbiAgICAgICAgaW5mby5vcmlnaW5hbEJlZ2luRHRzID0gbXA0U2FtcGxlc1swXS5vcmlnaW5hbER0cztcbiAgICAgICAgaW5mby5vcmlnaW5hbEVuZER0cyA9IGxhdGVzdC5vcmlnaW5hbER0cyArIGxhdGVzdC5kdXJhdGlvbjtcbiAgICAgICAgaW5mby5maXJzdFNhbXBsZSA9IG5ldyBTYW1wbGVJbmZvKG1wNFNhbXBsZXNbMF0uZHRzLFxuICAgICAgICAgICAgbXA0U2FtcGxlc1swXS5wdHMsXG4gICAgICAgICAgICBtcDRTYW1wbGVzWzBdLmR1cmF0aW9uLFxuICAgICAgICAgICAgbXA0U2FtcGxlc1swXS5vcmlnaW5hbER0cyxcbiAgICAgICAgICAgIG1wNFNhbXBsZXNbMF0uaXNLZXlmcmFtZSk7XG4gICAgICAgIGluZm8ubGFzdFNhbXBsZSA9IG5ldyBTYW1wbGVJbmZvKGxhdGVzdC5kdHMsXG4gICAgICAgICAgICBsYXRlc3QucHRzLFxuICAgICAgICAgICAgbGF0ZXN0LmR1cmF0aW9uLFxuICAgICAgICAgICAgbGF0ZXN0Lm9yaWdpbmFsRHRzLFxuICAgICAgICAgICAgbGF0ZXN0LmlzS2V5ZnJhbWUpO1xuICAgICAgICBpZiAoIXRoaXMuX2lzTGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmlkZW9TZWdtZW50SW5mb0xpc3QuYXBwZW5kKGluZm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhY2suc2FtcGxlcyA9IG1wNFNhbXBsZXM7XG4gICAgICAgIHRyYWNrLnNlcXVlbmNlTnVtYmVyICs9IHRyYWNrLmFkZGNvZWZmaWNpZW50O1xuXG4gICAgICAgIC8vIHdvcmthcm91bmQgZm9yIGNocm9tZSA8IDUwOiBmb3JjZSBmaXJzdCBzYW1wbGUgYXMgYSByYW5kb20gYWNjZXNzIHBvaW50XG4gICAgICAgIC8vIHNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMjk0MTJcbiAgICAgICAgaWYgKHRoaXMuX2ZvcmNlRmlyc3RJRFIpIHtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gbXA0U2FtcGxlc1swXS5mbGFncztcbiAgICAgICAgICAgIGZsYWdzLmRlcGVuZHNPbiA9IDI7XG4gICAgICAgICAgICBmbGFncy5pc05vblN5bmMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW9vZmJveCA9IE1QNC5tb29mKHRyYWNrLCBmaXJzdER0cyk7XG4gICAgICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICAgICAgdHJhY2subGVuZ3RoID0gMDtcblxuICAgICAgICB0aGlzLl9vbk1lZGlhU2VnbWVudCgndmlkZW8nLCB7XG4gICAgICAgICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5fbWVyZ2VCb3hlcyhtb29mYm94LCBtZGF0Ym94KS5idWZmZXIsXG4gICAgICAgICAgICBzYW1wbGVDb3VudDogbXA0U2FtcGxlcy5sZW5ndGgsXG4gICAgICAgICAgICBpbmZvXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9tZXJnZUJveGVzKG1vb2YsIG1kYXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobW9vZi5ieXRlTGVuZ3RoICsgbWRhdC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmVzdWx0LnNldChtb29mLCAwKTtcbiAgICAgICAgcmVzdWx0LnNldChtZGF0LCBtb29mLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBNUDRSZW11eGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jaGltZWUtZmx2MmZtcDQvbGliL21wNC9tcDRtb29mLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/**\n * reference flv.js\n */\n/* eslint-disable */\nconst Browser = {};\n\nfunction detect() {\n    // modified from jquery-browser-plugin\n\n    const ua = self.navigator.userAgent.toLowerCase();\n\n    const match = /(edge)\\/([\\w.]+)/.exec(ua) ||\n        /(opr)[\\/]([\\w.]+)/.exec(ua) ||\n        /(chrome)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(iemobile)[\\/]([\\w.]+)/.exec(ua) ||\n        /(version)(applewebkit)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(webkit)[ \\/]([\\w.]+).*(version)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(webkit)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(opera)(?:.*version|)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(msie) ([\\w.]+)/.exec(ua) ||\n        ua.indexOf('trident') >= 0 && /(rv)(?::| )([\\w.]+)/.exec(ua) ||\n        ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\\w.]+)|)/.exec(ua) || [];\n\n    const platform_match = /(ipad)/.exec(ua) ||\n        /(ipod)/.exec(ua) ||\n        /(windows phone)/.exec(ua) ||\n        /(iphone)/.exec(ua) ||\n        /(kindle)/.exec(ua) ||\n        /(android)/.exec(ua) ||\n        /(windows)/.exec(ua) ||\n        /(mac)/.exec(ua) ||\n        /(linux)/.exec(ua) ||\n        /(cros)/.exec(ua) || [];\n\n    const matched = {\n        browser: match[5] || match[3] || match[1] || '',\n        version: match[2] || match[4] || '0',\n        majorVersion: match[4] || match[2] || '0',\n        platform: platform_match[0] || ''\n    };\n\n    const browser = {};\n    if (matched.browser) {\n        browser[matched.browser] = true;\n\n        const versionArray = matched.majorVersion.split('.');\n        browser.version = {\n            major: parseInt(matched.majorVersion, 10),\n            string: matched.version\n        };\n        if (versionArray.length > 1) {\n            browser.version.minor = parseInt(versionArray[1], 10);\n        }\n        if (versionArray.length > 2) {\n            browser.version.build = parseInt(versionArray[2], 10);\n        }\n    }\n\n    if (matched.platform) {\n        browser[matched.platform] = true;\n    }\n\n    if (browser.chrome || browser.opr || browser.safari) {\n        browser.webkit = true;\n    }\n\n    // MSIE. IE11 has 'rv' identifer\n    if (browser.rv || browser.iemobile) {\n        if (browser.rv) {\n            delete browser.rv;\n        }\n        const msie = 'msie';\n        matched.browser = msie;\n        browser[msie] = true;\n    }\n\n    // Microsoft Edge\n    if (browser.edge) {\n        delete browser.edge;\n        const msedge = 'msedge';\n        matched.browser = msedge;\n        browser[msedge] = true;\n    }\n\n    // Opera 15+\n    if (browser.opr) {\n        const opera = 'opera';\n        matched.browser = opera;\n        browser[opera] = true;\n    }\n\n    // Stock android browsers are marked as Safari\n    if (browser.safari && browser.android) {\n        const android = 'android';\n        matched.browser = android;\n        browser[android] = true;\n    }\n\n    browser.name = matched.browser;\n    browser.platform = matched.platform;\n\n    for (const key in Browser) {\n        if (Browser.hasOwnProperty(key)) {\n            delete Browser[key];\n        }\n    }\n    Object.assign(Browser, browser);\n}\n\ndetect();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Browser);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1mbHYyZm1wNC9saWIvdXRpbHMvYnJvd3Nlci5qcz81NWZmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcmVmZXJlbmNlIGZsdi5qc1xuICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY29uc3QgQnJvd3NlciA9IHt9O1xuXG5mdW5jdGlvbiBkZXRlY3QoKSB7XG4gICAgLy8gbW9kaWZpZWQgZnJvbSBqcXVlcnktYnJvd3Nlci1wbHVnaW5cblxuICAgIGNvbnN0IHVhID0gc2VsZi5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG5cbiAgICBjb25zdCBtYXRjaCA9IC8oZWRnZSlcXC8oW1xcdy5dKykvLmV4ZWModWEpIHx8XG4gICAgICAgIC8ob3ByKVtcXC9dKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICAvKGNocm9tZSlbIFxcL10oW1xcdy5dKykvLmV4ZWModWEpIHx8XG4gICAgICAgIC8oaWVtb2JpbGUpW1xcL10oW1xcdy5dKykvLmV4ZWModWEpIHx8XG4gICAgICAgIC8odmVyc2lvbikoYXBwbGV3ZWJraXQpWyBcXC9dKFtcXHcuXSspLiooc2FmYXJpKVsgXFwvXShbXFx3Ll0rKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgLyh3ZWJraXQpWyBcXC9dKFtcXHcuXSspLioodmVyc2lvbilbIFxcL10oW1xcdy5dKykuKihzYWZhcmkpWyBcXC9dKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICAvKHdlYmtpdClbIFxcL10oW1xcdy5dKykvLmV4ZWModWEpIHx8XG4gICAgICAgIC8ob3BlcmEpKD86Lip2ZXJzaW9ufClbIFxcL10oW1xcdy5dKykvLmV4ZWModWEpIHx8XG4gICAgICAgIC8obXNpZSkgKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICB1YS5pbmRleE9mKCd0cmlkZW50JykgPj0gMCAmJiAvKHJ2KSg/Ojp8ICkoW1xcdy5dKykvLmV4ZWModWEpIHx8XG4gICAgICAgIHVhLmluZGV4T2YoJ2NvbXBhdGlibGUnKSA8IDAgJiYgLyhtb3ppbGxhKSg/Oi4qPyBydjooW1xcdy5dKyl8KS8uZXhlYyh1YSkgfHwgW107XG5cbiAgICBjb25zdCBwbGF0Zm9ybV9tYXRjaCA9IC8oaXBhZCkvLmV4ZWModWEpIHx8XG4gICAgICAgIC8oaXBvZCkvLmV4ZWModWEpIHx8XG4gICAgICAgIC8od2luZG93cyBwaG9uZSkvLmV4ZWModWEpIHx8XG4gICAgICAgIC8oaXBob25lKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgLyhraW5kbGUpLy5leGVjKHVhKSB8fFxuICAgICAgICAvKGFuZHJvaWQpLy5leGVjKHVhKSB8fFxuICAgICAgICAvKHdpbmRvd3MpLy5leGVjKHVhKSB8fFxuICAgICAgICAvKG1hYykvLmV4ZWModWEpIHx8XG4gICAgICAgIC8obGludXgpLy5leGVjKHVhKSB8fFxuICAgICAgICAvKGNyb3MpLy5leGVjKHVhKSB8fCBbXTtcblxuICAgIGNvbnN0IG1hdGNoZWQgPSB7XG4gICAgICAgIGJyb3dzZXI6IG1hdGNoWzVdIHx8IG1hdGNoWzNdIHx8IG1hdGNoWzFdIHx8ICcnLFxuICAgICAgICB2ZXJzaW9uOiBtYXRjaFsyXSB8fCBtYXRjaFs0XSB8fCAnMCcsXG4gICAgICAgIG1ham9yVmVyc2lvbjogbWF0Y2hbNF0gfHwgbWF0Y2hbMl0gfHwgJzAnLFxuICAgICAgICBwbGF0Zm9ybTogcGxhdGZvcm1fbWF0Y2hbMF0gfHwgJydcbiAgICB9O1xuXG4gICAgY29uc3QgYnJvd3NlciA9IHt9O1xuICAgIGlmIChtYXRjaGVkLmJyb3dzZXIpIHtcbiAgICAgICAgYnJvd3NlclttYXRjaGVkLmJyb3dzZXJdID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCB2ZXJzaW9uQXJyYXkgPSBtYXRjaGVkLm1ham9yVmVyc2lvbi5zcGxpdCgnLicpO1xuICAgICAgICBicm93c2VyLnZlcnNpb24gPSB7XG4gICAgICAgICAgICBtYWpvcjogcGFyc2VJbnQobWF0Y2hlZC5tYWpvclZlcnNpb24sIDEwKSxcbiAgICAgICAgICAgIHN0cmluZzogbWF0Y2hlZC52ZXJzaW9uXG4gICAgICAgIH07XG4gICAgICAgIGlmICh2ZXJzaW9uQXJyYXkubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uLm1pbm9yID0gcGFyc2VJbnQodmVyc2lvbkFycmF5WzFdLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcnNpb25BcnJheS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBicm93c2VyLnZlcnNpb24uYnVpbGQgPSBwYXJzZUludCh2ZXJzaW9uQXJyYXlbMl0sIDEwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXRjaGVkLnBsYXRmb3JtKSB7XG4gICAgICAgIGJyb3dzZXJbbWF0Y2hlZC5wbGF0Zm9ybV0gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChicm93c2VyLmNocm9tZSB8fCBicm93c2VyLm9wciB8fCBicm93c2VyLnNhZmFyaSkge1xuICAgICAgICBicm93c2VyLndlYmtpdCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gTVNJRS4gSUUxMSBoYXMgJ3J2JyBpZGVudGlmZXJcbiAgICBpZiAoYnJvd3Nlci5ydiB8fCBicm93c2VyLmllbW9iaWxlKSB7XG4gICAgICAgIGlmIChicm93c2VyLnJ2KSB7XG4gICAgICAgICAgICBkZWxldGUgYnJvd3Nlci5ydjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtc2llID0gJ21zaWUnO1xuICAgICAgICBtYXRjaGVkLmJyb3dzZXIgPSBtc2llO1xuICAgICAgICBicm93c2VyW21zaWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBNaWNyb3NvZnQgRWRnZVxuICAgIGlmIChicm93c2VyLmVkZ2UpIHtcbiAgICAgICAgZGVsZXRlIGJyb3dzZXIuZWRnZTtcbiAgICAgICAgY29uc3QgbXNlZGdlID0gJ21zZWRnZSc7XG4gICAgICAgIG1hdGNoZWQuYnJvd3NlciA9IG1zZWRnZTtcbiAgICAgICAgYnJvd3Nlclttc2VkZ2VdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBPcGVyYSAxNStcbiAgICBpZiAoYnJvd3Nlci5vcHIpIHtcbiAgICAgICAgY29uc3Qgb3BlcmEgPSAnb3BlcmEnO1xuICAgICAgICBtYXRjaGVkLmJyb3dzZXIgPSBvcGVyYTtcbiAgICAgICAgYnJvd3NlcltvcGVyYV0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFN0b2NrIGFuZHJvaWQgYnJvd3NlcnMgYXJlIG1hcmtlZCBhcyBTYWZhcmlcbiAgICBpZiAoYnJvd3Nlci5zYWZhcmkgJiYgYnJvd3Nlci5hbmRyb2lkKSB7XG4gICAgICAgIGNvbnN0IGFuZHJvaWQgPSAnYW5kcm9pZCc7XG4gICAgICAgIG1hdGNoZWQuYnJvd3NlciA9IGFuZHJvaWQ7XG4gICAgICAgIGJyb3dzZXJbYW5kcm9pZF0gPSB0cnVlO1xuICAgIH1cblxuICAgIGJyb3dzZXIubmFtZSA9IG1hdGNoZWQuYnJvd3NlcjtcbiAgICBicm93c2VyLnBsYXRmb3JtID0gbWF0Y2hlZC5wbGF0Zm9ybTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIEJyb3dzZXIpIHtcbiAgICAgICAgaWYgKEJyb3dzZXIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgZGVsZXRlIEJyb3dzZXJba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKEJyb3dzZXIsIGJyb3dzZXIpO1xufVxuXG5kZXRlY3QoKTtcblxuZXhwb3J0IGRlZmF1bHQgQnJvd3NlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY2hpbWVlLWZsdjJmbXA0L2xpYi91dGlscy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * chimee-helper v0.1.8\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n(function (global, factory) {\n\t true ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.chimeeHelper = global.chimeeHelper || {})));\n}(this, (function (exports) { 'use strict';\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\n// 7.1.4 ToInteger\nvar ceil  = Math.ceil;\nvar floor = Math.floor;\nvar _toInteger = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n// 7.2.1 RequireObjectCoercible(argument)\nvar _defined = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n// true  -> String#at\n// false -> String#codePointAt\nvar _stringAt = function(TO_STRING){\n  return function(that, pos){\n    var s = String(_defined(that))\n      , i = _toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\nvar _library = true;\n\nvar _global = createCommonjsModule(function (module) {\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n});\n\nvar _core = createCommonjsModule(function (module) {\nvar core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n});\n\nvar _aFunction = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n// optional / simple context binding\n\nvar _ctx = function(fn, that, length){\n  _aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\nvar _isObject = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\nvar _anObject = function(it){\n  if(!_isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\nvar _fails = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n// Thank's IE8 for his funny defineProperty\nvar _descriptors = !_fails(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\nvar document$1 = _global.document;\nvar is = _isObject(document$1) && _isObject(document$1.createElement);\nvar _domCreate = function(it){\n  return is ? document$1.createElement(it) : {};\n};\n\nvar _ie8DomDefine = !_descriptors && !_fails(function(){\n  return Object.defineProperty(_domCreate('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\n\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nvar _toPrimitive = function(it, S){\n  if(!_isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\nvar dP             = Object.defineProperty;\n\nvar f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  _anObject(O);\n  P = _toPrimitive(P, true);\n  _anObject(Attributes);\n  if(_ie8DomDefine)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\nvar _objectDp = {\n\tf: f\n};\n\nvar _propertyDesc = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\nvar _hide = _descriptors ? function(object, key, value){\n  return _objectDp.f(object, key, _propertyDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\nvar PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? _core : _core[name] || (_core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? _ctx(out, _global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])_hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nvar _export = $export;\n\nvar _redefine = _hide;\n\nvar hasOwnProperty = {}.hasOwnProperty;\nvar _has = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\nvar _iterators = {};\n\nvar toString = {}.toString;\n\nvar _cof = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\nvar _iobject = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return _cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n// to indexed object, toObject with fallback for non-array-like ES3 strings\n\nvar _toIobject = function(it){\n  return _iobject(_defined(it));\n};\n\n// 7.1.15 ToLength\nvar min       = Math.min;\nvar _toLength = function(it){\n  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\nvar max       = Math.max;\nvar min$1       = Math.min;\nvar _toIndex = function(index, length){\n  index = _toInteger(index);\n  return index < 0 ? max(index + length, 0) : min$1(index, length);\n};\n\n// false -> Array#indexOf\n// true  -> Array#includes\n\nvar _arrayIncludes = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = _toIobject($this)\n      , length = _toLength(O.length)\n      , index  = _toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar SHARED = '__core-js_shared__';\nvar store  = _global[SHARED] || (_global[SHARED] = {});\nvar _shared = function(key){\n  return store[key] || (store[key] = {});\n};\n\nvar id = 0;\nvar px = Math.random();\nvar _uid = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\nvar shared = _shared('keys');\nvar _sharedKey = function(key){\n  return shared[key] || (shared[key] = _uid(key));\n};\n\nvar arrayIndexOf = _arrayIncludes(false);\nvar IE_PROTO$1     = _sharedKey('IE_PROTO');\n\nvar _objectKeysInternal = function(object, names){\n  var O      = _toIobject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO$1)_has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(_has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n// IE 8- don't enum bug keys\nvar _enumBugKeys = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\n\nvar _objectKeys = Object.keys || function keys(O){\n  return _objectKeysInternal(O, _enumBugKeys);\n};\n\nvar _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties){\n  _anObject(O);\n  var keys   = _objectKeys(Properties)\n    , length = keys.length\n    , i = 0\n    , P;\n  while(length > i)_objectDp.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\nvar _html = _global.document && document.documentElement;\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar IE_PROTO    = _sharedKey('IE_PROTO');\nvar Empty       = function(){ /* empty */ };\nvar PROTOTYPE$1   = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = _domCreate('iframe')\n    , i      = _enumBugKeys.length\n    , lt     = '<'\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  _html.appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict[PROTOTYPE$1][_enumBugKeys[i]];\n  return createDict();\n};\n\nvar _objectCreate = Object.create || function create(O, Properties){\n  var result;\n  if(O !== null){\n    Empty[PROTOTYPE$1] = _anObject(O);\n    result = new Empty;\n    Empty[PROTOTYPE$1] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : _objectDps(result, Properties);\n};\n\nvar _wks = createCommonjsModule(function (module) {\nvar store      = _shared('wks')\n  , Symbol     = _global.Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n});\n\nvar def = _objectDp.f;\nvar TAG = _wks('toStringTag');\n\nvar _setToStringTag = function(it, tag, stat){\n  if(it && !_has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n_hide(IteratorPrototype, _wks('iterator'), function(){ return this; });\n\nvar _iterCreate = function(Constructor, NAME, next){\n  Constructor.prototype = _objectCreate(IteratorPrototype, {next: _propertyDesc(1, next)});\n  _setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n// 7.1.13 ToObject(argument)\n\nvar _toObject = function(it){\n  return Object(_defined(it));\n};\n\n// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar IE_PROTO$2    = _sharedKey('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nvar _objectGpo = Object.getPrototypeOf || function(O){\n  O = _toObject(O);\n  if(_has(O, IE_PROTO$2))return O[IE_PROTO$2];\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\nvar ITERATOR       = _wks('iterator');\nvar BUGGY          = !([].keys && 'next' in [].keys());\nvar FF_ITERATOR    = '@@iterator';\nvar KEYS           = 'keys';\nvar VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nvar _iterDefine = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  _iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = _objectGpo($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      _setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!_library && !_has(IteratorPrototype, ITERATOR))_hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    _hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  _iterators[NAME] = $default;\n  _iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))_redefine(proto, key, methods[key]);\n    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\nvar $at  = _stringAt(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n_iterDefine(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n// call something on iterator step with safe closing on error\n\nvar _iterCall = function(iterator, fn, value, entries){\n  try {\n    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch(e){\n    var ret = iterator['return'];\n    if(ret !== undefined)_anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n// check on default Array iterator\nvar ITERATOR$1   = _wks('iterator');\nvar ArrayProto = Array.prototype;\n\nvar _isArrayIter = function(it){\n  return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);\n};\n\nvar _createProperty = function(object, index, value){\n  if(index in object)_objectDp.f(object, index, _propertyDesc(0, value));\n  else object[index] = value;\n};\n\n// getting tag from 19.1.3.6 Object.prototype.toString()\nvar TAG$1 = _wks('toStringTag');\nvar ARG = _cof(function(){ return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key){\n  try {\n    return it[key];\n  } catch(e){ /* empty */ }\n};\n\nvar _classof = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T\n    // builtinTag case\n    : ARG ? _cof(O)\n    // ES3 arguments fallback\n    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\nvar ITERATOR$2  = _wks('iterator');\nvar core_getIteratorMethod = _core.getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR$2]\n    || it['@@iterator']\n    || _iterators[_classof(it)];\n};\n\nvar ITERATOR$3     = _wks('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR$3]();\n  riter['return'] = function(){ SAFE_CLOSING = true; };\n  Array.from(riter, function(){ throw 2; });\n} catch(e){ /* empty */ }\n\nvar _iterDetect = function(exec, skipClosing){\n  if(!skipClosing && !SAFE_CLOSING)return false;\n  var safe = false;\n  try {\n    var arr  = [7]\n      , iter = arr[ITERATOR$3]();\n    iter.next = function(){ return {done: safe = true}; };\n    arr[ITERATOR$3] = function(){ return iter; };\n    exec(arr);\n  } catch(e){ /* empty */ }\n  return safe;\n};\n\n_export(_export.S + _export.F * !_iterDetect(function(iter){ Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\n    var O       = _toObject(arrayLike)\n      , C       = typeof this == 'function' ? this : Array\n      , aLen    = arguments.length\n      , mapfn   = aLen > 1 ? arguments[1] : undefined\n      , mapping = mapfn !== undefined\n      , index   = 0\n      , iterFn  = core_getIteratorMethod(O)\n      , length, result, step, iterator;\n    if(mapping)mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if(iterFn != undefined && !(C == Array && _isArrayIter(iterFn))){\n      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){\n        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = _toLength(O.length);\n      for(result = new C(length); length > index; index++){\n        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n\nvar from$1 = _core.Array.from;\n\nvar from = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": from$1, __esModule: true };\n});\n\nvar _Array$from = unwrapExports(from);\n\nvar toConsumableArray = createCommonjsModule(function (module, exports) {\n\"use strict\";\n\nexports.__esModule = true;\n\n\n\nvar _from2 = _interopRequireDefault(from);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return (0, _from2.default)(arr);\n  }\n};\n});\n\nvar _toConsumableArray = unwrapExports(toConsumableArray);\n\nvar _addToUnscopables = function(){ /* empty */ };\n\nvar _iterStep = function(done, value){\n  return {value: value, done: !!done};\n};\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nvar es6_array_iterator = _iterDefine(Array, 'Array', function(iterated, kind){\n  this._t = _toIobject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return _iterStep(1);\n  }\n  if(kind == 'keys'  )return _iterStep(0, index);\n  if(kind == 'values')return _iterStep(0, O[index]);\n  return _iterStep(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n_iterators.Arguments = _iterators.Array;\n\n_addToUnscopables('keys');\n_addToUnscopables('values');\n_addToUnscopables('entries');\n\nvar TO_STRING_TAG = _wks('toStringTag');\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = _global[NAME]\n    , proto      = Collection && Collection.prototype;\n  if(proto && !proto[TO_STRING_TAG])_hide(proto, TO_STRING_TAG, NAME);\n  _iterators[NAME] = _iterators.Array;\n}\n\nvar f$1 = _wks;\n\nvar _wksExt = {\n\tf: f$1\n};\n\nvar iterator$2 = _wksExt.f('iterator');\n\nvar iterator = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": iterator$2, __esModule: true };\n});\n\nvar _meta = createCommonjsModule(function (module) {\nvar META     = _uid('meta')\n  , setDesc  = _objectDp.f\n  , id       = 0;\nvar isExtensible = Object.isExtensible || function(){\n  return true;\n};\nvar FREEZE = !_fails(function(){\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function(it){\n  setDesc(it, META, {value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  }});\n};\nvar fastKey = function(it, create){\n  // return primitive with prefix\n  if(!_isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if(!_has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return 'F';\n    // not necessary to add metadata\n    if(!create)return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function(it, create){\n  if(!_has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return true;\n    // not necessary to add metadata\n    if(!create)return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function(it){\n  if(FREEZE && meta.NEED && isExtensible(it) && !_has(it, META))setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY:      META,\n  NEED:     false,\n  fastKey:  fastKey,\n  getWeak:  getWeak,\n  onFreeze: onFreeze\n};\n});\n\nvar defineProperty = _objectDp.f;\nvar _wksDefine = function(name){\n  var $Symbol = _core.Symbol || (_core.Symbol = _library ? {} : _global.Symbol || {});\n  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: _wksExt.f(name)});\n};\n\nvar _keyof = function(object, el){\n  var O      = _toIobject(object)\n    , keys   = _objectKeys(O)\n    , length = keys.length\n    , index  = 0\n    , key;\n  while(length > index)if(O[key = keys[index++]] === el)return key;\n};\n\nvar f$2 = Object.getOwnPropertySymbols;\n\nvar _objectGops = {\n\tf: f$2\n};\n\nvar f$3 = {}.propertyIsEnumerable;\n\nvar _objectPie = {\n\tf: f$3\n};\n\n// all enumerable object keys, includes symbols\n\nvar _enumKeys = function(it){\n  var result     = _objectKeys(it)\n    , getSymbols = _objectGops.f;\n  if(getSymbols){\n    var symbols = getSymbols(it)\n      , isEnum  = _objectPie.f\n      , i       = 0\n      , key;\n    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n  } return result;\n};\n\n// 7.2.2 IsArray(argument)\n\nvar _isArray = Array.isArray || function isArray(arg){\n  return _cof(arg) == 'Array';\n};\n\n// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar hiddenKeys = _enumBugKeys.concat('length', 'prototype');\n\nvar f$5 = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\n  return _objectKeysInternal(O, hiddenKeys);\n};\n\nvar _objectGopn = {\n\tf: f$5\n};\n\n// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar gOPN$1      = _objectGopn.f;\nvar toString$1  = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function(it){\n  try {\n    return gOPN$1(it);\n  } catch(e){\n    return windowNames.slice();\n  }\n};\n\nvar f$4 = function getOwnPropertyNames(it){\n  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN$1(_toIobject(it));\n};\n\nvar _objectGopnExt = {\n\tf: f$4\n};\n\nvar gOPD$1           = Object.getOwnPropertyDescriptor;\n\nvar f$6 = _descriptors ? gOPD$1 : function getOwnPropertyDescriptor(O, P){\n  O = _toIobject(O);\n  P = _toPrimitive(P, true);\n  if(_ie8DomDefine)try {\n    return gOPD$1(O, P);\n  } catch(e){ /* empty */ }\n  if(_has(O, P))return _propertyDesc(!_objectPie.f.call(O, P), O[P]);\n};\n\nvar _objectGopd = {\n\tf: f$6\n};\n\n// ECMAScript 6 symbols shim\nvar META           = _meta.KEY;\nvar gOPD           = _objectGopd.f;\nvar dP$2             = _objectDp.f;\nvar gOPN           = _objectGopnExt.f;\nvar $Symbol        = _global.Symbol;\nvar $JSON          = _global.JSON;\nvar _stringify     = $JSON && $JSON.stringify;\nvar PROTOTYPE$2      = 'prototype';\nvar HIDDEN         = _wks('_hidden');\nvar TO_PRIMITIVE   = _wks('toPrimitive');\nvar isEnum         = {}.propertyIsEnumerable;\nvar SymbolRegistry = _shared('symbol-registry');\nvar AllSymbols     = _shared('symbols');\nvar OPSymbols      = _shared('op-symbols');\nvar ObjectProto$1    = Object[PROTOTYPE$2];\nvar USE_NATIVE     = typeof $Symbol == 'function';\nvar QObject        = _global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = _descriptors && _fails(function(){\n  return _objectCreate(dP$2({}, 'a', {\n    get: function(){ return dP$2(this, 'a', {value: 7}).a; }\n  })).a != 7;\n}) ? function(it, key, D){\n  var protoDesc = gOPD(ObjectProto$1, key);\n  if(protoDesc)delete ObjectProto$1[key];\n  dP$2(it, key, D);\n  if(protoDesc && it !== ObjectProto$1)dP$2(ObjectProto$1, key, protoDesc);\n} : dP$2;\n\nvar wrap = function(tag){\n  var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n  return typeof it == 'symbol';\n} : function(it){\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D){\n  if(it === ObjectProto$1)$defineProperty(OPSymbols, key, D);\n  _anObject(it);\n  key = _toPrimitive(key, true);\n  _anObject(D);\n  if(_has(AllSymbols, key)){\n    if(!D.enumerable){\n      if(!_has(it, HIDDEN))dP$2(it, HIDDEN, _propertyDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if(_has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n      D = _objectCreate(D, {enumerable: _propertyDesc(0, false)});\n    } return setSymbolDesc(it, key, D);\n  } return dP$2(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P){\n  _anObject(it);\n  var keys = _enumKeys(P = _toIobject(P))\n    , i    = 0\n    , l = keys.length\n    , key;\n  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P){\n  return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n  var E = isEnum.call(this, key = _toPrimitive(key, true));\n  if(this === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key))return false;\n  return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n  it  = _toIobject(it);\n  key = _toPrimitive(key, true);\n  if(it === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key))return;\n  var D = gOPD(it, key);\n  if(D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n  var names  = gOPN(_toIobject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n  var IS_OP  = it === ObjectProto$1\n    , names  = gOPN(IS_OP ? OPSymbols : _toIobject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto$1, key) : true))result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif(!USE_NATIVE){\n  $Symbol = function Symbol(){\n    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n    var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function(value){\n      if(this === ObjectProto$1)$set.call(OPSymbols, value);\n      if(_has(this, HIDDEN) && _has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, _propertyDesc(1, value));\n    };\n    if(_descriptors && setter)setSymbolDesc(ObjectProto$1, tag, {configurable: true, set: $set});\n    return wrap(tag);\n  };\n  _redefine($Symbol[PROTOTYPE$2], 'toString', function toString(){\n    return this._k;\n  });\n\n  _objectGopd.f = $getOwnPropertyDescriptor;\n  _objectDp.f   = $defineProperty;\n  _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;\n  _objectPie.f  = $propertyIsEnumerable;\n  _objectGops.f = $getOwnPropertySymbols;\n\n  if(_descriptors && !_library){\n    _redefine(ObjectProto$1, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  _wksExt.f = function(name){\n    return wrap(_wks(name));\n  };\n}\n\n_export(_export.G + _export.W + _export.F * !USE_NATIVE, {Symbol: $Symbol});\n\nfor(var symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), i$1 = 0; symbols.length > i$1; )_wks(symbols[i$1++]);\n\nfor(var symbols = _objectKeys(_wks.store), i$1 = 0; symbols.length > i$1; )_wksDefine(symbols[i$1++]);\n\n_export(_export.S + _export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function(key){\n    return _has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(key){\n    if(isSymbol(key))return _keyof(SymbolRegistry, key);\n    throw TypeError(key + ' is not a symbol!');\n  },\n  useSetter: function(){ setter = true; },\n  useSimple: function(){ setter = false; }\n});\n\n_export(_export.S + _export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && _export(_export.S + _export.F * (!USE_NATIVE || _fails(function(){\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it){\n    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n    var args = [it]\n      , i    = 1\n      , replacer, $replacer;\n    while(arguments.length > i)args.push(arguments[i++]);\n    replacer = args[1];\n    if(typeof replacer == 'function')$replacer = replacer;\n    if($replacer || !_isArray(replacer))replacer = function(key, value){\n      if($replacer)value = $replacer.call(this, key, value);\n      if(!isSymbol(value))return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\n_setToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\n_setToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\n_setToStringTag(_global.JSON, 'JSON', true);\n\n_wksDefine('asyncIterator');\n\n_wksDefine('observable');\n\nvar index = _core.Symbol;\n\nvar symbol = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": index, __esModule: true };\n});\n\nvar _typeof_1 = createCommonjsModule(function (module, exports) {\n\"use strict\";\n\nexports.__esModule = true;\n\n\n\nvar _iterator2 = _interopRequireDefault(iterator);\n\n\n\nvar _symbol2 = _interopRequireDefault(symbol);\n\nvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n};\n});\n\nvar _typeof = unwrapExports(_typeof_1);\n\n// most Object methods by ES6 should accept primitives\n\nvar _objectSap = function(KEY, exec){\n  var fn  = (_core.Object || {})[KEY] || Object[KEY]\n    , exp = {};\n  exp[KEY] = exec(fn);\n  _export(_export.S + _export.F * _fails(function(){ fn(1); }), 'Object', exp);\n};\n\n// 19.1.2.14 Object.keys(O)\n\n\n_objectSap('keys', function(){\n  return function keys(it){\n    return _objectKeys(_toObject(it));\n  };\n});\n\nvar keys$1 = _core.Object.keys;\n\nvar keys = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": keys$1, __esModule: true };\n});\n\nvar _Object$keys = unwrapExports(keys);\n\n// 20.1.2.3 Number.isInteger(number)\nvar floor$1    = Math.floor;\nvar _isInteger = function isInteger(it){\n  return !_isObject(it) && isFinite(it) && floor$1(it) === it;\n};\n\n// 20.1.2.3 Number.isInteger(number)\n\n\n_export(_export.S, 'Number', {isInteger: _isInteger});\n\nvar isInteger$2 = _core.Number.isInteger;\n\nvar isInteger$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": isInteger$2, __esModule: true };\n});\n\nvar _Number$isInteger = unwrapExports(isInteger$1);\n\nvar _stringWs = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n  '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\nvar space   = '[' + _stringWs + ']';\nvar non     = '\\u200b\\u0085';\nvar ltrim   = RegExp('^' + space + space + '*');\nvar rtrim   = RegExp(space + space + '*$');\n\nvar exporter = function(KEY, exec, ALIAS){\n  var exp   = {};\n  var FORCE = _fails(function(){\n    return !!_stringWs[KEY]() || non[KEY]() != non;\n  });\n  var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];\n  if(ALIAS)exp[ALIAS] = fn;\n  _export(_export.P + _export.F * FORCE, 'String', exp);\n};\n\n// 1 -> String#trimLeft\n// 2 -> String#trimRight\n// 3 -> String#trim\nvar trim = exporter.trim = function(string, TYPE){\n  string = String(_defined(string));\n  if(TYPE & 1)string = string.replace(ltrim, '');\n  if(TYPE & 2)string = string.replace(rtrim, '');\n  return string;\n};\n\nvar _stringTrim = exporter;\n\nvar $parseFloat = _global.parseFloat;\nvar $trim       = _stringTrim.trim;\n\nvar _parseFloat$3 = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str){\n  var string = $trim(String(str), 3)\n    , result = $parseFloat(string);\n  return result === 0 && string.charAt(0) == '-' ? -0 : result;\n} : $parseFloat;\n\n// 20.1.2.12 Number.parseFloat(string)\n_export(_export.S + _export.F * (Number.parseFloat != _parseFloat$3), 'Number', {parseFloat: _parseFloat$3});\n\nvar _parseFloat$1 = parseFloat;\n\nvar _parseFloat = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": _parseFloat$1, __esModule: true };\n});\n\nvar _Number$parseFloat = unwrapExports(_parseFloat);\n\n/**\n * toxic-predicate-functions v0.1.2\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n/**\n * is void element or not ? Means it will return true when val is undefined or null\n * @param  {Anything}  obj\n * @return {Boolean}   return true when val is undefined or null\n */\nfunction isVoid(obj) {\n  return obj === undefined || obj === null;\n}\n/**\n * to check whether a variable is array\n * @param {Anything} arr\n * @return {Boolean} true when it is a boolean\n */\nfunction isArray(arr) {\n  return Array.isArray(arr);\n}\n\n/**\n * 判断是否为function\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isFunction(obj) {\n  return typeof obj === 'function';\n}\n\n/**\n * 判断是否是对象\n * @param  {Anything}  obj 传入对象\n * @return {Boolean}     [description]\n */\nfunction isObject$1(obj) {\n  // incase of arrow function and array\n  return Object(obj) === obj && String(obj) === '[object Object]' && !isFunction(obj) && !isArray(obj);\n}\n/**\n * to tell you if it's a real number\n * @param  {Anything}  obj\n * @return {Boolean}   return true when it's a number\n */\nfunction isNumber(obj) {\n  return typeof obj === 'number';\n}\n/**\n * to tell you if the val can be transfer into data\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isNumeric(obj) {\n  return !isArray(obj) && obj - _Number$parseFloat(obj) + 1 >= 0;\n}\n/**\n * 判断是否为整数\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isInteger(num) {\n  return _Number$isInteger(num);\n}\n\n/**\n * 判断是否为空\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n * @example\n * \"\", {}, [], 0, null, undefined, false 为空\n */\nfunction isEmpty(obj) {\n  if (isArray(obj)) {\n    return obj.length === 0;\n  } else if (isObject$1(obj)) {\n    return _Object$keys(obj).length === 0;\n  } else {\n    return !obj;\n  }\n}\n/**\n * 判断是否为事件\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isEvent(obj) {\n  return obj instanceof Event || obj.originalEvent instanceof Event;\n}\n/**\n * 判断是否为blob\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isBlob(obj) {\n  return obj instanceof Blob;\n}\n/**\n * 判断是否为file上传的文件\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isFile(obj) {\n  return isBlob(obj) && isString(obj.name);\n}\n/**\n * 判断是否为日期对象\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isDate(obj) {\n  return Object.prototype.toString.call(obj) === '[object Date]';\n}\n/**\n * 判断是否是string\n * @param  {Anything}  str [description]\n * @return {Boolean}     [description]\n */\nfunction isString(str) {\n  return typeof str === 'string' || str instanceof String;\n}\n/**\n * is Boolean or not\n * @param  {Anything} bool\n * @return {Boolean}\n */\nfunction isBoolean(bool) {\n  return typeof bool === 'boolean';\n}\n/**\n * is a promise or not\n * @param {Anything} obj\n * @return {boolean}\n */\nfunction isPromise(obj) {\n  return !!obj && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n}\n/**\n * is Primitive type or not, whick means it will return true when data is number/string/boolean/undefined/null\n * @param  {Anyting}  val\n * @return {Boolean}  true when type is number/string/boolean/undefined/null\n */\nfunction isPrimitive(val) {\n  return isVoid(val) || isBoolean(val) || isString(val) || isNumber(val);\n}\n/**\n * 判断是否为url且必须要带有协议头\n * @param  {Anything}  str [description]\n * @return {Boolean}     [description]\n */\nfunction isUrl(str) {\n  return isString(str) && !!str.match(/^((https?|ftp|rtsp|mms):\\/\\/)(([0-9a-z_!~*'().&=+$%-]+: )?[0-9a-z_!~*'().&=+$%-]+@)?(([0-9]{1,3}\\.){3}[0-9]{1,3}|([0-9a-z_!~*'()-]+\\.)*([0-9a-z][0-9a-z-]{0,61})?[0-9a-z]\\.[a-z]{2,6}|localhost)(:[0-9]{1,4})?((\\/?)|(\\/[0-9a-z_!~*'().;?:@&=+$,%#-]+)+\\/?)$/i);\n}\n/**\n * to test if a HTML node\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isNode(obj) {\n  return !!((typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? obj instanceof Node : obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string');\n}\n/**\n * to test if a HTML element\n * @param  {Anything}  obj [description]\n * @return {Boolean}     [description]\n */\nfunction isElement(obj) {\n  return !!((typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement)) === 'object' ? obj instanceof HTMLElement : obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === 'string');\n}\n/**\n * check if node A is node B's parent or not\n * @param  {Node}  parent\n * @param  {Node}  child\n * @return {Boolean}\n */\nfunction isChildNode(parent, child) {\n  if (!isNode(parent) || !isNode(child)) {\n    return false;\n  }\n  return child.parentNode === parent;\n}\n/**\n * check if node B is node A's posterrity or not\n * @param  {Node}  parent\n * @param  {Node}  child\n * @return {Boolean}\n */\nfunction isPosterityNode(parent, child) {\n  if (!isNode(parent) || !isNode(child)) {\n    return false;\n  }\n  while (child.parentNode) {\n    child = child.parentNode;\n    if (child === parent) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * check if the string is an HTMLString\n * @param  {string}  str only accept string\n * @return {Boolean}\n */\nfunction isHTMLString(str) {\n  return (/<[^>]+?>/.test(str)\n  );\n}\n/**\n * check if is an error\n * @param {anything} val\n * @return {boolean}\n */\nfunction isError(val) {\n  return val instanceof Error;\n}\n\n/**\n * toxic-utils v0.1.3\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n/**\n * 生成深度遍历函数的处理器，常用于生成深度拷贝等\n * @param  {Function} fn 遍历到深度变量的时候的操作\n * @return {Function}     可用的操作函数\n */\nfunction genTraversalHandler(fn) {\n  function recursiveFn(source, target, key) {\n    if (isArray(source) || isObject$1(source)) {\n      target = target || (isObject$1(source) ? {} : []);\n      for (var _key in source) {\n        target[_key] = recursiveFn(source[_key], target[_key], _key);\n      }\n      return target;\n    }\n    return fn(source, target, key);\n  }\n  return recursiveFn;\n}\nvar _deepAssign = genTraversalHandler(function (val) {\n  return val;\n});\n/**\n * 对象克隆\n * @param  {Array|Object} source 传其他值会直接返回\n * @return {clone-target}        [description]\n */\nfunction deepClone(source) {\n  if (isPrimitive(source)) {\n    throw new TypeError('deepClone only accept non primitive type');\n  }\n  return _deepAssign(source);\n}\n/**\n * merge multiple objects\n * @param  {...Object} args [description]\n * @return {merge-object}         [description]\n */\nfunction deepAssign() {\n  for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  if (args.length < 2) {\n    throw new Error('deepAssign accept two and more argument');\n  }\n  for (var i = args.length - 1; i > -1; i--) {\n    if (isPrimitive(args[i])) {\n      throw new TypeError('deepAssign only accept non primitive type');\n    }\n  }\n  var target = args.shift();\n  args.forEach(function (source) {\n    return _deepAssign(source, target);\n  });\n  return target;\n}\n\n/**\n * camelize any string, e.g hello world -> helloWorld\n * @param  {string} str only accept string!\n * @return {string}     camelize string\n */\nfunction camelize(str, isBig) {\n  return str.replace(/(^|[^a-zA-Z]+)([a-zA-Z])/g, function (match, spilt, initials, index) {\n    return !isBig && index === 0 ? initials.toLowerCase() : initials.toUpperCase();\n  });\n}\n/**\n * hypenate any string e.g hello world -> hello-world\n * @param  {string} str only accept string\n * @return {string}\n */\nfunction hypenate(str) {\n  return camelize(str).replace(/([A-Z])/g, function (match) {\n    return '-' + match.toLowerCase();\n  });\n}\n\n/**\n * bind the function with some context. we have some fallback strategy here\n * @param {function} fn the function which we need to bind the context on\n * @param {any} context the context object\n */\nfunction bind(fn, context) {\n  if (fn.bind) {\n    return fn.bind(context);\n  } else if (fn.apply) {\n    return function __autobind__() {\n      for (var _len2 = arguments.length, args = Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return fn.apply(context, args);\n    };\n  } else {\n    return function __autobind__() {\n      for (var _len3 = arguments.length, args = Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return fn.call.apply(fn, [context].concat(_toConsumableArray(args)));\n    };\n  }\n}\n\n// **********************  计算类    ************************\n// 计算获取某种东西或者计算出某种东西\n// ********************************************************\n// 生成uuid\nfunction uuid() {\n  return S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4();\n}\n// 生成四个随机数\nfunction S4() {\n  return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);\n}\n// 生成任意长度的随机数\nfunction rand(length) {\n  var str = '';\n  while (str.length < length) {\n    str += S4();\n  }\n  return str.slice(0, length);\n}\n\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n_export(_export.S + _export.F * !_descriptors, 'Object', {defineProperty: _objectDp.f});\n\nvar $Object = _core.Object;\nvar defineProperty$2 = function defineProperty(it, key, desc){\n  return $Object.defineProperty(it, key, desc);\n};\n\nvar defineProperty$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": defineProperty$2, __esModule: true };\n});\n\nvar _Object$defineProperty = unwrapExports(defineProperty$1);\n\nvar _anInstance = function(it, Constructor, name, forbiddenField){\n  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n\nvar _forOf = createCommonjsModule(function (module) {\nvar BREAK       = {}\n  , RETURN      = {};\nvar exports = module.exports = function(iterable, entries, fn, that, ITERATOR){\n  var iterFn = ITERATOR ? function(){ return iterable; } : core_getIteratorMethod(iterable)\n    , f      = _ctx(fn, that, entries ? 2 : 1)\n    , index  = 0\n    , length, step, iterator, result;\n  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if(_isArrayIter(iterFn))for(length = _toLength(iterable.length); length > index; index++){\n    result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if(result === BREAK || result === RETURN)return result;\n  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){\n    result = _iterCall(iterator, f, step.value, entries);\n    if(result === BREAK || result === RETURN)return result;\n  }\n};\nexports.BREAK  = BREAK;\nexports.RETURN = RETURN;\n});\n\n// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar SPECIES   = _wks('species');\nvar _speciesConstructor = function(O, D){\n  var C = _anObject(O).constructor, S;\n  return C === undefined || (S = _anObject(C)[SPECIES]) == undefined ? D : _aFunction(S);\n};\n\n// fast apply, http://jsperf.lnkit.com/fast-apply/5\nvar _invoke = function(fn, args, that){\n  var un = that === undefined;\n  switch(args.length){\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return              fn.apply(that, args);\n};\n\nvar process$1            = _global.process;\nvar setTask            = _global.setImmediate;\nvar clearTask          = _global.clearImmediate;\nvar MessageChannel     = _global.MessageChannel;\nvar counter            = 0;\nvar queue              = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer;\nvar channel;\nvar port;\nvar run = function(){\n  var id = +this;\n  if(queue.hasOwnProperty(id)){\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function(event){\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif(!setTask || !clearTask){\n  setTask = function setImmediate(fn){\n    var args = [], i = 1;\n    while(arguments.length > i)args.push(arguments[i++]);\n    queue[++counter] = function(){\n      _invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id){\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if(_cof(process$1) == 'process'){\n    defer = function(id){\n      process$1.nextTick(_ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if(MessageChannel){\n    channel = new MessageChannel;\n    port    = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = _ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if(_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts){\n    defer = function(id){\n      _global.postMessage(id + '', '*');\n    };\n    _global.addEventListener('message', listener, false);\n  // IE8-\n  } else if(ONREADYSTATECHANGE in _domCreate('script')){\n    defer = function(id){\n      _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function(){\n        _html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function(id){\n      setTimeout(_ctx(run, id, 1), 0);\n    };\n  }\n}\nvar _task = {\n  set:   setTask,\n  clear: clearTask\n};\n\nvar macrotask = _task.set;\nvar Observer  = _global.MutationObserver || _global.WebKitMutationObserver;\nvar process$2   = _global.process;\nvar Promise   = _global.Promise;\nvar isNode$2    = _cof(process$2) == 'process';\n\nvar _microtask = function(){\n  var head, last, notify;\n\n  var flush = function(){\n    var parent, fn;\n    if(isNode$2 && (parent = process$2.domain))parent.exit();\n    while(head){\n      fn   = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch(e){\n        if(head)notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if(parent)parent.enter();\n  };\n\n  // Node.js\n  if(isNode$2){\n    notify = function(){\n      process$2.nextTick(flush);\n    };\n  // browsers with MutationObserver\n  } else if(Observer){\n    var toggle = true\n      , node   = document.createTextNode('');\n    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new\n    notify = function(){\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if(Promise && Promise.resolve){\n    var promise = Promise.resolve();\n    notify = function(){\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function(){\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(_global, flush);\n    };\n  }\n\n  return function(fn){\n    var task = {fn: fn, next: undefined};\n    if(last)last.next = task;\n    if(!head){\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n\nvar _redefineAll = function(target, src, safe){\n  for(var key in src){\n    if(safe && target[key])target[key] = src[key];\n    else _hide(target, key, src[key]);\n  } return target;\n};\n\nvar SPECIES$1     = _wks('species');\n\nvar _setSpecies = function(KEY){\n  var C = typeof _core[KEY] == 'function' ? _core[KEY] : _global[KEY];\n  if(_descriptors && C && !C[SPECIES$1])_objectDp.f(C, SPECIES$1, {\n    configurable: true,\n    get: function(){ return this; }\n  });\n};\n\nvar task               = _task.set;\nvar microtask          = _microtask();\nvar PROMISE            = 'Promise';\nvar TypeError$1          = _global.TypeError;\nvar process            = _global.process;\nvar $Promise           = _global[PROMISE];\nvar process            = _global.process;\nvar isNode$1             = _classof(process) == 'process';\nvar empty              = function(){ /* empty */ };\nvar Internal;\nvar GenericPromiseCapability;\nvar Wrapper;\n\nvar USE_NATIVE$1 = !!function(){\n  try {\n    // correct subclassing with @@species support\n    var promise     = $Promise.resolve(1)\n      , FakePromise = (promise.constructor = {})[_wks('species')] = function(exec){ exec(empty, empty); };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode$1 || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\n  } catch(e){ /* empty */ }\n}();\n\n// helpers\nvar sameConstructor = function(a, b){\n  // with library wrapper special case\n  return a === b || a === $Promise && b === Wrapper;\n};\nvar isThenable = function(it){\n  var then;\n  return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar newPromiseCapability = function(C){\n  return sameConstructor($Promise, C)\n    ? new PromiseCapability(C)\n    : new GenericPromiseCapability(C);\n};\nvar PromiseCapability = GenericPromiseCapability = function(C){\n  var resolve, reject;\n  this.promise = new C(function($$resolve, $$reject){\n    if(resolve !== undefined || reject !== undefined)throw TypeError$1('Bad Promise constructor');\n    resolve = $$resolve;\n    reject  = $$reject;\n  });\n  this.resolve = _aFunction(resolve);\n  this.reject  = _aFunction(reject);\n};\nvar perform = function(exec){\n  try {\n    exec();\n  } catch(e){\n    return {error: e};\n  }\n};\nvar notify = function(promise, isReject){\n  if(promise._n)return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function(){\n    var value = promise._v\n      , ok    = promise._s == 1\n      , i     = 0;\n    var run = function(reaction){\n      var handler = ok ? reaction.ok : reaction.fail\n        , resolve = reaction.resolve\n        , reject  = reaction.reject\n        , domain  = reaction.domain\n        , result, then;\n      try {\n        if(handler){\n          if(!ok){\n            if(promise._h == 2)onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if(handler === true)result = value;\n          else {\n            if(domain)domain.enter();\n            result = handler(value);\n            if(domain)domain.exit();\n          }\n          if(result === reaction.promise){\n            reject(TypeError$1('Promise-chain cycle'));\n          } else if(then = isThenable(result)){\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch(e){\n        reject(e);\n      }\n    };\n    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if(isReject && !promise._h)onUnhandled(promise);\n  });\n};\nvar onUnhandled = function(promise){\n  task.call(_global, function(){\n    var value = promise._v\n      , abrupt, handler, console;\n    if(isUnhandled(promise)){\n      abrupt = perform(function(){\n        if(isNode$1){\n          process.emit('unhandledRejection', value, promise);\n        } else if(handler = _global.onunhandledrejection){\n          handler({promise: promise, reason: value});\n        } else if((console = _global.console) && console.error){\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if(abrupt)throw abrupt.error;\n  });\n};\nvar isUnhandled = function(promise){\n  if(promise._h == 1)return false;\n  var chain = promise._a || promise._c\n    , i     = 0\n    , reaction;\n  while(chain.length > i){\n    reaction = chain[i++];\n    if(reaction.fail || !isUnhandled(reaction.promise))return false;\n  } return true;\n};\nvar onHandleUnhandled = function(promise){\n  task.call(_global, function(){\n    var handler;\n    if(isNode$1){\n      process.emit('rejectionHandled', promise);\n    } else if(handler = _global.onrejectionhandled){\n      handler({promise: promise, reason: promise._v});\n    }\n  });\n};\nvar $reject = function(value){\n  var promise = this;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if(!promise._a)promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function(value){\n  var promise = this\n    , then;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if(promise === value)throw TypeError$1(\"Promise can't be resolved itself\");\n    if(then = isThenable(value)){\n      microtask(function(){\n        var wrapper = {_w: promise, _d: false}; // wrap\n        try {\n          then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));\n        } catch(e){\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch(e){\n    $reject.call({_w: promise, _d: false}, e); // wrap\n  }\n};\n\n// constructor polyfill\nif(!USE_NATIVE$1){\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor){\n    _anInstance(this, $Promise, PROMISE, '_h');\n    _aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));\n    } catch(err){\n      $reject.call(this, err);\n    }\n  };\n  Internal = function Promise(executor){\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = _redefineAll($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected){\n      var reaction    = newPromiseCapability(_speciesConstructor(this, $Promise));\n      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail   = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode$1 ? process.domain : undefined;\n      this._c.push(reaction);\n      if(this._a)this._a.push(reaction);\n      if(this._s)notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function(onRejected){\n      return this.then(undefined, onRejected);\n    }\n  });\n  PromiseCapability = function(){\n    var promise  = new Internal;\n    this.promise = promise;\n    this.resolve = _ctx($resolve, promise, 1);\n    this.reject  = _ctx($reject, promise, 1);\n  };\n}\n\n_export(_export.G + _export.W + _export.F * !USE_NATIVE$1, {Promise: $Promise});\n_setToStringTag($Promise, PROMISE);\n_setSpecies(PROMISE);\nWrapper = _core[PROMISE];\n\n// statics\n_export(_export.S + _export.F * !USE_NATIVE$1, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r){\n    var capability = newPromiseCapability(this)\n      , $$reject   = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n_export(_export.S + _export.F * (_library || !USE_NATIVE$1), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x){\n    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;\n    var capability = newPromiseCapability(this)\n      , $$resolve  = capability.resolve;\n    $$resolve(x);\n    return capability.promise;\n  }\n});\n_export(_export.S + _export.F * !(USE_NATIVE$1 && _iterDetect(function(iter){\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , resolve    = capability.resolve\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      var values    = []\n        , index     = 0\n        , remaining = 1;\n      _forOf(iterable, false, function(promise){\n        var $index        = index++\n          , alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function(value){\n          if(alreadyCalled)return;\n          alreadyCalled  = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      _forOf(iterable, false, function(promise){\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  }\n});\n\nvar promise$1 = _core.Promise;\n\nvar promise = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": promise$1, __esModule: true };\n});\n\nvar _Promise = unwrapExports(promise);\n\n/**\n * chimee-helper-utils v0.1.2\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n// **********************  judgement   ************************\n/**\n * check if the code running in browser environment (not include worker env)\n * @returns {Boolean}\n */\nvar inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\n\n// **********************  对象操作  ************************\n/**\n * 转变一个类数组对象为数组\n */\nfunction makeArray(obj) {\n  return _Array$from(obj);\n}\n\n/**\n * sort Object attributes by function\n * and transfer them into array\n * @param  {Object} obj Object form from numric\n * @param  {Function} fn sort function\n * @return {Array} the sorted attirbutes array\n */\nfunction transObjectAttrIntoArray(obj) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (a, b) {\n    return +a - +b;\n  };\n\n  return _Object$keys(obj).sort(fn).reduce(function (order, key) {\n    return order.concat(obj[key]);\n  }, []);\n}\n// ********************** class operation ***************************\n// class MixinBuilder {\n//   constructor (superclass) {\n//     this.superclass = superclass || class {};\n//   }\n\n//   with (...mixins) {\n//     return mixins.reduce((c, mixin) => mixin(c), this.superclass);\n//   }\n// }\n// export const mix = (superclass) => {\n//   return new MixinBuilder(superclass);\n// };\n/**\n * run a queue one by one.If include function reject or return false it will stop\n * @param  {Array} queue the queue which we want to run one by one\n * @return {Promise}    tell us whether a queue run finished\n */\nfunction runRejectableQueue(queue) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return new _Promise(function (resolve, reject) {\n    var step = function step(index) {\n      if (index >= queue.length) {\n        resolve();\n        return;\n      }\n      var result = isFunction(queue[index]) ? queue[index].apply(queue, _toConsumableArray(args)) : queue[index];\n      if (result === false) return reject('stop');\n      return _Promise.resolve(result).then(function () {\n        return step(index + 1);\n      }).catch(function () {\n        return reject('stop');\n      });\n    };\n    step(0);\n  });\n}\n/**\n * run a queue one by one.If include function return false it will stop\n * @param  {Array} queue the queue which we want to run one by one\n * @return {boolean} tell the user if the queue run finished\n */\nfunction runStoppableQueue(queue) {\n  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  var step = function step(index) {\n    if (index >= queue.length) {\n      return true;\n    }\n    var result = isFunction(queue[index]) ? queue[index].apply(queue, _toConsumableArray(args)) : queue[index];\n    if (result === false) return false;\n    return step(++index);\n  };\n  return step(0);\n}\n/**\n * set an attribute to an object which is frozen.\n * Means you can't remove it, iterate it or rewrite it.\n * @param {!primitive} obj\n * @param {string} key\n * @param {Anything} value\n */\nfunction setFrozenAttr(obj, key, value) {\n  if (isPrimitive(obj)) throw TypeError('setFrozenAttr obj parameter can not be primitive type');\n  if (!isString(key)) throw TypeError('setFrozenAttr key parameter must be String');\n  _Object$defineProperty(obj, key, {\n    value: value,\n    configurable: false,\n    enumerable: false,\n    writable: false\n  });\n}\n/**\n * set attr on an Object. We will bind getter and setter on it if you provide to us\n * @param {!primitive} obj\n * @param {string} key\n * @param {Function} options.get\n * @param {Function} options.set\n * @param {String} prefix the origin data's prefix. We do not plan to save it by closure.\n */\nfunction setAttrGetterAndSetter(obj, key) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      get = _ref.get,\n      set = _ref.set;\n\n  var prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '__';\n\n  if (isPrimitive(obj)) throw TypeError('setFrozenAttr obj parameter can not be primitive type');\n  if (!isString(key)) throw TypeError('setAttrGetterAndSetter key parameter must be String');\n  var originalData = obj[key];\n  if (!isFunction(get)) {\n    _Object$defineProperty(obj, prefix + key, {\n      value: originalData,\n      configurable: true,\n      writable: true,\n      enumerable: false\n    });\n    get = function get() {\n      return this[prefix + key];\n    };\n    if (set && isFunction(set)) {\n      var originSetter = set;\n      set = function set() {\n        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        this[prefix + key] = originSetter.call.apply(originSetter, [this].concat(args));\n      };\n    }\n  }\n  _Object$defineProperty(obj, key, { get: get, set: set });\n}\n\nfunction checkContinuation(uint8array, start, checkLength) {\n  var array = uint8array;\n  if (start + checkLength < array.length) {\n    while (checkLength--) {\n      if ((array[++start] & 0xC0) !== 0x80) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// decodeUTF8\nfunction decodeUTF8(uint8array) {\n  var out = [];\n  var input = uint8array;\n  var i = 0;\n  var length = uint8array.length;\n\n  while (i < length) {\n    if (input[i] < 0x80) {\n      out.push(String.fromCharCode(input[i]));\n      ++i;\n      continue;\n    } else if (input[i] < 0xC0) {\n      // fallthrough\n    } else if (input[i] < 0xE0) {\n      if (checkContinuation(input, i, 1)) {\n        var ucs4 = (input[i] & 0x1F) << 6 | input[i + 1] & 0x3F;\n        if (ucs4 >= 0x80) {\n          out.push(String.fromCharCode(ucs4 & 0xFFFF));\n          i += 2;\n          continue;\n        }\n      }\n    } else if (input[i] < 0xF0) {\n      if (checkContinuation(input, i, 2)) {\n        var _ucs = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F;\n        if (_ucs >= 0x800 && (_ucs & 0xF800) !== 0xD800) {\n          out.push(String.fromCharCode(_ucs & 0xFFFF));\n          i += 3;\n          continue;\n        }\n      }\n    } else if (input[i] < 0xF8) {\n      if (checkContinuation(input, i, 3)) {\n        var _ucs2 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12 | (input[i + 2] & 0x3F) << 6 | input[i + 3] & 0x3F;\n        if (_ucs2 > 0x10000 && _ucs2 < 0x110000) {\n          _ucs2 -= 0x10000;\n          out.push(String.fromCharCode(_ucs2 >>> 10 | 0xD800));\n          out.push(String.fromCharCode(_ucs2 & 0x3FF | 0xDC00));\n          i += 4;\n          continue;\n        }\n      }\n    }\n    out.push(String.fromCharCode(0xFFFD));\n    ++i;\n  }\n  return out.join('');\n}\n\nfunction debounce(func, wait, immediate) {\n  // immediate默认为false\n  var timeout = void 0,\n      args = void 0,\n      context = void 0,\n      timestamp = void 0,\n      result = void 0;\n\n  var later = function later() {\n    // 当wait指定的时间间隔期间多次调用_.debounce返回的函数，则会不断更新timestamp的值，导致last < wait && last >= 0一直为true，从而不断启动新的计时器延时执行func\n    var last = new Date() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = new Date();\n    // 第一次调用该方法时，且immediate为true，则调用func函数\n    var callNow = immediate && !timeout;\n    // 在wait指定的时间间隔内首次调用该方法，则启动计时器定时调用func函数\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n}\n\n/**\n * 函数节流（控制函数执行频率）\n * @param  {Function} func 要节流控制的函数，必填\n * @return {Number}   wait 等待时长\n * @return {Object}   options {\n *                      leading<是否首次调用立即执行，否：则按wait设定等待到期后调用才执行>:false,\n *                      trailing<是否在调用并未到期时启用定时器，以保证一定执行>:true\n *                    }\n * @return {Object}   cxt 上下文对象\n * @return {Function}\n */\nfunction throttle(func, wait, options, cxt) {\n  /* options的默认值\n   *  表示首次调用返回值方法时，会马上调用func；否则仅会记录当前时刻，当第二次调用的时间间隔超过wait时，才调用func。\n   *  options.leading = true;\n   * 表示当调用方法时，未到达wait指定的时间间隔，则启动计时器延迟调用func函数，若后续在既未达到wait指定的时间间隔和func函数又未被调用的情况下调用返回值方法，则被调用请求将被丢弃。\n   *  options.trailing = true;\n   * 注意：当options.trailing = false时，效果与上面的简单实现效果相同\n   */\n  var context = void 0,\n      args = void 0,\n      result = void 0;\n  var timeout = null;\n  var previous = 0;\n  if (!options) options = {};\n  var later = function later() {\n    previous = options.leading === false ? 0 : new Date() - 0;\n    timeout = null;\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n  wait = wait || 0;\n  return function () {\n    var now = new Date();\n    if (!previous && options.leading === false) previous = now;\n    // 计算剩余时间\n    var remaining = wait - (now - previous);\n    if (cxt) {\n      context = cxt;\n    } else {\n      context = this;\n    }\n\n    args = arguments;\n    // 当到达wait指定的时间间隔，则调用func函数\n    // 精彩之处：按理来说remaining <= 0已经足够证明已经到达wait的时间间隔，但这里还考虑到假如客户端修改了系统时间则马上执行func函数。\n    if (remaining <= 0 || remaining > wait) {\n      // 由于setTimeout存在最小时间精度问题，因此会存在到达wait的时间间隔，但之前设置的setTimeout操作还没被执行，因此为保险起见，这里先清理setTimeout操作\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      // options.trailing=true时，延时执行func函数\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\n\n// requestAnimationFrame\nvar raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (cb) {\n  return setTimeout(cb, 17);\n};\n\n// cancelAnimationFrame\nvar caf = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame || function (id) {\n  clearTimeout(id);\n};\n\n// 根据要求的位数，将9格式化为 09\\009\\0009...\nfunction strRepeat(num, bit) {\n  var pBit = bit;\n  num = '' + (num || '');\n  var numLen = num.length;\n  bit = (bit || numLen) - numLen;\n  var paddingStr = bit > 0 ? num.repeat ? '0'.repeat(bit) : new Array(bit + 1).join('0') : '';\n  return (paddingStr + num).slice(0, pBit);\n}\n\n// video 时间格式化\nfunction formatTime(time) {\n  var hh = Math.floor(time / 3600);\n  time = Math.floor(time % 3600);\n  var mm = strRepeat(Math.floor(time / 60), 2);\n  time = Math.floor(time % 60);\n  var ss = strRepeat(time, 2);\n  return hh >= 1 ? hh + ':' + mm + ':' + ss : mm + ':' + ss;\n}\n\n/**\n * 给obj对象扩展上trans方法，用以实现methodName对应的属性方法包装为静态函数且保持上下文的功能\n * @param  {Object} obj 目标对象\n */\nfunction addTransMethod(obj) {\n  setFrozenAttr(obj, 'trans', function (methodName) {\n    if (!obj.__fns) {\n      setFrozenAttr(obj, '__fns', {});\n    }\n    if (!obj.__fns[methodName]) {\n      obj.__fns[methodName] = function () {\n        if (!isFunction(obj[methodName])) throw TypeError('obj.trans(methodName) parameter must be Function');\n        return obj[methodName].apply(obj, arguments);\n      };\n    }\n    return obj.__fns[methodName];\n  });\n}\n\n/**\n * 追加样式代码到head的style标签，不存在则创建\n * @param {String} cssText 样式文本\n * @return {HTMLElement}\n */\nfunction appendCSS(cssText) {\n  var doc = document;\n  var styleEl = doc.querySelector('style');\n  if (!styleEl) {\n    styleEl = doc.createElement('style');\n    var header = doc.querySelector('head');\n    header && header.appendChild(styleEl);\n  }\n  styleEl.appendChild(doc.createTextNode(cssText));\n  return styleEl;\n}\n\n/**\n * 格式化日期对象为：年-月-日 时:分:秒.毫秒\n * @param {Date} date Date日期对象\n * @param {String} pattern 要输出的日期格式，默认：`yyyy-MM-dd hh:mm:ss.i`\n * @return {String}\n */\nfunction formatDate() {\n  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n  var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'yyyy-MM-dd hh:mm:ss.i';\n\n  var year = date.getFullYear().toString();\n  var fields = {\n    M: date.getMonth() + 1,\n    d: date.getDate(),\n    h: date.getHours(),\n    m: date.getMinutes(),\n    s: date.getSeconds(),\n    i: date.getMilliseconds()\n  };\n  pattern = pattern.replace(/(y+)/ig, function (_, yearPattern) {\n    return year.substr(4 - Math.min(4, yearPattern.length));\n  });\n\n  var _loop = function _loop(i) {\n    pattern = pattern.replace(new RegExp('(' + i + '+)', 'g'), function (_, pattStr) {\n      return (fields[i] < 10 && pattStr.length > 1 ? '0' : '') + fields[i];\n    });\n  };\n\n  for (var i in fields) {\n    _loop(i);\n  }\n  return pattern;\n}\n\n/**\n * 读取本地存储的值（不支持localStorage则降级到cookie）\n * @param {String} key 目标数据key\n * @return {String}\n */\nfunction getLocalStorage(key) {\n  try {\n    return window.localStorage.getItem(key);\n  } catch (e) {\n    try {\n      var regRt = document.cookie.match(new RegExp('(^| )' + key + '=([^;]*)(;|$)'));\n      return isArray(regRt) ? unescape(regRt[2]) : '';\n    } catch (e) {\n      return '';\n    }\n  }\n}\n/**\n * 将指定key对应值写入本地存储（不支持localStorage则降级到cookie）\n * @param {String} key\n * @param {String} val\n * @return {String}\n */\nfunction setLocalStorage(key, val) {\n  try {\n    window.localStorage.setItem(key, val);\n  } catch (e) {\n    var expires = new Date();\n    // 默认存储300天\n    expires.setTime(expires.getTime() + 24 * 3600 * 1000 * 300);\n    try {\n      document.cookie = key + '=' + escape(val) + ';expires=' + expires.toUTCString() + ';path=/;';\n    } catch (e) {}\n  }\n}\n\nvar classCallCheck = createCommonjsModule(function (module, exports) {\n\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n});\n\nvar _classCallCheck = unwrapExports(classCallCheck);\n\nvar createClass = createCommonjsModule(function (module, exports) {\n\"use strict\";\n\nexports.__esModule = true;\n\n\n\nvar _defineProperty2 = _interopRequireDefault(defineProperty$1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n});\n\nvar _createClass = unwrapExports(createClass);\n\n// 19.1.2.1 Object.assign(target, source, ...)\nvar $assign  = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nvar _objectAssign = !$assign || _fails(function(){\n  var A = {}\n    , B = {}\n    , S = Symbol()\n    , K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function(k){ B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n  var T     = _toObject(target)\n    , aLen  = arguments.length\n    , index = 1\n    , getSymbols = _objectGops.f\n    , isEnum     = _objectPie.f;\n  while(aLen > index){\n    var S      = _iobject(arguments[index++])\n      , keys   = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S)\n      , length = keys.length\n      , j      = 0\n      , key;\n    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n  } return T;\n} : $assign;\n\n// 19.1.3.1 Object.assign(target, source)\n\n\n_export(_export.S + _export.F, 'Object', {assign: _objectAssign});\n\nvar assign$1 = _core.Object.assign;\n\nvar assign = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": assign$1, __esModule: true };\n});\n\nvar _Object$assign = unwrapExports(assign);\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n_export(_export.S, 'Object', {create: _objectCreate});\n\nvar $Object$1 = _core.Object;\nvar create$1 = function create(P, D){\n  return $Object$1.create(P, D);\n};\n\nvar create = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": create$1, __esModule: true };\n});\n\nvar _Object$create = unwrapExports(create);\n\n/**\n * chimee-helper-events v0.1.0\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n/**\n* @module event\n* @author huzunjie\n* @description 自定义事件基础类\n*/\n\n/* 缓存事件监听方法及包装，内部数据格式：\n * targetIndex_<type:'click|mouseup|done'>: [ [\n *   function(){ ... handler ... },\n *   function(){ ... handlerWrap ... handler.apply(target, arguments) ... },\n *   isOnce\n * ]]\n */\nvar _evtListenerCache = _Object$create(null);\n_evtListenerCache.count = 0;\n\n/**\n * 得到某对象的某事件类型对应的监听队列数组\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型(这里的时间类型不只是名称，还是缓存标识，可以通过添加后缀来区分)\n * @return {Array}\n */\nfunction getEvtTypeCache(target, type) {\n\n  var evtId = target.__evt_id;\n  if (!evtId) {\n\n    /* 设置__evt_id不可枚举 */\n    Object.defineProperty(target, '__evt_id', {\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n\n    /* 空对象初始化绑定索引 */\n    evtId = target.__evt_id = ++_evtListenerCache.count;\n  }\n\n  var typeCacheKey = evtId + '_' + type;\n  var evtTypeCache = _evtListenerCache[typeCacheKey];\n  if (!evtTypeCache) {\n    evtTypeCache = _evtListenerCache[typeCacheKey] = [];\n  }\n\n  return evtTypeCache;\n}\n\n/**\n * 触发事件监听方法\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型\n * @param {Object} eventObj 触发事件时要传回的event对象\n * @return {undefined}\n */\nfunction emitEventCache(target, type, eventObj) {\n  var evt = _Object$create(null);\n  evt.type = type;\n  evt.target = target;\n  if (eventObj) {\n    _Object$assign(evt, isObject$1(eventObj) ? eventObj : { data: eventObj });\n  }\n  getEvtTypeCache(target, type).forEach(function (item) {\n    (item[1] || item[0]).apply(target, [evt]);\n  });\n}\n\n/**\n * 添加事件监听到缓存\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型\n * @param {Function} handler 监听函数\n * @param {Boolean} isOnce 是否单次执行\n * @param {Function} handlerWrap\n * @return {undefined}\n */\nfunction addEventCache(target, type, handler) {\n  var isOnce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var handlerWrap = arguments[4];\n\n  if (isFunction(isOnce) && !handlerWrap) {\n    handlerWrap = isOnce;\n    isOnce = undefined;\n  }\n  var handlers = [handler, undefined, isOnce];\n  if (isOnce && !handlerWrap) {\n    handlerWrap = function handlerWrap() {\n      removeEventCache(target, type, handler, isOnce);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      handler.apply(target, args);\n    };\n  }\n  if (handlerWrap) {\n    handlers[1] = handlerWrap;\n  }\n  getEvtTypeCache(target, type).push(handlers);\n}\n\n/**\n * 移除事件监听\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型\n * @param {Function} handler 监听函数\n * @return {undefined}\n */\nfunction removeEventCache(target, type, handler) {\n  var isOnce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  var typeCache = getEvtTypeCache(target, type);\n\n  if (handler || isOnce) {\n    /* 有指定 handler 则清除对应监听 */\n    var handlerId = -1;\n    var handlerWrap = void 0;\n    typeCache.find(function (item, i) {\n      if ((!handler || item[0] === handler) && (!isOnce || item[2])) {\n        handlerId = i;\n        handlerWrap = item[1];\n        return true;\n      }\n    });\n    if (handlerId !== -1) {\n      typeCache.splice(handlerId, 1);\n    }\n    return handlerWrap;\n  } else {\n    /* 未指定 handler 则清除type对应的所有监听 */\n    typeCache.length = 0;\n  }\n}\n\n/**\n * @class CustEvent\n * @description\n * Event 自定义事件类\n * 1. 可以使用不传参得到的实例作为eventBus使用\n * 2. 可以通过指定target，用多个实例操作同一target对象的事件管理\n * 3. 当设定target时，可以通过设置assign为true，来给target实现\"on\\once\\off\\emit\"方法\n * @param  {Object}  target 发生事件的对象（空则默认为event实例）\n * @param  {Boolean}  assign 是否将\"on\\once\\off\\emit\"方法实现到target对象上\n * @return {event}\n */\nvar CustEvent = function () {\n  function CustEvent(target, assign$$1) {\n    var _this = this;\n\n    _classCallCheck(this, CustEvent);\n\n    /* 设置__target不可枚举 */\n    Object.defineProperty(this, '__target', {\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n    this.__target = this;\n\n    if (target) {\n\n      if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== 'object') {\n        throw new Error('CusEvent target are not object');\n      }\n      this.__target = target;\n\n      /* 为target实现on\\once\\off\\emit */\n      if (assign$$1) {\n        ['on', 'once', 'off', 'emit'].forEach(function (mth) {\n          target[mth] = _this[mth];\n        });\n      }\n    }\n  }\n\n  /**\n   * 添加事件监听\n   * @param {String} type 事件类型\n   * @param {Function} handler 监听函数\n   * @param {Boolean} isOnce 单次监听类型\n   * @return {event}\n   */\n\n\n  _createClass(CustEvent, [{\n    key: 'on',\n    value: function on(type, handler) {\n      var isOnce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      addEventCache(this.__target, type, handler, isOnce);\n      return this;\n    }\n\n    /**\n     * 添加事件监听,并且只执行一次\n     * @param {String} type 事件类型\n     * @param {Function} handler 监听函数\n     * @return {event}\n     */\n\n  }, {\n    key: 'once',\n    value: function once(type, handler) {\n      return this.on(type, handler, true);\n    }\n\n    /**\n     * 移除事件监听\n     * @param {String} type 事件类型\n     * @param {Function} handler 监听函数(不指定handler则清除type对应的所有事件监听)\n     * @param {Boolean} isOnce 单次监听类型\n     * @return {event}\n     */\n\n  }, {\n    key: 'off',\n    value: function off(type, handler) {\n      var isOnce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      removeEventCache(this.__target, type, handler, isOnce);\n      return this;\n    }\n\n    /**\n     * 触发事件监听函数\n     * @param {String} type 事件类型\n     * @return {event}\n     */\n\n  }, {\n    key: 'emit',\n    value: function emit(type, data) {\n      emitEventCache(this.__target, type, { data: data });\n      return this;\n    }\n  }]);\n\n  return CustEvent;\n}();\n\n/**\n * chimee-helper-dom v0.1.0\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n/**\n * chimee-helper-events v0.1.0\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n/**\n* @module event\n* @author huzunjie\n* @description 自定义事件基础类\n*/\n\n/* 缓存事件监听方法及包装，内部数据格式：\n * targetIndex_<type:'click|mouseup|done'>: [ [\n *   function(){ ... handler ... },\n *   function(){ ... handlerWrap ... handler.apply(target, arguments) ... },\n *   isOnce\n * ]]\n */\nvar _evtListenerCache$1 = _Object$create(null);\n_evtListenerCache$1.count = 0;\n\n/**\n * 得到某对象的某事件类型对应的监听队列数组\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型(这里的时间类型不只是名称，还是缓存标识，可以通过添加后缀来区分)\n * @return {Array}\n */\nfunction getEvtTypeCache$1(target, type) {\n\n  var evtId = target.__evt_id;\n  if (!evtId) {\n\n    /* 设置__evt_id不可枚举 */\n    Object.defineProperty(target, '__evt_id', {\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n\n    /* 空对象初始化绑定索引 */\n    evtId = target.__evt_id = ++_evtListenerCache$1.count;\n  }\n\n  var typeCacheKey = evtId + '_' + type;\n  var evtTypeCache = _evtListenerCache$1[typeCacheKey];\n  if (!evtTypeCache) {\n    evtTypeCache = _evtListenerCache$1[typeCacheKey] = [];\n  }\n\n  return evtTypeCache;\n}\n\n/**\n * 触发事件监听方法\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型\n * @param {Object} eventObj 触发事件时要传回的event对象\n * @return {undefined}\n */\nfunction emitEventCache$1(target, type, eventObj) {\n  var evt = _Object$create(null);\n  evt.type = type;\n  evt.target = target;\n  if (eventObj) {\n    _Object$assign(evt, isObject$1(eventObj) ? eventObj : { data: eventObj });\n  }\n  getEvtTypeCache$1(target, type).forEach(function (item) {\n    (item[1] || item[0]).apply(target, [evt]);\n  });\n}\n\n/**\n * 添加事件监听到缓存\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型\n * @param {Function} handler 监听函数\n * @param {Boolean} isOnce 是否单次执行\n * @param {Function} handlerWrap\n * @return {undefined}\n */\nfunction addEventCache$1(target, type, handler) {\n  var isOnce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var handlerWrap = arguments[4];\n\n  if (isFunction(isOnce) && !handlerWrap) {\n    handlerWrap = isOnce;\n    isOnce = undefined;\n  }\n  var handlers = [handler, undefined, isOnce];\n  if (isOnce && !handlerWrap) {\n    handlerWrap = function handlerWrap() {\n      removeEventCache$1(target, type, handler, isOnce);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      handler.apply(target, args);\n    };\n  }\n  if (handlerWrap) {\n    handlers[1] = handlerWrap;\n  }\n  getEvtTypeCache$1(target, type).push(handlers);\n}\n\n/**\n * 移除事件监听\n * @param  {Object}  target 发生事件的对象\n * @param {String} type 事件类型\n * @param {Function} handler 监听函数\n * @return {undefined}\n */\nfunction removeEventCache$1(target, type, handler) {\n  var isOnce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  var typeCache = getEvtTypeCache$1(target, type);\n\n  if (handler || isOnce) {\n    /* 有指定 handler 则清除对应监听 */\n    var handlerId = -1;\n    var handlerWrap = void 0;\n    typeCache.find(function (item, i) {\n      if ((!handler || item[0] === handler) && (!isOnce || item[2])) {\n        handlerId = i;\n        handlerWrap = item[1];\n        return true;\n      }\n    });\n    if (handlerId !== -1) {\n      typeCache.splice(handlerId, 1);\n    }\n    return handlerWrap;\n  } else {\n    /* 未指定 handler 则清除type对应的所有监听 */\n    typeCache.length = 0;\n  }\n}\n\n/**\n * @class CustEvent\n * @description\n * Event 自定义事件类\n * 1. 可以使用不传参得到的实例作为eventBus使用\n * 2. 可以通过指定target，用多个实例操作同一target对象的事件管理\n * 3. 当设定target时，可以通过设置assign为true，来给target实现\"on\\once\\off\\emit\"方法\n * @param  {Object}  target 发生事件的对象（空则默认为event实例）\n * @param  {Boolean}  assign 是否将\"on\\once\\off\\emit\"方法实现到target对象上\n * @return {event}\n */\nvar CustEvent$1 = function () {\n  function CustEvent(target, assign$$1) {\n    var _this = this;\n\n    _classCallCheck(this, CustEvent);\n\n    /* 设置__target不可枚举 */\n    Object.defineProperty(this, '__target', {\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n    this.__target = this;\n\n    if (target) {\n\n      if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== 'object') {\n        throw new Error('CusEvent target are not object');\n      }\n      this.__target = target;\n\n      /* 为target实现on\\once\\off\\emit */\n      if (assign$$1) {\n        ['on', 'once', 'off', 'emit'].forEach(function (mth) {\n          target[mth] = _this[mth];\n        });\n      }\n    }\n  }\n\n  /**\n   * 添加事件监听\n   * @param {String} type 事件类型\n   * @param {Function} handler 监听函数\n   * @param {Boolean} isOnce 单次监听类型\n   * @return {event}\n   */\n\n\n  _createClass(CustEvent, [{\n    key: 'on',\n    value: function on(type, handler) {\n      var isOnce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      addEventCache$1(this.__target, type, handler, isOnce);\n      return this;\n    }\n\n    /**\n     * 添加事件监听,并且只执行一次\n     * @param {String} type 事件类型\n     * @param {Function} handler 监听函数\n     * @return {event}\n     */\n\n  }, {\n    key: 'once',\n    value: function once(type, handler) {\n      return this.on(type, handler, true);\n    }\n\n    /**\n     * 移除事件监听\n     * @param {String} type 事件类型\n     * @param {Function} handler 监听函数(不指定handler则清除type对应的所有事件监听)\n     * @param {Boolean} isOnce 单次监听类型\n     * @return {event}\n     */\n\n  }, {\n    key: 'off',\n    value: function off(type, handler) {\n      var isOnce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      removeEventCache$1(this.__target, type, handler, isOnce);\n      return this;\n    }\n\n    /**\n     * 触发事件监听函数\n     * @param {String} type 事件类型\n     * @return {event}\n     */\n\n  }, {\n    key: 'emit',\n    value: function emit(type, data) {\n      emitEventCache$1(this.__target, type, { data: data });\n      return this;\n    }\n  }]);\n\n  return CustEvent;\n}();\n\n/**\n * chimee-helper-utils v0.1.1\n * (c) 2017 toxic-johann\n * Released under MIT\n */\n\n// **********************  judgement   ************************\n/**\n * check if the code running in browser environment (not include worker env)\n * @returns {Boolean}\n */\nvar inBrowser$1 = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\n\n// **********************  对象操作  ************************\n/**\n * 转变一个类数组对象为数组\n */\nfunction makeArray$1(obj) {\n  return _Array$from(obj);\n}\n\n/**\n* @module dom\n* @author huzunjie\n* @description 一些常用的DOM判断及操作方法，可以使用dom.$('*')包装DOM，实现类jQuery的链式操作；当然这里的静态方法也可以直接使用。\n*/\n\nvar _divEl = document.createElement('div');\nvar _textAttrName = 'innerText';\n'textContent' in _divEl && (_textAttrName = 'textContent');\nvar _arrPrototype = Array.prototype;\n\n/**\n * 读取HTML元素属性值\n * @param {HTMLElement} el 目标元素\n * @param {String} attrName 目标属性名称\n * @return {String}\n */\nfunction getAttr(el, attrName) {\n  return el.getAttribute(attrName);\n}\n\n/**\n * 设置HTML元素属性值\n * @param {HTMLElement} el 目标元素\n * @param {String} attrName 目标属性名称\n * @param {String} attrVal 目标属性值\n */\nfunction setAttr(el, attrName, attrVal) {\n  if (attrVal === undefined) {\n    el.removeAttribute(attrName);\n  } else {\n    el.setAttribute(attrName, attrVal);\n  }\n}\n\n/**\n * 为HTML元素添加className\n * @param {HTMLElement} el 目标元素\n * @param {String} cls 要添加的className（多个以空格分割）\n */\nfunction addClassName(el, cls) {\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n  var clsArr = cls.split(/\\s+/);\n  if (el.classList) {\n    clsArr.forEach(function (c) {\n      return el.classList.add(c);\n    });\n  } else {\n    var curCls = ' ' + (el.className || '') + ' ';\n    clsArr.forEach(function (c) {\n      curCls.indexOf(' ' + c + ' ') === -1 && (curCls += ' ' + c);\n    });\n    el.className = curCls.trim();\n  }\n}\n\n/**\n * 为HTML元素移除className\n * @param {HTMLElement} el 目标元素\n * @param {String} cls 要移除的className（多个以空格分割）\n */\nfunction removeClassName(el, cls) {\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n\n  var clsArr = cls.split(/\\s+/);\n  if (el.classList) {\n    clsArr.forEach(function (c) {\n      return el.classList.remove(c);\n    });\n  } else {\n    var curCls = ' ' + el.className + ' ';\n    clsArr.forEach(function (c) {\n      var tar = ' ' + c + ' ';\n      while (curCls.indexOf(tar) !== -1) {\n        curCls = curCls.replace(tar, ' ');\n      }\n    });\n    el.className = curCls.trim();\n  }\n}\n\n/**\n * 检查HTML元素是否已设置className\n * @param {HTMLElement} el 目标元素\n * @param {String} className 要检查的className\n * @return {Boolean}\n */\nfunction hasClassName(el, className) {\n  return new RegExp('(?:^|\\\\s)' + className + '(?=\\\\s|$)').test(el.className);\n}\n\n/**\n * 为HTML元素移除事件监听\n * @param {HTMLElement} el 目标元素\n * @param {String} type 事件名称\n * @param {Function} handler 处理函数\n * @param {Boolean} once 是否只监听一次\n * @param {Boolean} capture 是否在捕获阶段的监听\n */\nfunction removeEvent(el, type, handler) {\n  var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  if (once) {\n    /* 尝试从缓存中读取包装后的方法 */\n    var handlerWrap = removeEventCache$1(el, type + '_once', handler);\n    if (handlerWrap) {\n      handler = handlerWrap;\n    }\n  }\n  el.removeEventListener(type, handler, capture);\n}\n\n/**\n * 为HTML元素添加事件监听\n * @param {HTMLElement} el 目标元素\n * @param {String} type 事件名称\n * @param {Function} handler 处理函数\n * @param {Boolean} once 是否只监听一次\n * @param {Boolean} capture 是否在捕获阶段监听\n */\nfunction addEvent(el, type, handler) {\n  var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  if (once) {\n    var oldHandler = handler;\n    handler = function () {\n      return function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        oldHandler.apply(this, args);\n        removeEvent(el, type, handler, once, capture);\n      };\n    }();\n    /* 将包装后的方法记录到缓存中 */\n    addEventCache$1(el, type + '_once', oldHandler, handler);\n  }\n\n  el.addEventListener(type, handler, capture);\n}\n\n/**\n * 为HTML元素添加事件代理\n * @param {HTMLElement} el 目标元素\n * @param {String} selector 要被代理的元素\n * @param {String} type 事件名称\n * @param {Function} handler 处理函数\n * @param {Boolean} capture 是否在捕获阶段监听\n */\nfunction addDelegate(el, selector, type, handler) {\n  var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n\n  var handlerWrap = function handlerWrap(e) {\n    var targetEls = findParents(e.srcElement, el, true);\n    var targetEl = query(selector, el, true).find(function (seEl) {\n      return targetEls.find(function (tgEl) {\n        return seEl === tgEl;\n      });\n    });\n    targetEl && handler.apply(targetEl, arguments);\n  };\n  /* 将包装后的方法记录到缓存中 */\n  addEventCache$1(el, type + '_delegate_' + selector, handler, handlerWrap);\n  el.addEventListener(type, handlerWrap, capture);\n}\n\n/**\n * 为HTML元素移除事件代理\n * @param {HTMLElement} el 目标元素\n * @param {String} selector 要被代理的元素\n * @param {String} type 事件名称\n * @param {Function} handler 处理函数\n * @param {Boolean} capture 是否在捕获阶段监听\n */\nfunction removeDelegate(el, selector, type, handler) {\n  var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  /* 尝试从缓存中读取包装后的方法 */\n  var handlerWrap = removeEventCache$1(el, type + '_delegate_' + selector, handler);\n  handlerWrap && el.removeEventListener(type, handlerWrap, capture);\n}\n\n/**\n * 读取HTML元素样式值\n * @param {HTMLElement} el 目标元素\n * @param {String} key 样式key\n * @return {String}\n */\nfunction getStyle(el, key) {\n  return (el.currentStyle || document.defaultView.getComputedStyle(el, null))[key] || el.style[key];\n}\n\n/**\n * 设置HTML元素样式值\n * @param {HTMLElement} el 目标元素\n * @param {String} key 样式key\n * @param {String} val 样式值\n */\nfunction setStyle(el, key, val) {\n  if (isObject$1(key)) {\n    for (var k in key) {\n      setStyle(el, k, key[k]);\n    }\n  } else {\n    el.style[key] = val;\n  }\n}\n\n/**\n * 根据选择器查询目标元素\n * @param {String} selector 选择器,用于 querySelectorAll\n * @param {HTMLElement} container 父容器\n * @param {Boolean} toArray 强制输出为数组\n * @return {NodeList|Array}\n */\nfunction query(selector) {\n  var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n  var toArray = arguments[2];\n\n  var retNodeList = container.querySelectorAll(selector);\n  return toArray ? _Array$from(retNodeList) : retNodeList;\n}\n\n/**\n * 从DOM树中移除el\n * @param {HTMLElement} el 目标元素\n */\nfunction removeEl(el) {\n  el.parentNode.removeChild(el);\n}\n\n/**\n * 查找元素的父节点们\n * @param {HTMLElement} el 目标元素\n * @param {HTMLElement} endEl 最大父容器（不指定则找到html）\n * @param {Boolean} haveEl 包含当前元素\n * @param {Boolean} haveEndEl 包含设定的最大父容器\n */\nfunction findParents(el) {\n  var endEl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var haveEl = arguments[2];\n  var haveEndEl = arguments[3];\n\n  var retEls = [];\n  if (haveEl) {\n    retEls.push(el);\n  }\n  while (el && el.parentNode !== endEl) {\n    el = el.parentNode;\n    el && retEls.push(el);\n  }\n  if (haveEndEl) {\n    retEls.push(endEl);\n  }\n  return retEls;\n}\n\n/**\n * 根据选择器查询并得到目标元素的wrap包装器\n * @param {String} selector 选择器,另外支持 HTMLString||NodeList||NodeArray||HTMLElement\n * @param {HTMLElement} container 父容器\n * @return {Object}\n */\nfunction $(selector, container) {\n  return selector.constructor === NodeWrap ? selector : new NodeWrap(selector, container);\n}\n\n/**\n * @class NodeWrap\n * @description\n * NodeWrap DOM包装器，用以实现基本的链式操作\n * new dom.NodeWrap('*') 相当于 dom.$('*')\n * 这里面用于DOM操作的属性方法都是基于上面静态方法实现，有需要可以随时修改补充\n * @param {String} selector 选择器(兼容 String||HTMLString||NodeList||NodeArray||HTMLElement)\n * @param {HTMLElement} container 父容器（默认为document）\n */\n\nvar NodeWrap = function () {\n  function NodeWrap(selector) {\n    var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n\n    _classCallCheck(this, NodeWrap);\n\n    var _this = this;\n    _this.selector = selector;\n\n    /* String||NodeList||HTMLElement 识别处理 */\n    var elsArr = void 0;\n    if (selector && selector.constructor === NodeList) {\n      /* 支持直接传入NodeList来构建包装器 */\n      elsArr = makeArray$1(selector);\n    } else if (isArray(selector)) {\n      /* 支持直接传入Node数组来构建包装器 */\n      elsArr = selector;\n    } else if (isString(selector)) {\n      if (selector.indexOf('<') === 0) {\n        /* 支持直接传入HTML字符串来新建DOM并构建包装器 */\n        _divEl.innerHTML = selector;\n        elsArr = query('*', _divEl, true);\n      } else {\n        /* 支持直接传入字符串选择器来查找DOM并构建包装器 */\n        elsArr = query(selector, container, true);\n      }\n    } else {\n      /* 其他任意对象直接构建包装器 */\n      elsArr = [selector];\n    }\n    _Object$assign(_this, elsArr);\n\n    /* NodeWrap本意可以 extends Array省略构造方法中下面这部分代码，但目前编译不支持 */\n    _this.length = elsArr.length;\n  }\n\n  /**\n   * 循环遍历DOM集合\n   * @param {Function} fn 遍历函数 fn(item, i)\n   * @return {Object}\n   */\n\n\n  _createClass(NodeWrap, [{\n    key: 'each',\n    value: function each() {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _arrPrototype.forEach.apply(this, args);\n      return this;\n    }\n  }, {\n    key: 'push',\n\n\n    /**\n     * 添加元素到DOM集合\n     * @param {HTMLElement} el 要加入的元素\n     * @return {this}\n     */\n    value: function push() {\n      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      _arrPrototype.push.apply(this, args);\n      return this;\n    }\n  }, {\n    key: 'splice',\n\n\n    /**\n     * 截取DOM集合片段，并得到新的包装器splice\n     * @param {Nubmer} start\n     * @param {Nubmer} count\n     * @return {NodeWrap} 新的DOM集合包装器\n     */\n    value: function splice() {\n      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return $(_arrPrototype.splice.apply(this, args));\n    }\n  }, {\n    key: 'find',\n\n\n    /**\n     * 查找子元素\n     * @param {String} selector 选择器\n     * @return {NodeWrap} 新的DOM集合包装器\n     */\n    value: function find(selector) {\n      var childs = [];\n      this.each(function (el) {\n        childs = childs.concat(query(selector, el, true));\n      });\n      var childsWrap = $(childs);\n      childsWrap.parent = this;\n      childsWrap.selector = selector;\n      return childsWrap;\n    }\n\n    /**\n     * 添加子元素\n     * @param {HTMLElement} childEls 要添加的HTML元素\n     * @return {this}\n     */\n\n  }, {\n    key: 'append',\n    value: function append(childEls) {\n      var childsWrap = $(childEls);\n      var firstEl = this[0];\n      childsWrap.each(function (newEl) {\n        return firstEl.appendChild(newEl);\n      });\n      return this;\n    }\n\n    /**\n     * 将元素集合添加到指定容器\n     * @param {HTMLElement} parentEl 要添加到父容器\n     * @return {this}\n     */\n\n  }, {\n    key: 'appendTo',\n    value: function appendTo(parentEl) {\n      $(parentEl).append(this);\n      return this;\n    }\n\n    /**\n     * DOM集合text内容读写操作\n     * @param {String} val 文本内容（如果有设置该参数则执行写操作，否则执行读操作）\n     * @return {this}\n     */\n\n  }, {\n    key: 'text',\n    value: function text(val) {\n      if (arguments.length === 0) {\n        return this[0][_textAttrName];\n      }\n      return this.each(function (el) {\n        el[_textAttrName] = val;\n      });\n    }\n\n    /**\n     * DOM集合HTML内容读写操作\n     * @param {String} html html内容（如果有设置该参数则执行写操作，否则执行读操作）\n     * @return {this}\n     */\n\n  }, {\n    key: 'html',\n    value: function html(_html) {\n      if (arguments.length === 0) {\n        return this[0].innerHTML;\n      }\n      return this.each(function (el) {\n        el.innerHTML = _html;\n      });\n    }\n\n    /**\n     * DOM集合属性读写操作\n     * @param {String} name 属性名称\n     * @param {String} val 属性值（如果有设置该参数则执行写操作，否则执行读操作）\n     * @return {this}\n     */\n\n  }, {\n    key: 'attr',\n    value: function attr(name, val) {\n      if (arguments.length === 1) {\n        return getAttr(this[0], name);\n      }\n      return this.each(function (el) {\n        return setAttr(el, name, val);\n      });\n    }\n\n    /**\n     * DOM集合dataset读写操作\n     * @param {String} key 键名\n     * @param {Any} val 键值（如果有设置该参数则执行写操作，否则执行读操作）\n     * @return {this}\n     */\n\n  }, {\n    key: 'data',\n    value: function data(key, val) {\n      if (arguments.length === 0) {\n        return this[0].dataset || {};\n      }\n      if (arguments.length === 1) {\n        return (this[0].dataset || {})[key];\n      }\n      return this.each(function (el) {\n        (el.dataset || (el.dataset = {}))[key] = val;\n      });\n    }\n\n    /**\n     * DOM集合样式读写操作\n     * @param {String} key 样式key\n     * @param {String} val 样式值（如果有设置该参数则执行写操作，否则执行读操作）\n     * @return {this}\n     */\n\n  }, {\n    key: 'css',\n    value: function css(key, val) {\n      if (arguments.length === 1 && !isObject$1(key)) {\n        return getStyle(this[0], key);\n      }\n      return this.each(function (el) {\n        return setStyle(el, key, val);\n      });\n    }\n\n    /**\n     * 为DOM集合增加className\n     * @param {String} cls 要增加的className\n     * @return {this}\n     */\n\n  }, {\n    key: 'addClass',\n    value: function addClass(cls) {\n      return this.each(function (el) {\n        return addClassName(el, cls);\n      });\n    }\n\n    /**\n     * 移除当前DOM集合的className\n     * @param {String} cls 要移除的className\n     * @return {this}\n     */\n\n  }, {\n    key: 'removeClass',\n    value: function removeClass(cls) {\n      return this.each(function (el) {\n        return removeClassName(el, cls);\n      });\n    }\n\n    /**\n     * 检查索引0的DOM是否有className\n     * @param {String} cls 要检查的className\n     * @return {this}\n     */\n\n  }, {\n    key: 'hasClass',\n    value: function hasClass(cls) {\n      return hasClassName(this[0], cls);\n    }\n\n    /**\n     * 为DOM集合添加事件监听\n     * @param {String} type 事件名称\n     * @param {Function} handler 处理函数\n     * @param {Boolean} once 是否只监听一次\n     * @param {Boolean} capture 是否在捕获阶段监听\n     * @return {this}\n     */\n\n  }, {\n    key: 'on',\n    value: function on(type, handler) {\n      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      return this.each(function (el) {\n        return addEvent(el, type, handler, once, capture);\n      });\n    }\n\n    /**\n     * 为DOM集合解除事件监听\n     * @param {String} type 事件名称\n     * @param {Function} handler 处理函数\n     * @param {Boolean} once 是否只监听一次\n     * @param {Boolean} capture 是否在捕获阶段监听\n     * @return {this}\n     */\n\n  }, {\n    key: 'off',\n    value: function off(type, handler) {\n      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      return this.each(function (el) {\n        return removeEvent(el, type, handler, once, capture);\n      });\n    }\n\n    /**\n     * 为DOM集合绑定事件代理\n     * @param {String} selector 目标子元素选择器\n     * @param {String} type 事件名称\n     * @param {Function} handler 处理函数\n     * @param {Boolean} capture 是否在捕获阶段监听\n     * @return {this}\n     */\n\n  }, {\n    key: 'delegate',\n    value: function delegate(selector, type, handler) {\n      var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      return this.each(function (el) {\n        return addDelegate(el, selector, type, handler, capture);\n      });\n    }\n\n    /**\n     * 为DOM集合解绑事件代理\n     * @param {String} selector 目标子元素选择器\n     * @param {String} type 事件名称\n     * @param {Function} handler 处理函数\n     * @param {Boolean} capture 是否在捕获阶段监听\n     * @return {this}\n     */\n\n  }, {\n    key: 'undelegate',\n    value: function undelegate(selector, type, handler) {\n      var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      return this.each(function (el) {\n        return removeDelegate(el, selector, type, handler, capture);\n      });\n    }\n\n    /**\n     * 从DOM树中移除\n     * @return {this}\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove() {\n      return this.each(function (el) {\n        return removeEl(el);\n      });\n    }\n  }]);\n\n  return NodeWrap;\n}();\n\n/**\n * chimee-helper-log v0.1.0\n * (c) 2017 songguangyu\n * Released under MIT\n */\n\nvar Log = function () {\n  function Log() {\n    _classCallCheck(this, Log);\n  }\n\n  _createClass(Log, null, [{\n    key: 'error',\n    value: function error(tag, msg) {\n      if (!Log.ENABLE_ERROR) {\n        return;\n      }\n\n      if (!tag || Log.FORCE_GLOBAL_TAG) {\n        tag = Log.GLOBAL_TAG;\n      }\n      var str = '[' + tag + '] > ' + msg;\n\n      if (console.error) {\n        console.error(str);\n      } else if (console.warn) {\n        console.warn(str);\n      } else {\n        console.log(str);\n      }\n    }\n  }, {\n    key: 'info',\n    value: function info(tag, msg) {\n      if (!Log.ENABLE_INFO) {\n        return;\n      }\n\n      if (!tag || Log.FORCE_GLOBAL_TAG) {\n        tag = Log.GLOBAL_TAG;\n      }\n\n      var str = '[' + tag + '] > ' + msg;\n\n      if (console.info) {\n        console.info(str);\n      } else {\n        console.log(str);\n      }\n    }\n  }, {\n    key: 'warn',\n    value: function warn(tag, msg) {\n      if (!Log.ENABLE_WARN) {\n        return;\n      }\n\n      if (!tag || Log.FORCE_GLOBAL_TAG) {\n        tag = Log.GLOBAL_TAG;\n      }\n\n      var str = '[' + tag + '] > ' + msg;\n\n      if (console.warn) {\n        console.warn(str);\n      } else {\n        console.log(str);\n      }\n    }\n  }, {\n    key: 'debug',\n    value: function debug(tag, msg) {\n      if (!Log.ENABLE_DEBUG) {\n        return;\n      }\n\n      if (!tag || Log.FORCE_GLOBAL_TAG) {\n        tag = Log.GLOBAL_TAG;\n      }\n\n      var str = '[' + tag + '] > ' + msg;\n\n      if (console.debug) {\n        console.debug(str);\n      } else {\n        console.log(str);\n      }\n    }\n  }, {\n    key: 'verbose',\n    value: function verbose(tag, msg) {\n      if (!Log.ENABLE_VERBOSE) {\n        return;\n      }\n\n      if (!tag || Log.FORCE_GLOBAL_TAG) {\n        tag = Log.GLOBAL_TAG;\n      }\n\n      console.log('[' + tag + '] > ' + msg);\n    }\n  }]);\n\n  return Log;\n}();\n\nLog.GLOBAL_TAG = 'chimee';\nLog.FORCE_GLOBAL_TAG = false;\nLog.ENABLE_ERROR = true;\nLog.ENABLE_INFO = true;\nLog.ENABLE_WARN = true;\nLog.ENABLE_DEBUG = true;\nLog.ENABLE_VERBOSE = true;\n\nexports.Log = Log;\nexports.genTraversalHandler = genTraversalHandler;\nexports.deepClone = deepClone;\nexports.deepAssign = deepAssign;\nexports.camelize = camelize;\nexports.hypenate = hypenate;\nexports.bind = bind;\nexports.uuid = uuid;\nexports.S4 = S4;\nexports.rand = rand;\nexports.isVoid = isVoid;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isObject = isObject$1;\nexports.isNumber = isNumber;\nexports.isNumeric = isNumeric;\nexports.isInteger = isInteger;\nexports.isEmpty = isEmpty;\nexports.isEvent = isEvent;\nexports.isBlob = isBlob;\nexports.isFile = isFile;\nexports.isDate = isDate;\nexports.isString = isString;\nexports.isBoolean = isBoolean;\nexports.isPromise = isPromise;\nexports.isPrimitive = isPrimitive;\nexports.isUrl = isUrl;\nexports.isNode = isNode;\nexports.isElement = isElement;\nexports.isChildNode = isChildNode;\nexports.isPosterityNode = isPosterityNode;\nexports.isHTMLString = isHTMLString;\nexports.isError = isError;\nexports.inBrowser = inBrowser;\nexports.makeArray = makeArray;\nexports.transObjectAttrIntoArray = transObjectAttrIntoArray;\nexports.runRejectableQueue = runRejectableQueue;\nexports.runStoppableQueue = runStoppableQueue;\nexports.setFrozenAttr = setFrozenAttr;\nexports.setAttrGetterAndSetter = setAttrGetterAndSetter;\nexports.decodeUTF8 = decodeUTF8;\nexports.debounce = debounce;\nexports.throttle = throttle;\nexports.raf = raf;\nexports.caf = caf;\nexports.strRepeat = strRepeat;\nexports.formatTime = formatTime;\nexports.addTransMethod = addTransMethod;\nexports.appendCSS = appendCSS;\nexports.formatDate = formatDate;\nexports.getLocalStorage = getLocalStorage;\nexports.setLocalStorage = setLocalStorage;\nexports.emitEventCache = emitEventCache;\nexports.addEventCache = addEventCache;\nexports.removeEventCache = removeEventCache;\nexports.CustEvent = CustEvent;\nexports.getAttr = getAttr;\nexports.setAttr = setAttr;\nexports.addClassName = addClassName;\nexports.removeClassName = removeClassName;\nexports.hasClassName = hasClassName;\nexports.removeEvent = removeEvent;\nexports.addEvent = addEvent;\nexports.addDelegate = addDelegate;\nexports.removeDelegate = removeDelegate;\nexports.getStyle = getStyle;\nexports.setStyle = setStyle;\nexports.query = query;\nexports.removeEl = removeEl;\nexports.findParents = findParents;\nexports.$ = $;\nexports.NodeWrap = NodeWrap;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoaW1lZS1oZWxwZXIvbGliL2luZGV4LmJyb3dzZXIuanM/YWIxNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixZQUFZLEVBQUU7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLENBQUM7O0FBRUQ7QUFDQSw2QkFBNkI7QUFDN0IscUNBQXFDO0FBQ3JDLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUSxnQkFBZ0IsVUFBVSxHQUFHO0FBQ3RFLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCxnQkFBZ0IsVUFBVSxHQUFHO0FBQ3JGLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxVQUFVO0FBQ2I7QUFDQTtBQUNB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QUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtB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T0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxjQUFjOztBQUU1RCxDQUFDIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIGNoaW1lZS1oZWxwZXIgdjAuMS44XG4gKiAoYykgMjAxNyB0b3hpYy1qb2hhbm5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVFxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5jaGltZWVIZWxwZXIgPSBnbG9iYWwuY2hpbWVlSGVscGVyIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiB1bndyYXBFeHBvcnRzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgX3RvSW50ZWdlciA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG4vLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxudmFyIF9kZWZpbmVkID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxudmFyIF9zdHJpbmdBdCA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKF9kZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gX3RvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxudmFyIF9saWJyYXJ5ID0gdHJ1ZTtcblxudmFyIF9nbG9iYWwgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG59KTtcblxudmFyIF9jb3JlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xudmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxufSk7XG5cbnZhciBfYUZ1bmN0aW9uID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcblxudmFyIF9jdHggPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgX2FGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciBfaXNPYmplY3QgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgX2FuT2JqZWN0ID0gZnVuY3Rpb24oaXQpe1xuICBpZighX2lzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cbnZhciBfZmFpbHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbnZhciBfZGVzY3JpcHRvcnMgPSAhX2ZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxudmFyIGRvY3VtZW50JDEgPSBfZ2xvYmFsLmRvY3VtZW50O1xudmFyIGlzID0gX2lzT2JqZWN0KGRvY3VtZW50JDEpICYmIF9pc09iamVjdChkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQpO1xudmFyIF9kb21DcmVhdGUgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cbnZhciBfaWU4RG9tRGVmaW5lID0gIV9kZXNjcmlwdG9ycyAmJiAhX2ZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2RvbUNyZWF0ZSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG5cbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xudmFyIF90b1ByaW1pdGl2ZSA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIV9pc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIV9pc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIV9pc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFfaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cbnZhciBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIGYgPSBfZGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgX2FuT2JqZWN0KE8pO1xuICBQID0gX3RvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBfYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKF9pZThEb21EZWZpbmUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgX29iamVjdERwID0ge1xuXHRmOiBmXG59O1xuXG52YXIgX3Byb3BlcnR5RGVzYyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBfaGlkZSA9IF9kZXNjcmlwdG9ycyA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBfb2JqZWN0RHAuZihvYmplY3QsIGtleSwgX3Byb3BlcnR5RGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0LldcbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IF9jb3JlIDogX2NvcmVbbmFtZV0gfHwgKF9jb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV1cbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IF9nbG9iYWwgOiBJU19TVEFUSUMgPyBfZ2xvYmFsW25hbWVdIDogKF9nbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gX2N0eChvdXQsIF9nbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBfY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYoSVNfUFJPVE8pe1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0pX2hpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxudmFyIF9leHBvcnQgPSAkZXhwb3J0O1xuXG52YXIgX3JlZGVmaW5lID0gX2hpZGU7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIF9oYXMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG52YXIgX2l0ZXJhdG9ycyA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIF9jb2YgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xuXG52YXIgX2lvYmplY3QgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIF9jb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cbi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xuXG52YXIgX3RvSW9iamVjdCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIF9pb2JqZWN0KF9kZWZpbmVkKGl0KSk7XG59O1xuXG4vLyA3LjEuMTUgVG9MZW5ndGhcbnZhciBtaW4gICAgICAgPSBNYXRoLm1pbjtcbnZhciBfdG9MZW5ndGggPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4oX3RvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxudmFyIG1heCAgICAgICA9IE1hdGgubWF4O1xudmFyIG1pbiQxICAgICAgID0gTWF0aC5taW47XG52YXIgX3RvSW5kZXggPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcbiAgaW5kZXggPSBfdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4kMShpbmRleCwgbGVuZ3RoKTtcbn07XG5cbi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG5cbnZhciBfYXJyYXlJbmNsdWRlcyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gX3RvSW9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gX3RvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSBfdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgID0gX2dsb2JhbFtTSEFSRURdIHx8IChfZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG52YXIgX3NoYXJlZCA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxudmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG52YXIgX3VpZCA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG52YXIgc2hhcmVkID0gX3NoYXJlZCgna2V5cycpO1xudmFyIF9zaGFyZWRLZXkgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gX3VpZChrZXkpKTtcbn07XG5cbnZhciBhcnJheUluZGV4T2YgPSBfYXJyYXlJbmNsdWRlcyhmYWxzZSk7XG52YXIgSUVfUFJPVE8kMSAgICAgPSBfc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xuXG52YXIgX29iamVjdEtleXNJbnRlcm5hbCA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xuICB2YXIgTyAgICAgID0gX3RvSW9iamVjdChvYmplY3QpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPJDEpX2hhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihfaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG52YXIgX2VudW1CdWdLZXlzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuXG4vLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcblxuXG52YXIgX29iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xuICByZXR1cm4gX29iamVjdEtleXNJbnRlcm5hbChPLCBfZW51bUJ1Z0tleXMpO1xufTtcblxudmFyIF9vYmplY3REcHMgPSBfZGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XG4gIF9hbk9iamVjdChPKTtcbiAgdmFyIGtleXMgICA9IF9vYmplY3RLZXlzKFByb3BlcnRpZXMpXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIFA7XG4gIHdoaWxlKGxlbmd0aCA+IGkpX29iamVjdERwLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcblxudmFyIF9odG1sID0gX2dsb2JhbC5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIElFX1BST1RPICAgID0gX3NoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFJDEgICA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBfZG9tQ3JlYXRlKCdpZnJhbWUnKVxuICAgICwgaSAgICAgID0gX2VudW1CdWdLZXlzLmxlbmd0aFxuICAgICwgbHQgICAgID0gJzwnXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgX2h0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUoaS0tKWRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRSQxXVtfZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxudmFyIF9vYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKXtcbiAgdmFyIHJlc3VsdDtcbiAgaWYoTyAhPT0gbnVsbCl7XG4gICAgRW1wdHlbUFJPVE9UWVBFJDFdID0gX2FuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eTtcbiAgICBFbXB0eVtQUk9UT1RZUEUkMV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IF9vYmplY3REcHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cbnZhciBfd2tzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xudmFyIHN0b3JlICAgICAgPSBfc2hhcmVkKCd3a3MnKVxuICAsIFN5bWJvbCAgICAgPSBfZ2xvYmFsLlN5bWJvbFxuICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogX3VpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbn0pO1xuXG52YXIgZGVmID0gX29iamVjdERwLmY7XG52YXIgVEFHID0gX3drcygndG9TdHJpbmdUYWcnKTtcblxudmFyIF9zZXRUb1N0cmluZ1RhZyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhX2hhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTtcblxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5faGlkZShJdGVyYXRvclByb3RvdHlwZSwgX3drcygnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG52YXIgX2l0ZXJDcmVhdGUgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IF9vYmplY3RDcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBfcHJvcGVydHlEZXNjKDEsIG5leHQpfSk7XG4gIF9zZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cbi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcblxudmFyIF90b09iamVjdCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChfZGVmaW5lZChpdCkpO1xufTtcblxuLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBJRV9QUk9UTyQyICAgID0gX3NoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbnZhciBfb2JqZWN0R3BvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xuICBPID0gX3RvT2JqZWN0KE8pO1xuICBpZihfaGFzKE8sIElFX1BST1RPJDIpKXJldHVybiBPW0lFX1BST1RPJDJdO1xuICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG52YXIgSVRFUkFUT1IgICAgICAgPSBfd2tzKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpO1xudmFyIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgICAgICAgICAgID0gJ2tleXMnO1xudmFyIFZBTFVFUyAgICAgICAgID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG5cbnZhciBfaXRlckRlZmluZSA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG4gIF9pdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG4gICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuICAgICwgJGVudHJpZXMgICA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWRcbiAgICAsICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlXG4gICAgLCBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKCRhbnlOYXRpdmUpe1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gX29iamVjdEdwbygkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UpKTtcbiAgICBpZihJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSl7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBfc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmKCFfbGlicmFyeSAmJiAhX2hhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKV9oaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIV9saWJyYXJ5IHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIF9oaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgX2l0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBfaXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKV9yZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSBfZXhwb3J0KF9leHBvcnQuUCArIF9leHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG52YXIgJGF0ICA9IF9zdHJpbmdBdCh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxuX2l0ZXJEZWZpbmUoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBpbmRleCA9IHRoaXMuX2lcbiAgICAsIHBvaW50O1xuICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xufSk7XG5cbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcblxudmFyIF9pdGVyQ2FsbCA9IGZ1bmN0aW9uKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpe1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oX2FuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpX2FuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcblxuLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIElURVJBVE9SJDEgICA9IF93a3MoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIF9pc0FycmF5SXRlciA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKF9pdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1IkMV0gPT09IGl0KTtcbn07XG5cbnZhciBfY3JlYXRlUHJvcGVydHkgPSBmdW5jdGlvbihvYmplY3QsIGluZGV4LCB2YWx1ZSl7XG4gIGlmKGluZGV4IGluIG9iamVjdClfb2JqZWN0RHAuZihvYmplY3QsIGluZGV4LCBfcHJvcGVydHlEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBUQUckMSA9IF93a3MoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQVJHID0gX2NvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59O1xuXG52YXIgX2NsYXNzb2YgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHJDEpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IF9jb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IF9jb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcblxudmFyIElURVJBVE9SJDIgID0gX3drcygnaXRlcmF0b3InKTtcbnZhciBjb3JlX2dldEl0ZXJhdG9yTWV0aG9kID0gX2NvcmUuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ICE9IHVuZGVmaW5lZClyZXR1cm4gaXRbSVRFUkFUT1IkMl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgX2l0ZXJhdG9yc1tfY2xhc3NvZihpdCldO1xufTtcblxudmFyIElURVJBVE9SJDMgICAgID0gX3drcygnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SJDNdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG52YXIgX2l0ZXJEZXRlY3QgPSBmdW5jdGlvbihleGVjLCBza2lwQ2xvc2luZyl7XG4gIGlmKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKXJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyICA9IFs3XVxuICAgICAgLCBpdGVyID0gYXJyW0lURVJBVE9SJDNdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHtkb25lOiBzYWZlID0gdHJ1ZX07IH07XG4gICAgYXJyW0lURVJBVE9SJDNdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcblxuX2V4cG9ydChfZXhwb3J0LlMgKyBfZXhwb3J0LkYgKiAhX2l0ZXJEZXRlY3QoZnVuY3Rpb24oaXRlcil7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XG4gICAgdmFyIE8gICAgICAgPSBfdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBDICAgICAgID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGNvcmVfZ2V0SXRlcmF0b3JNZXRob2QoTylcbiAgICAgICwgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKG1hcHBpbmcpbWFwZm4gPSBfY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgX2lzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgX2NyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBfaXRlckNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSBfdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICAgICAgX2NyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnZhciBmcm9tJDEgPSBfY29yZS5BcnJheS5mcm9tO1xuXG52YXIgZnJvbSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogZnJvbSQxLCBfX2VzTW9kdWxlOiB0cnVlIH07XG59KTtcblxudmFyIF9BcnJheSRmcm9tID0gdW53cmFwRXhwb3J0cyhmcm9tKTtcblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblxuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChmcm9tKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9mcm9tMi5kZWZhdWx0KShhcnIpO1xuICB9XG59O1xufSk7XG5cbnZhciBfdG9Db25zdW1hYmxlQXJyYXkgPSB1bndyYXBFeHBvcnRzKHRvQ29uc3VtYWJsZUFycmF5KTtcblxudmFyIF9hZGRUb1Vuc2NvcGFibGVzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTtcblxudmFyIF9pdGVyU3RlcCA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59O1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG52YXIgZXM2X2FycmF5X2l0ZXJhdG9yID0gX2l0ZXJEZWZpbmUoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IF90b0lvYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIF9pdGVyU3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBfaXRlclN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBfaXRlclN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gX2l0ZXJTdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuX2l0ZXJhdG9ycy5Bcmd1bWVudHMgPSBfaXRlcmF0b3JzLkFycmF5O1xuXG5fYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuX2FkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuX2FkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSBfd2tzKCd0b1N0cmluZ1RhZycpO1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IF9nbG9iYWxbTkFNRV1cbiAgICAsIHByb3RvICAgICAgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZihwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pX2hpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBfaXRlcmF0b3JzW05BTUVdID0gX2l0ZXJhdG9ycy5BcnJheTtcbn1cblxudmFyIGYkMSA9IF93a3M7XG5cbnZhciBfd2tzRXh0ID0ge1xuXHRmOiBmJDFcbn07XG5cbnZhciBpdGVyYXRvciQyID0gX3drc0V4dC5mKCdpdGVyYXRvcicpO1xuXG52YXIgaXRlcmF0b3IgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IGl0ZXJhdG9yJDIsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG52YXIgX21ldGEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG52YXIgTUVUQSAgICAgPSBfdWlkKCdtZXRhJylcbiAgLCBzZXREZXNjICA9IF9vYmplY3REcC5mXG4gICwgaWQgICAgICAgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFfZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFfaXNPYmplY3QoaXQpKXJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmKCFfaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighX2hhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIV9oYXMoaXQsIE1FVEEpKXNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiAgICAgIE1FVEEsXG4gIE5FRUQ6ICAgICBmYWxzZSxcbiAgZmFzdEtleTogIGZhc3RLZXksXG4gIGdldFdlYWs6ICBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG59KTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gX29iamVjdERwLmY7XG52YXIgX3drc0RlZmluZSA9IGZ1bmN0aW9uKG5hbWUpe1xuICB2YXIgJFN5bWJvbCA9IF9jb3JlLlN5bWJvbCB8fCAoX2NvcmUuU3ltYm9sID0gX2xpYnJhcnkgPyB7fSA6IF9nbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSlkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7dmFsdWU6IF93a3NFeHQuZihuYW1lKX0pO1xufTtcblxudmFyIF9rZXlvZiA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuICB2YXIgTyAgICAgID0gX3RvSW9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSBfb2JqZWN0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07XG5cbnZhciBmJDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG52YXIgX29iamVjdEdvcHMgPSB7XG5cdGY6IGYkMlxufTtcblxudmFyIGYkMyA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG52YXIgX29iamVjdFBpZSA9IHtcblx0ZjogZiQzXG59O1xuXG4vLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xuXG52YXIgX2VudW1LZXlzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgcmVzdWx0ICAgICA9IF9vYmplY3RLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9IF9vYmplY3RHb3BzLmY7XG4gIGlmKGdldFN5bWJvbHMpe1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcbiAgICAgICwgaXNFbnVtICA9IF9vYmplY3RQaWUuZlxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoc3ltYm9scy5sZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG5cbnZhciBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gX2NvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG4vLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgaGlkZGVuS2V5cyA9IF9lbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxudmFyIGYkNSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XG4gIHJldHVybiBfb2JqZWN0S2V5c0ludGVybmFsKE8sIGhpZGRlbktleXMpO1xufTtcblxudmFyIF9vYmplY3RHb3BuID0ge1xuXHRmOiBmJDVcbn07XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciBnT1BOJDEgICAgICA9IF9vYmplY3RHb3BuLmY7XG52YXIgdG9TdHJpbmckMSAgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTiQxKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxudmFyIGYkNCA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmckMS5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4kMShfdG9Jb2JqZWN0KGl0KSk7XG59O1xuXG52YXIgX29iamVjdEdvcG5FeHQgPSB7XG5cdGY6IGYkNFxufTtcblxudmFyIGdPUEQkMSAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgZiQ2ID0gX2Rlc2NyaXB0b3JzID8gZ09QRCQxIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApe1xuICBPID0gX3RvSW9iamVjdChPKTtcbiAgUCA9IF90b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYoX2llOERvbURlZmluZSl0cnkge1xuICAgIHJldHVybiBnT1BEJDEoTywgUCk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoX2hhcyhPLCBQKSlyZXR1cm4gX3Byb3BlcnR5RGVzYyghX29iamVjdFBpZS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxudmFyIF9vYmplY3RHb3BkID0ge1xuXHRmOiBmJDZcbn07XG5cbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBNRVRBICAgICAgICAgICA9IF9tZXRhLktFWTtcbnZhciBnT1BEICAgICAgICAgICA9IF9vYmplY3RHb3BkLmY7XG52YXIgZFAkMiAgICAgICAgICAgICA9IF9vYmplY3REcC5mO1xudmFyIGdPUE4gICAgICAgICAgID0gX29iamVjdEdvcG5FeHQuZjtcbnZhciAkU3ltYm9sICAgICAgICA9IF9nbG9iYWwuU3ltYm9sO1xudmFyICRKU09OICAgICAgICAgID0gX2dsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSQyICAgICAgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gICAgICAgICA9IF93a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgICA9IF93a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IF9zaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgICAgID0gX3NoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyAgICAgID0gX3NoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvJDEgICAgPSBPYmplY3RbUFJPVE9UWVBFJDJdO1xudmFyIFVTRV9OQVRJVkUgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ICAgICAgICA9IF9nbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRSQyXSB8fCAhUU9iamVjdFtQUk9UT1RZUEUkMl0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gX2Rlc2NyaXB0b3JzICYmIF9mYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gX29iamVjdENyZWF0ZShkUCQyKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBkUCQyKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8kMSwga2V5KTtcbiAgaWYocHJvdG9EZXNjKWRlbGV0ZSBPYmplY3RQcm90byQxW2tleV07XG4gIGRQJDIoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8kMSlkUCQyKE9iamVjdFByb3RvJDEsIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUCQyO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfb2JqZWN0Q3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFJDJdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byQxKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIF9hbk9iamVjdChpdCk7XG4gIGtleSA9IF90b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBfYW5PYmplY3QoRCk7XG4gIGlmKF9oYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighX2hhcyhpdCwgSElEREVOKSlkUCQyKGl0LCBISURERU4sIF9wcm9wZXJ0eURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKF9oYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9vYmplY3RDcmVhdGUoRCwge2VudW1lcmFibGU6IF9wcm9wZXJ0eURlc2MoMCwgZmFsc2UpfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAkMihpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgX2FuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBfZW51bUtleXMoUCA9IF90b0lvYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX29iamVjdENyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfb2JqZWN0Q3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gX3RvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZih0aGlzID09PSBPYmplY3RQcm90byQxICYmIF9oYXMoQWxsU3ltYm9scywga2V5KSAmJiAhX2hhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhX2hhcyh0aGlzLCBrZXkpIHx8ICFfaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgX2hhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IF90b0lvYmplY3QoaXQpO1xuICBrZXkgPSBfdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvJDEgJiYgX2hhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFfaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBfaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShfaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnT1BOKF90b0lvYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIV9oYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgSVNfT1AgID0gaXQgPT09IE9iamVjdFByb3RvJDFcbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiBfdG9Jb2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKF9oYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gX2hhcyhPYmplY3RQcm90byQxLCBrZXkpIDogdHJ1ZSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZighVVNFX05BVElWRSl7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKXtcbiAgICBpZih0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gX3VpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90byQxKSRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmKF9oYXModGhpcywgSElEREVOKSAmJiBfaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIF9wcm9wZXJ0eURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmKF9kZXNjcmlwdG9ycyAmJiBzZXR0ZXIpc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90byQxLCB0YWcsIHtjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIF9yZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRSQyXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgX29iamVjdEdvcGQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gIF9vYmplY3REcC5mICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gIF9vYmplY3RHb3BuLmYgPSBfb2JqZWN0R29wbkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIF9vYmplY3RQaWUuZiAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIF9vYmplY3RHb3BzLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmKF9kZXNjcmlwdG9ycyAmJiAhX2xpYnJhcnkpe1xuICAgIF9yZWRlZmluZShPYmplY3RQcm90byQxLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgX3drc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAoX3drcyhuYW1lKSk7XG4gIH07XG59XG5cbl9leHBvcnQoX2V4cG9ydC5HICsgX2V4cG9ydC5XICsgX2V4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtTeW1ib2w6ICRTeW1ib2x9KTtcblxuZm9yKHZhciBzeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGkkMSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaSQxOyApX3drcyhzeW1ib2xzW2kkMSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IF9vYmplY3RLZXlzKF93a3Muc3RvcmUpLCBpJDEgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGkkMTsgKV93a3NEZWZpbmUoc3ltYm9sc1tpJDErK10pO1xuXG5fZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIF9oYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBfa2V5b2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG5fZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiBfZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqICghVVNFX05BVElWRSB8fCBfZmFpbHMoZnVuY3Rpb24oKXtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIHZhciBhcmdzID0gW2l0XVxuICAgICAgLCBpICAgID0gMVxuICAgICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIGlmKCRyZXBsYWNlciB8fCAhX2lzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgICBpZigkcmVwbGFjZXIpdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmKCFpc1N5bWJvbCh2YWx1ZSkpcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFJDJdW1RPX1BSSU1JVElWRV0gfHwgX2hpZGUoJFN5bWJvbFtQUk9UT1RZUEUkMl0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEUkMl0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5fc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuX3NldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuX3NldFRvU3RyaW5nVGFnKF9nbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxuX3drc0RlZmluZSgnYXN5bmNJdGVyYXRvcicpO1xuXG5fd2tzRGVmaW5lKCdvYnNlcnZhYmxlJyk7XG5cbnZhciBpbmRleCA9IF9jb3JlLlN5bWJvbDtcblxudmFyIHN5bWJvbCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogaW5kZXgsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG52YXIgX3R5cGVvZl8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblxuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoaXRlcmF0b3IpO1xuXG5cblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChzeW1ib2wpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIF9pdGVyYXRvcjIuZGVmYXVsdCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufTtcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHVud3JhcEV4cG9ydHMoX3R5cGVvZl8xKTtcblxuLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG5cbnZhciBfb2JqZWN0U2FwID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcbiAgdmFyIGZuICA9IChfY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICBfZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqIF9mYWlscyhmdW5jdGlvbigpeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcblxuLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG5cblxuX29iamVjdFNhcCgna2V5cycsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KXtcbiAgICByZXR1cm4gX29iamVjdEtleXMoX3RvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxudmFyIGtleXMkMSA9IF9jb3JlLk9iamVjdC5rZXlzO1xuXG52YXIga2V5cyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjoga2V5cyQxLCBfX2VzTW9kdWxlOiB0cnVlIH07XG59KTtcblxudmFyIF9PYmplY3Qka2V5cyA9IHVud3JhcEV4cG9ydHMoa2V5cyk7XG5cbi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyIGZsb29yJDEgICAgPSBNYXRoLmZsb29yO1xudmFyIF9pc0ludGVnZXIgPSBmdW5jdGlvbiBpc0ludGVnZXIoaXQpe1xuICByZXR1cm4gIV9pc09iamVjdChpdCkgJiYgaXNGaW5pdGUoaXQpICYmIGZsb29yJDEoaXQpID09PSBpdDtcbn07XG5cbi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxuXG5cbl9leHBvcnQoX2V4cG9ydC5TLCAnTnVtYmVyJywge2lzSW50ZWdlcjogX2lzSW50ZWdlcn0pO1xuXG52YXIgaXNJbnRlZ2VyJDIgPSBfY29yZS5OdW1iZXIuaXNJbnRlZ2VyO1xuXG52YXIgaXNJbnRlZ2VyJDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IGlzSW50ZWdlciQyLCBfX2VzTW9kdWxlOiB0cnVlIH07XG59KTtcblxudmFyIF9OdW1iZXIkaXNJbnRlZ2VyID0gdW53cmFwRXhwb3J0cyhpc0ludGVnZXIkMSk7XG5cbnZhciBfc3RyaW5nV3MgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnO1xuXG52YXIgc3BhY2UgICA9ICdbJyArIF9zdHJpbmdXcyArICddJztcbnZhciBub24gICAgID0gJ1xcdTIwMGJcXHUwMDg1JztcbnZhciBsdHJpbSAgID0gUmVnRXhwKCdeJyArIHNwYWNlICsgc3BhY2UgKyAnKicpO1xudmFyIHJ0cmltICAgPSBSZWdFeHAoc3BhY2UgKyBzcGFjZSArICcqJCcpO1xuXG52YXIgZXhwb3J0ZXIgPSBmdW5jdGlvbihLRVksIGV4ZWMsIEFMSUFTKXtcbiAgdmFyIGV4cCAgID0ge307XG4gIHZhciBGT1JDRSA9IF9mYWlscyhmdW5jdGlvbigpe1xuICAgIHJldHVybiAhIV9zdHJpbmdXc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IF9zdHJpbmdXc1tLRVldO1xuICBpZihBTElBUylleHBbQUxJQVNdID0gZm47XG4gIF9leHBvcnQoX2V4cG9ydC5QICsgX2V4cG9ydC5GICogRk9SQ0UsICdTdHJpbmcnLCBleHApO1xufTtcblxuLy8gMSAtPiBTdHJpbmcjdHJpbUxlZnRcbi8vIDIgLT4gU3RyaW5nI3RyaW1SaWdodFxuLy8gMyAtPiBTdHJpbmcjdHJpbVxudmFyIHRyaW0gPSBleHBvcnRlci50cmltID0gZnVuY3Rpb24oc3RyaW5nLCBUWVBFKXtcbiAgc3RyaW5nID0gU3RyaW5nKF9kZWZpbmVkKHN0cmluZykpO1xuICBpZihUWVBFICYgMSlzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICBpZihUWVBFICYgMilzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICByZXR1cm4gc3RyaW5nO1xufTtcblxudmFyIF9zdHJpbmdUcmltID0gZXhwb3J0ZXI7XG5cbnZhciAkcGFyc2VGbG9hdCA9IF9nbG9iYWwucGFyc2VGbG9hdDtcbnZhciAkdHJpbSAgICAgICA9IF9zdHJpbmdUcmltLnRyaW07XG5cbnZhciBfcGFyc2VGbG9hdCQzID0gMSAvICRwYXJzZUZsb2F0KF9zdHJpbmdXcyArICctMCcpICE9PSAtSW5maW5pdHkgPyBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cil7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMylcbiAgICAsIHJlc3VsdCA9ICRwYXJzZUZsb2F0KHN0cmluZyk7XG4gIHJldHVybiByZXN1bHQgPT09IDAgJiYgc3RyaW5nLmNoYXJBdCgwKSA9PSAnLScgPyAtMCA6IHJlc3VsdDtcbn0gOiAkcGFyc2VGbG9hdDtcblxuLy8gMjAuMS4yLjEyIE51bWJlci5wYXJzZUZsb2F0KHN0cmluZylcbl9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogKE51bWJlci5wYXJzZUZsb2F0ICE9IF9wYXJzZUZsb2F0JDMpLCAnTnVtYmVyJywge3BhcnNlRmxvYXQ6IF9wYXJzZUZsb2F0JDN9KTtcblxudmFyIF9wYXJzZUZsb2F0JDEgPSBwYXJzZUZsb2F0O1xuXG52YXIgX3BhcnNlRmxvYXQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9wYXJzZUZsb2F0JDEsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG52YXIgX051bWJlciRwYXJzZUZsb2F0ID0gdW53cmFwRXhwb3J0cyhfcGFyc2VGbG9hdCk7XG5cbi8qKlxuICogdG94aWMtcHJlZGljYXRlLWZ1bmN0aW9ucyB2MC4xLjJcbiAqIChjKSAyMDE3IHRveGljLWpvaGFublxuICogUmVsZWFzZWQgdW5kZXIgTUlUXG4gKi9cblxuLyoqXG4gKiBpcyB2b2lkIGVsZW1lbnQgb3Igbm90ID8gTWVhbnMgaXQgd2lsbCByZXR1cm4gdHJ1ZSB3aGVuIHZhbCBpcyB1bmRlZmluZWQgb3IgbnVsbFxuICogQHBhcmFtICB7QW55dGhpbmd9ICBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgcmV0dXJuIHRydWUgd2hlbiB2YWwgaXMgdW5kZWZpbmVkIG9yIG51bGxcbiAqL1xuZnVuY3Rpb24gaXNWb2lkKG9iaikge1xuICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsO1xufVxuLyoqXG4gKiB0byBjaGVjayB3aGV0aGVyIGEgdmFyaWFibGUgaXMgYXJyYXlcbiAqIEBwYXJhbSB7QW55dGhpbmd9IGFyclxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSB3aGVuIGl0IGlzIGEgYm9vbGVhblxuICovXG5mdW5jdGlvbiBpc0FycmF5KGFycikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpO1xufVxuXG4vKipcbiAqIOWIpOaWreaYr+WQpuS4umZ1bmN0aW9uXG4gKiBAcGFyYW0gIHtBbnl0aGluZ30gIG9iaiBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiDliKTmlq3mmK/lkKbmmK/lr7nosaFcbiAqIEBwYXJhbSAge0FueXRoaW5nfSAgb2JqIOS8oOWFpeWvueixoVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QkMShvYmopIHtcbiAgLy8gaW5jYXNlIG9mIGFycm93IGZ1bmN0aW9uIGFuZCBhcnJheVxuICByZXR1cm4gT2JqZWN0KG9iaikgPT09IG9iaiAmJiBTdHJpbmcob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgIWlzRnVuY3Rpb24ob2JqKSAmJiAhaXNBcnJheShvYmopO1xufVxuLyoqXG4gKiB0byB0ZWxsIHlvdSBpZiBpdCdzIGEgcmVhbCBudW1iZXJcbiAqIEBwYXJhbSAge0FueXRoaW5nfSAgb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgIHJldHVybiB0cnVlIHdoZW4gaXQncyBhIG51bWJlclxuICovXG5mdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdudW1iZXInO1xufVxuLyoqXG4gKiB0byB0ZWxsIHlvdSBpZiB0aGUgdmFsIGNhbiBiZSB0cmFuc2ZlciBpbnRvIGRhdGFcbiAqIEBwYXJhbSAge0FueXRoaW5nfSAgb2JqIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGlzTnVtZXJpYyhvYmopIHtcbiAgcmV0dXJuICFpc0FycmF5KG9iaikgJiYgb2JqIC0gX051bWJlciRwYXJzZUZsb2F0KG9iaikgKyAxID49IDA7XG59XG4vKipcbiAqIOWIpOaWreaYr+WQpuS4uuaVtOaVsFxuICogQHBhcmFtICB7QW55dGhpbmd9ICBvYmogW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gaXNJbnRlZ2VyKG51bSkge1xuICByZXR1cm4gX051bWJlciRpc0ludGVnZXIobnVtKTtcbn1cblxuLyoqXG4gKiDliKTmlq3mmK/lkKbkuLrnqbpcbiAqIEBwYXJhbSAge0FueXRoaW5nfSAgb2JqIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBbZGVzY3JpcHRpb25dXG4gKiBAZXhhbXBsZVxuICogXCJcIiwge30sIFtdLCAwLCBudWxsLCB1bmRlZmluZWQsIGZhbHNlIOS4uuepulxuICovXG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QkMShvYmopKSB7XG4gICAgcmV0dXJuIF9PYmplY3Qka2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gIW9iajtcbiAgfVxufVxuLyoqXG4gKiDliKTmlq3mmK/lkKbkuLrkuovku7ZcbiAqIEBwYXJhbSAge0FueXRoaW5nfSAgb2JqIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnQob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBFdmVudCB8fCBvYmoub3JpZ2luYWxFdmVudCBpbnN0YW5jZW9mIEV2ZW50O1xufVxuLyoqXG4gKiDliKTmlq3mmK/lkKbkuLpibG9iXG4gKiBAcGFyYW0gIHtBbnl0aGluZ30gIG9iaiBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBpc0Jsb2Iob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBCbG9iO1xufVxuLyoqXG4gKiDliKTmlq3mmK/lkKbkuLpmaWxl5LiK5Lyg55qE5paH5Lu2XG4gKiBAcGFyYW0gIHtBbnl0aGluZ30gIG9iaiBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBpc0ZpbGUob2JqKSB7XG4gIHJldHVybiBpc0Jsb2Iob2JqKSAmJiBpc1N0cmluZyhvYmoubmFtZSk7XG59XG4vKipcbiAqIOWIpOaWreaYr+WQpuS4uuaXpeacn+WvueixoVxuICogQHBhcmFtICB7QW55dGhpbmd9ICBvYmogW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gaXNEYXRlKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbi8qKlxuICog5Yik5pat5piv5ZCm5pivc3RyaW5nXG4gKiBAcGFyYW0gIHtBbnl0aGluZ30gIHN0ciBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZztcbn1cbi8qKlxuICogaXMgQm9vbGVhbiBvciBub3RcbiAqIEBwYXJhbSAge0FueXRoaW5nfSBib29sXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYm9vbCkge1xuICByZXR1cm4gdHlwZW9mIGJvb2wgPT09ICdib29sZWFuJztcbn1cbi8qKlxuICogaXMgYSBwcm9taXNlIG9yIG5vdFxuICogQHBhcmFtIHtBbnl0aGluZ30gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gIHJldHVybiAhIW9iaiAmJiAoKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iaikpID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIGlzIFByaW1pdGl2ZSB0eXBlIG9yIG5vdCwgd2hpY2sgbWVhbnMgaXQgd2lsbCByZXR1cm4gdHJ1ZSB3aGVuIGRhdGEgaXMgbnVtYmVyL3N0cmluZy9ib29sZWFuL3VuZGVmaW5lZC9udWxsXG4gKiBAcGFyYW0gIHtBbnl0aW5nfSAgdmFsXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgdHJ1ZSB3aGVuIHR5cGUgaXMgbnVtYmVyL3N0cmluZy9ib29sZWFuL3VuZGVmaW5lZC9udWxsXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbCkge1xuICByZXR1cm4gaXNWb2lkKHZhbCkgfHwgaXNCb29sZWFuKHZhbCkgfHwgaXNTdHJpbmcodmFsKSB8fCBpc051bWJlcih2YWwpO1xufVxuLyoqXG4gKiDliKTmlq3mmK/lkKbkuLp1cmzkuJTlv4XpobvopoHluKbmnInljY/orq7lpLRcbiAqIEBwYXJhbSAge0FueXRoaW5nfSAgc3RyIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGlzVXJsKHN0cikge1xuICByZXR1cm4gaXNTdHJpbmcoc3RyKSAmJiAhIXN0ci5tYXRjaCgvXigoaHR0cHM/fGZ0cHxydHNwfG1tcyk6XFwvXFwvKSgoWzAtOWEtel8hfionKCkuJj0rJCUtXSs6ICk/WzAtOWEtel8hfionKCkuJj0rJCUtXStAKT8oKFswLTldezEsM31cXC4pezN9WzAtOV17MSwzfXwoWzAtOWEtel8hfionKCktXStcXC4pKihbMC05YS16XVswLTlhLXotXXswLDYxfSk/WzAtOWEtel1cXC5bYS16XXsyLDZ9fGxvY2FsaG9zdCkoOlswLTldezEsNH0pPygoXFwvPyl8KFxcL1swLTlhLXpfIX4qJygpLjs/OkAmPSskLCUjLV0rKStcXC8/KSQvaSk7XG59XG4vKipcbiAqIHRvIHRlc3QgaWYgYSBIVE1MIG5vZGVcbiAqIEBwYXJhbSAge0FueXRoaW5nfSAgb2JqIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZShvYmopIHtcbiAgcmV0dXJuICEhKCh0eXBlb2YgTm9kZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoTm9kZSkpID09PSAnb2JqZWN0JyA/IG9iaiBpbnN0YW5jZW9mIE5vZGUgOiBvYmogJiYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iaikpID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqLm5vZGVOYW1lID09PSAnc3RyaW5nJyk7XG59XG4vKipcbiAqIHRvIHRlc3QgaWYgYSBIVE1MIGVsZW1lbnRcbiAqIEBwYXJhbSAge0FueXRoaW5nfSAgb2JqIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmopIHtcbiAgcmV0dXJuICEhKCh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKEhUTUxFbGVtZW50KSkgPT09ICdvYmplY3QnID8gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgOiBvYmogJiYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iaikpID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwgJiYgb2JqLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvYmoubm9kZU5hbWUgPT09ICdzdHJpbmcnKTtcbn1cbi8qKlxuICogY2hlY2sgaWYgbm9kZSBBIGlzIG5vZGUgQidzIHBhcmVudCBvciBub3RcbiAqIEBwYXJhbSAge05vZGV9ICBwYXJlbnRcbiAqIEBwYXJhbSAge05vZGV9ICBjaGlsZFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDaGlsZE5vZGUocGFyZW50LCBjaGlsZCkge1xuICBpZiAoIWlzTm9kZShwYXJlbnQpIHx8ICFpc05vZGUoY2hpbGQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBjaGlsZC5wYXJlbnROb2RlID09PSBwYXJlbnQ7XG59XG4vKipcbiAqIGNoZWNrIGlmIG5vZGUgQiBpcyBub2RlIEEncyBwb3N0ZXJyaXR5IG9yIG5vdFxuICogQHBhcmFtICB7Tm9kZX0gIHBhcmVudFxuICogQHBhcmFtICB7Tm9kZX0gIGNoaWxkXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc1Bvc3Rlcml0eU5vZGUocGFyZW50LCBjaGlsZCkge1xuICBpZiAoIWlzTm9kZShwYXJlbnQpIHx8ICFpc05vZGUoY2hpbGQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHdoaWxlIChjaGlsZC5wYXJlbnROb2RlKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlO1xuICAgIGlmIChjaGlsZCA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBjaGVjayBpZiB0aGUgc3RyaW5nIGlzIGFuIEhUTUxTdHJpbmdcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0ciBvbmx5IGFjY2VwdCBzdHJpbmdcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzSFRNTFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuICgvPFtePl0rPz4vLnRlc3Qoc3RyKVxuICApO1xufVxuLyoqXG4gKiBjaGVjayBpZiBpcyBhbiBlcnJvclxuICogQHBhcmFtIHthbnl0aGluZ30gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Vycm9yKHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRXJyb3I7XG59XG5cbi8qKlxuICogdG94aWMtdXRpbHMgdjAuMS4zXG4gKiAoYykgMjAxNyB0b3hpYy1qb2hhbm5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVFxuICovXG5cbi8qKlxuICog55Sf5oiQ5rex5bqm6YGN5Y6G5Ye95pWw55qE5aSE55CG5Zmo77yM5bi455So5LqO55Sf5oiQ5rex5bqm5ou36LSd562JXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4g6YGN5Y6G5Yiw5rex5bqm5Y+Y6YeP55qE5pe25YCZ55qE5pON5L2cXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gICAgIOWPr+eUqOeahOaTjeS9nOWHveaVsFxuICovXG5mdW5jdGlvbiBnZW5UcmF2ZXJzYWxIYW5kbGVyKGZuKSB7XG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZUZuKHNvdXJjZSwgdGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoaXNBcnJheShzb3VyY2UpIHx8IGlzT2JqZWN0JDEoc291cmNlKSkge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IChpc09iamVjdCQxKHNvdXJjZSkgPyB7fSA6IFtdKTtcbiAgICAgIGZvciAodmFyIF9rZXkgaW4gc291cmNlKSB7XG4gICAgICAgIHRhcmdldFtfa2V5XSA9IHJlY3Vyc2l2ZUZuKHNvdXJjZVtfa2V5XSwgdGFyZ2V0W19rZXldLCBfa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIHJldHVybiBmbihzb3VyY2UsIHRhcmdldCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVjdXJzaXZlRm47XG59XG52YXIgX2RlZXBBc3NpZ24gPSBnZW5UcmF2ZXJzYWxIYW5kbGVyKGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbDtcbn0pO1xuLyoqXG4gKiDlr7nosaHlhYvpmoZcbiAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gc291cmNlIOS8oOWFtuS7luWAvOS8muebtOaOpei/lOWbnlxuICogQHJldHVybiB7Y2xvbmUtdGFyZ2V0fSAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBkZWVwQ2xvbmUoc291cmNlKSB7XG4gIGlmIChpc1ByaW1pdGl2ZShzb3VyY2UpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGVlcENsb25lIG9ubHkgYWNjZXB0IG5vbiBwcmltaXRpdmUgdHlwZScpO1xuICB9XG4gIHJldHVybiBfZGVlcEFzc2lnbihzb3VyY2UpO1xufVxuLyoqXG4gKiBtZXJnZSBtdWx0aXBsZSBvYmplY3RzXG4gKiBAcGFyYW0gIHsuLi5PYmplY3R9IGFyZ3MgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7bWVyZ2Utb2JqZWN0fSAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gZGVlcEFzc2lnbigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW47IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWVwQXNzaWduIGFjY2VwdCB0d28gYW5kIG1vcmUgYXJndW1lbnQnKTtcbiAgfVxuICBmb3IgKHZhciBpID0gYXJncy5sZW5ndGggLSAxOyBpID4gLTE7IGktLSkge1xuICAgIGlmIChpc1ByaW1pdGl2ZShhcmdzW2ldKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGVlcEFzc2lnbiBvbmx5IGFjY2VwdCBub24gcHJpbWl0aXZlIHR5cGUnKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRhcmdldCA9IGFyZ3Muc2hpZnQoKTtcbiAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICByZXR1cm4gX2RlZXBBc3NpZ24oc291cmNlLCB0YXJnZXQpO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBjYW1lbGl6ZSBhbnkgc3RyaW5nLCBlLmcgaGVsbG8gd29ybGQgLT4gaGVsbG9Xb3JsZFxuICogQHBhcmFtICB7c3RyaW5nfSBzdHIgb25seSBhY2NlcHQgc3RyaW5nIVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgY2FtZWxpemUgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0ciwgaXNCaWcpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oXnxbXmEtekEtWl0rKShbYS16QS1aXSkvZywgZnVuY3Rpb24gKG1hdGNoLCBzcGlsdCwgaW5pdGlhbHMsIGluZGV4KSB7XG4gICAgcmV0dXJuICFpc0JpZyAmJiBpbmRleCA9PT0gMCA/IGluaXRpYWxzLnRvTG93ZXJDYXNlKCkgOiBpbml0aWFscy50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cbi8qKlxuICogaHlwZW5hdGUgYW55IHN0cmluZyBlLmcgaGVsbG8gd29ybGQgLT4gaGVsbG8td29ybGRcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyIG9ubHkgYWNjZXB0IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBlbmF0ZShzdHIpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cikucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gJy0nICsgbWF0Y2gudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogYmluZCB0aGUgZnVuY3Rpb24gd2l0aCBzb21lIGNvbnRleHQuIHdlIGhhdmUgc29tZSBmYWxsYmFjayBzdHJhdGVneSBoZXJlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiB0aGUgZnVuY3Rpb24gd2hpY2ggd2UgbmVlZCB0byBiaW5kIHRoZSBjb250ZXh0IG9uXG4gKiBAcGFyYW0ge2FueX0gY29udGV4dCB0aGUgY29udGV4dCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYmluZChmbiwgY29udGV4dCkge1xuICBpZiAoZm4uYmluZCkge1xuICAgIHJldHVybiBmbi5iaW5kKGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKGZuLmFwcGx5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9fYXV0b2JpbmRfXygpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4yOyBfa2V5MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9fYXV0b2JpbmRfXygpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4zKSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW4zOyBfa2V5NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZuLmNhbGwuYXBwbHkoZm4sIFtjb250ZXh0XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKSk7XG4gICAgfTtcbiAgfVxufVxuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqICDorqHnrpfnsbsgICAgKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyDorqHnrpfojrflj5bmn5Dnp43kuJzopb/miJbogIXorqHnrpflh7rmn5Dnp43kuJzopb9cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyDnlJ/miJB1dWlkXG5mdW5jdGlvbiB1dWlkKCkge1xuICByZXR1cm4gUzQoKSArIFM0KCkgKyAnLScgKyBTNCgpICsgJy0nICsgUzQoKSArICctJyArIFM0KCkgKyAnLScgKyBTNCgpICsgUzQoKSArIFM0KCk7XG59XG4vLyDnlJ/miJDlm5vkuKrpmo/mnLrmlbBcbmZ1bmN0aW9uIFM0KCkge1xuICByZXR1cm4gKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwIHwgMCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtcbn1cbi8vIOeUn+aIkOS7u+aEj+mVv+W6pueahOmaj+acuuaVsFxuZnVuY3Rpb24gcmFuZChsZW5ndGgpIHtcbiAgdmFyIHN0ciA9ICcnO1xuICB3aGlsZSAoc3RyLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgIHN0ciArPSBTNCgpO1xuICB9XG4gIHJldHVybiBzdHIuc2xpY2UoMCwgbGVuZ3RoKTtcbn1cblxuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbl9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogIV9kZXNjcmlwdG9ycywgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogX29iamVjdERwLmZ9KTtcblxudmFyICRPYmplY3QgPSBfY29yZS5PYmplY3Q7XG52YXIgZGVmaW5lUHJvcGVydHkkMiA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBkZWZpbmVQcm9wZXJ0eSQyLCBfX2VzTW9kdWxlOiB0cnVlIH07XG59KTtcblxudmFyIF9PYmplY3QkZGVmaW5lUHJvcGVydHkgPSB1bndyYXBFeHBvcnRzKGRlZmluZVByb3BlcnR5JDEpO1xuXG52YXIgX2FuSW5zdGFuY2UgPSBmdW5jdGlvbihpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKXtcbiAgaWYoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpe1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxudmFyIF9mb3JPZiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbnZhciBCUkVBSyAgICAgICA9IHt9XG4gICwgUkVUVVJOICAgICAgPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKXtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogY29yZV9nZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSlcbiAgICAsIGYgICAgICA9IF9jdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSlcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYoX2lzQXJyYXlJdGVyKGl0ZXJGbikpZm9yKGxlbmd0aCA9IF90b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoX2FuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgKXtcbiAgICByZXN1bHQgPSBfaXRlckNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcbn0pO1xuXG4vLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBTUEVDSUVTICAgPSBfd2tzKCdzcGVjaWVzJyk7XG52YXIgX3NwZWNpZXNDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKE8sIEQpe1xuICB2YXIgQyA9IF9hbk9iamVjdChPKS5jb25zdHJ1Y3RvciwgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IF9hbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IF9hRnVuY3Rpb24oUyk7XG59O1xuXG4vLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbnZhciBfaW52b2tlID0gZnVuY3Rpb24oZm4sIGFyZ3MsIHRoYXQpe1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG5cbnZhciBwcm9jZXNzJDEgICAgICAgICAgICA9IF9nbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrICAgICAgICAgICAgPSBfZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhclRhc2sgICAgICAgICAgPSBfZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIE1lc3NhZ2VDaGFubmVsICAgICA9IF9nbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgY291bnRlciAgICAgICAgICAgID0gMDtcbnZhciBxdWV1ZSAgICAgICAgICAgICAgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlcjtcbnZhciBjaGFubmVsO1xudmFyIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYoIXNldFRhc2sgfHwgIWNsZWFyVGFzayl7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pe1xuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XG4gICAgICBfaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYoX2NvZihwcm9jZXNzJDEpID09ICdwcm9jZXNzJyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBwcm9jZXNzJDEubmV4dFRpY2soX2N0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYoTWVzc2FnZUNoYW5uZWwpe1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XG4gICAgcG9ydCAgICA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IF9jdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYoX2dsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFfZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgX2dsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgX2dsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIF9kb21DcmVhdGUoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIF9odG1sLmFwcGVuZENoaWxkKF9kb21DcmVhdGUoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgX2h0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoX2N0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxudmFyIF90YXNrID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcblxudmFyIG1hY3JvdGFzayA9IF90YXNrLnNldDtcbnZhciBPYnNlcnZlciAgPSBfZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgX2dsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MkMiAgID0gX2dsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgICA9IF9nbG9iYWwuUHJvbWlzZTtcbnZhciBpc05vZGUkMiAgICA9IF9jb2YocHJvY2VzcyQyKSA9PSAncHJvY2Vzcyc7XG5cbnZhciBfbWljcm90YXNrID0gZnVuY3Rpb24oKXtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmKGlzTm9kZSQyICYmIChwYXJlbnQgPSBwcm9jZXNzJDIuZG9tYWluKSlwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlKGhlYWQpe1xuICAgICAgZm4gICA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIGlmKGhlYWQpbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYocGFyZW50KXBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYoaXNOb2RlJDIpe1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9jZXNzJDIubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlclxuICB9IGVsc2UgaWYoT2JzZXJ2ZXIpe1xuICAgIHZhciB0b2dnbGUgPSB0cnVlXG4gICAgICAsIG5vZGUgICA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpe1xuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChfZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmbil7XG4gICAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWR9O1xuICAgIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZighaGVhZCl7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuXG52YXIgX3JlZGVmaW5lQWxsID0gZnVuY3Rpb24odGFyZ2V0LCBzcmMsIHNhZmUpe1xuICBmb3IodmFyIGtleSBpbiBzcmMpe1xuICAgIGlmKHNhZmUgJiYgdGFyZ2V0W2tleV0pdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcbiAgICBlbHNlIF9oaWRlKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH0gcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBTUEVDSUVTJDEgICAgID0gX3drcygnc3BlY2llcycpO1xuXG52YXIgX3NldFNwZWNpZXMgPSBmdW5jdGlvbihLRVkpe1xuICB2YXIgQyA9IHR5cGVvZiBfY29yZVtLRVldID09ICdmdW5jdGlvbicgPyBfY29yZVtLRVldIDogX2dsb2JhbFtLRVldO1xuICBpZihfZGVzY3JpcHRvcnMgJiYgQyAmJiAhQ1tTUEVDSUVTJDFdKV9vYmplY3REcC5mKEMsIFNQRUNJRVMkMSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcblxudmFyIHRhc2sgICAgICAgICAgICAgICA9IF90YXNrLnNldDtcbnZhciBtaWNyb3Rhc2sgICAgICAgICAgPSBfbWljcm90YXNrKCk7XG52YXIgUFJPTUlTRSAgICAgICAgICAgID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciQxICAgICAgICAgID0gX2dsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyAgICAgICAgICAgID0gX2dsb2JhbC5wcm9jZXNzO1xudmFyICRQcm9taXNlICAgICAgICAgICA9IF9nbG9iYWxbUFJPTUlTRV07XG52YXIgcHJvY2VzcyAgICAgICAgICAgID0gX2dsb2JhbC5wcm9jZXNzO1xudmFyIGlzTm9kZSQxICAgICAgICAgICAgID0gX2NsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xudmFyIGVtcHR5ICAgICAgICAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07XG52YXIgSW50ZXJuYWw7XG52YXIgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5O1xudmFyIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFJDEgPSAhIWZ1bmN0aW9uKCl7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgICAgID0gJFByb21pc2UucmVzb2x2ZSgxKVxuICAgICAgLCBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW193a3MoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbihleGVjKXsgZXhlYyhlbXB0eSwgZW1wdHkpOyB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSQxIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gX2lzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICByZXR1cm4gc2FtZUNvbnN0cnVjdG9yKCRQcm9taXNlLCBDKVxuICAgID8gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgOiBuZXcgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbigkJHJlc29sdmUsICQkcmVqZWN0KXtcbiAgICBpZihyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yJDEoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBfYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCAgPSBfYUZ1bmN0aW9uKHJlamVjdCk7XG59O1xudmFyIHBlcmZvcm0gPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICBleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHtlcnJvcjogZX07XG4gIH1cbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24ocHJvbWlzZSwgaXNSZWplY3Qpe1xuICBpZihwcm9taXNlLl9uKXJldHVybjtcbiAgcHJvbWlzZS5fbiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XG4gIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3ZcbiAgICAgICwgb2sgICAgPSBwcm9taXNlLl9zID09IDFcbiAgICAgICwgaSAgICAgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbihyZWFjdGlvbil7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsXG4gICAgICAgICwgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmVcbiAgICAgICAgLCByZWplY3QgID0gcmVhY3Rpb24ucmVqZWN0XG4gICAgICAgICwgZG9tYWluICA9IHJlYWN0aW9uLmRvbWFpblxuICAgICAgICAsIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmKGhhbmRsZXIpe1xuICAgICAgICAgIGlmKCFvayl7XG4gICAgICAgICAgICBpZihwcm9taXNlLl9oID09IDIpb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoaGFuZGxlciA9PT0gdHJ1ZSlyZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYoZG9tYWluKWRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSl7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yJDEoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpe1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoX2dsb2JhbCwgZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIGFicnVwdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZihpc1VuaGFuZGxlZChwcm9taXNlKSl7XG4gICAgICBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKGlzTm9kZSQxKXtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBfZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKXtcbiAgICAgICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlfSk7XG4gICAgICAgIH0gZWxzZSBpZigoY29uc29sZSA9IF9nbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlJDEgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYoYWJydXB0KXRocm93IGFicnVwdC5lcnJvcjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIGlmKHByb21pc2UuX2ggPT0gMSlyZXR1cm4gZmFsc2U7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2EgfHwgcHJvbWlzZS5fY1xuICAgICwgaSAgICAgPSAwXG4gICAgLCByZWFjdGlvbjtcbiAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSl7XG4gICAgcmVhY3Rpb24gPSBjaGFpbltpKytdO1xuICAgIGlmKHJlYWN0aW9uLmZhaWwgfHwgIWlzVW5oYW5kbGVkKHJlYWN0aW9uLnByb21pc2UpKXJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgdGFzay5jYWxsKF9nbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlJDEpe1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBfZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IkMShcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSl7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7X3c6IHByb21pc2UsIF9kOiBmYWxzZX07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIF9jdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBfY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgICRyZWplY3QuY2FsbCh7X3c6IHByb21pc2UsIF9kOiBmYWxzZX0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZighVVNFX05BVElWRSQxKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBfYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgX2FGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoX2N0eCgkcmVzb2x2ZSwgdGhpcywgMSksIF9jdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSBfcmVkZWZpbmVBbGwoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKXtcbiAgICAgIHZhciByZWFjdGlvbiAgICA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KF9zcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlJDEgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZih0aGlzLl9hKXRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZih0aGlzLl9zKW5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3RlZCl7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbigpe1xuICAgIHZhciBwcm9taXNlICA9IG5ldyBJbnRlcm5hbDtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IF9jdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IF9jdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG59XG5cbl9leHBvcnQoX2V4cG9ydC5HICsgX2V4cG9ydC5XICsgX2V4cG9ydC5GICogIVVTRV9OQVRJVkUkMSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5fc2V0VG9TdHJpbmdUYWcoJFByb21pc2UsIFBST01JU0UpO1xuX3NldFNwZWNpZXMoUFJPTUlTRSk7XG5XcmFwcGVyID0gX2NvcmVbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3Ncbl9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogIVVTRV9OQVRJVkUkMSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKXtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVqZWN0ICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbl9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogKF9saWJyYXJ5IHx8ICFVU0VfTkFUSVZFJDEpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpe1xuICAgIC8vIGluc3RhbmNlb2YgaW5zdGVhZCBvZiBpbnRlcm5hbCBzbG90IGNoZWNrIGJlY2F1c2Ugd2Ugc2hvdWxkIGZpeCBpdCB3aXRob3V0IHJlcGxhY2VtZW50IG5hdGl2ZSBQcm9taXNlIGNvcmVcbiAgICBpZih4IGluc3RhbmNlb2YgJFByb21pc2UgJiYgc2FtZUNvbnN0cnVjdG9yKHguY29uc3RydWN0b3IsIHRoaXMpKXJldHVybiB4O1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZXNvbHZlICA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICAkJHJlc29sdmUoeCk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5fZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqICEoVVNFX05BVElWRSQxICYmIF9pdGVyRGV0ZWN0KGZ1bmN0aW9uKGl0ZXIpe1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSB0aGlzXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZXNvbHZlICAgID0gY2FwYWJpbGl0eS5yZXNvbHZlXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgdmFyIHZhbHVlcyAgICA9IFtdXG4gICAgICAgICwgaW5kZXggICAgID0gMFxuICAgICAgICAsIHJlbWFpbmluZyA9IDE7XG4gICAgICBfZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgdmFyICRpbmRleCAgICAgICAgPSBpbmRleCsrXG4gICAgICAgICAgLCBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgaWYoYWxyZWFkeUNhbGxlZClyZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCAgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSB0aGlzXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZWplY3QgICAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgIF9mb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciBwcm9taXNlJDEgPSBfY29yZS5Qcm9taXNlO1xuXG52YXIgcHJvbWlzZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcHJvbWlzZSQxLCBfX2VzTW9kdWxlOiB0cnVlIH07XG59KTtcblxudmFyIF9Qcm9taXNlID0gdW53cmFwRXhwb3J0cyhwcm9taXNlKTtcblxuLyoqXG4gKiBjaGltZWUtaGVscGVyLXV0aWxzIHYwLjEuMlxuICogKGMpIDIwMTcgdG94aWMtam9oYW5uXG4gKiBSZWxlYXNlZCB1bmRlciBNSVRcbiAqL1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqICBqdWRnZW1lbnQgICAqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2hlY2sgaWYgdGhlIGNvZGUgcnVubmluZyBpbiBicm93c2VyIGVudmlyb25tZW50IChub3QgaW5jbHVkZSB3b3JrZXIgZW52KVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93KSAhPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKiogIOWvueixoeaTjeS9nCAgKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIOi9rOWPmOS4gOS4quexu+aVsOe7hOWvueixoeS4uuaVsOe7hFxuICovXG5mdW5jdGlvbiBtYWtlQXJyYXkob2JqKSB7XG4gIHJldHVybiBfQXJyYXkkZnJvbShvYmopO1xufVxuXG4vKipcbiAqIHNvcnQgT2JqZWN0IGF0dHJpYnV0ZXMgYnkgZnVuY3Rpb25cbiAqIGFuZCB0cmFuc2ZlciB0aGVtIGludG8gYXJyYXlcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqIE9iamVjdCBmb3JtIGZyb20gbnVtcmljXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gc29ydCBmdW5jdGlvblxuICogQHJldHVybiB7QXJyYXl9IHRoZSBzb3J0ZWQgYXR0aXJidXRlcyBhcnJheVxuICovXG5mdW5jdGlvbiB0cmFuc09iamVjdEF0dHJJbnRvQXJyYXkob2JqKSB7XG4gIHZhciBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gK2EgLSArYjtcbiAgfTtcblxuICByZXR1cm4gX09iamVjdCRrZXlzKG9iaikuc29ydChmbikucmVkdWNlKGZ1bmN0aW9uIChvcmRlciwga2V5KSB7XG4gICAgcmV0dXJuIG9yZGVyLmNvbmNhdChvYmpba2V5XSk7XG4gIH0sIFtdKTtcbn1cbi8vICoqKioqKioqKioqKioqKioqKioqKiogY2xhc3Mgb3BlcmF0aW9uICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8gY2xhc3MgTWl4aW5CdWlsZGVyIHtcbi8vICAgY29uc3RydWN0b3IgKHN1cGVyY2xhc3MpIHtcbi8vICAgICB0aGlzLnN1cGVyY2xhc3MgPSBzdXBlcmNsYXNzIHx8IGNsYXNzIHt9O1xuLy8gICB9XG5cbi8vICAgd2l0aCAoLi4ubWl4aW5zKSB7XG4vLyAgICAgcmV0dXJuIG1peGlucy5yZWR1Y2UoKGMsIG1peGluKSA9PiBtaXhpbihjKSwgdGhpcy5zdXBlcmNsYXNzKTtcbi8vICAgfVxuLy8gfVxuLy8gZXhwb3J0IGNvbnN0IG1peCA9IChzdXBlcmNsYXNzKSA9PiB7XG4vLyAgIHJldHVybiBuZXcgTWl4aW5CdWlsZGVyKHN1cGVyY2xhc3MpO1xuLy8gfTtcbi8qKlxuICogcnVuIGEgcXVldWUgb25lIGJ5IG9uZS5JZiBpbmNsdWRlIGZ1bmN0aW9uIHJlamVjdCBvciByZXR1cm4gZmFsc2UgaXQgd2lsbCBzdG9wXG4gKiBAcGFyYW0gIHtBcnJheX0gcXVldWUgdGhlIHF1ZXVlIHdoaWNoIHdlIHdhbnQgdG8gcnVuIG9uZSBieSBvbmVcbiAqIEByZXR1cm4ge1Byb21pc2V9ICAgIHRlbGwgdXMgd2hldGhlciBhIHF1ZXVlIHJ1biBmaW5pc2hlZFxuICovXG5mdW5jdGlvbiBydW5SZWplY3RhYmxlUXVldWUocXVldWUpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uIHN0ZXAoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA+PSBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbihxdWV1ZVtpbmRleF0pID8gcXVldWVbaW5kZXhdLmFwcGx5KHF1ZXVlLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJncykpIDogcXVldWVbaW5kZXhdO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHJldHVybiByZWplY3QoJ3N0b3AnKTtcbiAgICAgIHJldHVybiBfUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzdGVwKGluZGV4ICsgMSk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoJ3N0b3AnKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgc3RlcCgwKTtcbiAgfSk7XG59XG4vKipcbiAqIHJ1biBhIHF1ZXVlIG9uZSBieSBvbmUuSWYgaW5jbHVkZSBmdW5jdGlvbiByZXR1cm4gZmFsc2UgaXQgd2lsbCBzdG9wXG4gKiBAcGFyYW0gIHtBcnJheX0gcXVldWUgdGhlIHF1ZXVlIHdoaWNoIHdlIHdhbnQgdG8gcnVuIG9uZSBieSBvbmVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRlbGwgdGhlIHVzZXIgaWYgdGhlIHF1ZXVlIHJ1biBmaW5pc2hlZFxuICovXG5mdW5jdGlvbiBydW5TdG9wcGFibGVRdWV1ZShxdWV1ZSkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIHZhciBzdGVwID0gZnVuY3Rpb24gc3RlcChpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbihxdWV1ZVtpbmRleF0pID8gcXVldWVbaW5kZXhdLmFwcGx5KHF1ZXVlLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJncykpIDogcXVldWVbaW5kZXhdO1xuICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHN0ZXAoKytpbmRleCk7XG4gIH07XG4gIHJldHVybiBzdGVwKDApO1xufVxuLyoqXG4gKiBzZXQgYW4gYXR0cmlidXRlIHRvIGFuIG9iamVjdCB3aGljaCBpcyBmcm96ZW4uXG4gKiBNZWFucyB5b3UgY2FuJ3QgcmVtb3ZlIGl0LCBpdGVyYXRlIGl0IG9yIHJld3JpdGUgaXQuXG4gKiBAcGFyYW0geyFwcmltaXRpdmV9IG9ialxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtBbnl0aGluZ30gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2V0RnJvemVuQXR0cihvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzUHJpbWl0aXZlKG9iaikpIHRocm93IFR5cGVFcnJvcignc2V0RnJvemVuQXR0ciBvYmogcGFyYW1ldGVyIGNhbiBub3QgYmUgcHJpbWl0aXZlIHR5cGUnKTtcbiAgaWYgKCFpc1N0cmluZyhrZXkpKSB0aHJvdyBUeXBlRXJyb3IoJ3NldEZyb3plbkF0dHIga2V5IHBhcmFtZXRlciBtdXN0IGJlIFN0cmluZycpO1xuICBfT2JqZWN0JGRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xufVxuLyoqXG4gKiBzZXQgYXR0ciBvbiBhbiBPYmplY3QuIFdlIHdpbGwgYmluZCBnZXR0ZXIgYW5kIHNldHRlciBvbiBpdCBpZiB5b3UgcHJvdmlkZSB0byB1c1xuICogQHBhcmFtIHshcHJpbWl0aXZlfSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuZ2V0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldFxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCB0aGUgb3JpZ2luIGRhdGEncyBwcmVmaXguIFdlIGRvIG5vdCBwbGFuIHRvIHNhdmUgaXQgYnkgY2xvc3VyZS5cbiAqL1xuZnVuY3Rpb24gc2V0QXR0ckdldHRlckFuZFNldHRlcihvYmosIGtleSkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICBnZXQgPSBfcmVmLmdldCxcbiAgICAgIHNldCA9IF9yZWYuc2V0O1xuXG4gIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6ICdfXyc7XG5cbiAgaWYgKGlzUHJpbWl0aXZlKG9iaikpIHRocm93IFR5cGVFcnJvcignc2V0RnJvemVuQXR0ciBvYmogcGFyYW1ldGVyIGNhbiBub3QgYmUgcHJpbWl0aXZlIHR5cGUnKTtcbiAgaWYgKCFpc1N0cmluZyhrZXkpKSB0aHJvdyBUeXBlRXJyb3IoJ3NldEF0dHJHZXR0ZXJBbmRTZXR0ZXIga2V5IHBhcmFtZXRlciBtdXN0IGJlIFN0cmluZycpO1xuICB2YXIgb3JpZ2luYWxEYXRhID0gb2JqW2tleV07XG4gIGlmICghaXNGdW5jdGlvbihnZXQpKSB7XG4gICAgX09iamVjdCRkZWZpbmVQcm9wZXJ0eShvYmosIHByZWZpeCArIGtleSwge1xuICAgICAgdmFsdWU6IG9yaWdpbmFsRGF0YSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgICBnZXQgPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1twcmVmaXggKyBrZXldO1xuICAgIH07XG4gICAgaWYgKHNldCAmJiBpc0Z1bmN0aW9uKHNldCkpIHtcbiAgICAgIHZhciBvcmlnaW5TZXR0ZXIgPSBzZXQ7XG4gICAgICBzZXQgPSBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1twcmVmaXggKyBrZXldID0gb3JpZ2luU2V0dGVyLmNhbGwuYXBwbHkob3JpZ2luU2V0dGVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIF9PYmplY3QkZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgZ2V0OiBnZXQsIHNldDogc2V0IH0pO1xufVxuXG5mdW5jdGlvbiBjaGVja0NvbnRpbnVhdGlvbih1aW50OGFycmF5LCBzdGFydCwgY2hlY2tMZW5ndGgpIHtcbiAgdmFyIGFycmF5ID0gdWludDhhcnJheTtcbiAgaWYgKHN0YXJ0ICsgY2hlY2tMZW5ndGggPCBhcnJheS5sZW5ndGgpIHtcbiAgICB3aGlsZSAoY2hlY2tMZW5ndGgtLSkge1xuICAgICAgaWYgKChhcnJheVsrK3N0YXJ0XSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIGRlY29kZVVURjhcbmZ1bmN0aW9uIGRlY29kZVVURjgodWludDhhcnJheSkge1xuICB2YXIgb3V0ID0gW107XG4gIHZhciBpbnB1dCA9IHVpbnQ4YXJyYXk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbmd0aCA9IHVpbnQ4YXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaWYgKGlucHV0W2ldIDwgMHg4MCkge1xuICAgICAgb3V0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpbnB1dFtpXSkpO1xuICAgICAgKytpO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChpbnB1dFtpXSA8IDB4QzApIHtcbiAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgfSBlbHNlIGlmIChpbnB1dFtpXSA8IDB4RTApIHtcbiAgICAgIGlmIChjaGVja0NvbnRpbnVhdGlvbihpbnB1dCwgaSwgMSkpIHtcbiAgICAgICAgdmFyIHVjczQgPSAoaW5wdXRbaV0gJiAweDFGKSA8PCA2IHwgaW5wdXRbaSArIDFdICYgMHgzRjtcbiAgICAgICAgaWYgKHVjczQgPj0gMHg4MCkge1xuICAgICAgICAgIG91dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUodWNzNCAmIDB4RkZGRikpO1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5wdXRbaV0gPCAweEYwKSB7XG4gICAgICBpZiAoY2hlY2tDb250aW51YXRpb24oaW5wdXQsIGksIDIpKSB7XG4gICAgICAgIHZhciBfdWNzID0gKGlucHV0W2ldICYgMHhGKSA8PCAxMiB8IChpbnB1dFtpICsgMV0gJiAweDNGKSA8PCA2IHwgaW5wdXRbaSArIDJdICYgMHgzRjtcbiAgICAgICAgaWYgKF91Y3MgPj0gMHg4MDAgJiYgKF91Y3MgJiAweEY4MDApICE9PSAweEQ4MDApIHtcbiAgICAgICAgICBvdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKF91Y3MgJiAweEZGRkYpKTtcbiAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlucHV0W2ldIDwgMHhGOCkge1xuICAgICAgaWYgKGNoZWNrQ29udGludWF0aW9uKGlucHV0LCBpLCAzKSkge1xuICAgICAgICB2YXIgX3VjczIgPSAoaW5wdXRbaV0gJiAweDcpIDw8IDE4IHwgKGlucHV0W2kgKyAxXSAmIDB4M0YpIDw8IDEyIHwgKGlucHV0W2kgKyAyXSAmIDB4M0YpIDw8IDYgfCBpbnB1dFtpICsgM10gJiAweDNGO1xuICAgICAgICBpZiAoX3VjczIgPiAweDEwMDAwICYmIF91Y3MyIDwgMHgxMTAwMDApIHtcbiAgICAgICAgICBfdWNzMiAtPSAweDEwMDAwO1xuICAgICAgICAgIG91dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoX3VjczIgPj4+IDEwIHwgMHhEODAwKSk7XG4gICAgICAgICAgb3V0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShfdWNzMiAmIDB4M0ZGIHwgMHhEQzAwKSk7XG4gICAgICAgICAgaSArPSA0O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG91dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSk7XG4gICAgKytpO1xuICB9XG4gIHJldHVybiBvdXQuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAvLyBpbW1lZGlhdGXpu5jorqTkuLpmYWxzZVxuICB2YXIgdGltZW91dCA9IHZvaWQgMCxcbiAgICAgIGFyZ3MgPSB2b2lkIDAsXG4gICAgICBjb250ZXh0ID0gdm9pZCAwLFxuICAgICAgdGltZXN0YW1wID0gdm9pZCAwLFxuICAgICAgcmVzdWx0ID0gdm9pZCAwO1xuXG4gIHZhciBsYXRlciA9IGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgIC8vIOW9k3dhaXTmjIflrprnmoTml7bpl7Tpl7TpmpTmnJ/pl7TlpJrmrKHosIPnlKhfLmRlYm91bmNl6L+U5Zue55qE5Ye95pWw77yM5YiZ5Lya5LiN5pat5pu05pawdGltZXN0YW1w55qE5YC877yM5a+86Ie0bGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAw5LiA55u05Li6dHJ1Ze+8jOS7juiAjOS4jeaWreWQr+WKqOaWsOeahOiuoeaXtuWZqOW7tuaXtuaJp+ihjGZ1bmNcbiAgICB2YXIgbGFzdCA9IG5ldyBEYXRlKCkgLSB0aW1lc3RhbXA7XG5cbiAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAvLyDnrKzkuIDmrKHosIPnlKjor6Xmlrnms5Xml7bvvIzkuJRpbW1lZGlhdGXkuLp0cnVl77yM5YiZ6LCD55SoZnVuY+WHveaVsFxuICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgIC8vIOWcqHdhaXTmjIflrprnmoTml7bpl7Tpl7TpmpTlhoXpppbmrKHosIPnlKjor6Xmlrnms5XvvIzliJnlkK/liqjorqHml7blmajlrprml7bosIPnlKhmdW5j5Ye95pWwXG4gICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiDlh73mlbDoioLmtYHvvIjmjqfliLblh73mlbDmiafooYzpopHnjofvvIlcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmdW5jIOimgeiKgua1geaOp+WItueahOWHveaVsO+8jOW/heWhq1xuICogQHJldHVybiB7TnVtYmVyfSAgIHdhaXQg562J5b6F5pe26ZW/XG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgb3B0aW9ucyB7XG4gKiAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nPOaYr+WQpummluasoeiwg+eUqOeri+WNs+aJp+ihjO+8jOWQpu+8muWImeaMiXdhaXTorr7lrprnrYnlvoXliLDmnJ/lkI7osIPnlKjmiY3miafooYw+OmZhbHNlLFxuICogICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmc85piv5ZCm5Zyo6LCD55So5bm25pyq5Yiw5pyf5pe25ZCv55So5a6a5pe25Zmo77yM5Lul5L+d6K+B5LiA5a6a5omn6KGMPjp0cnVlXG4gKiAgICAgICAgICAgICAgICAgICAgfVxuICogQHJldHVybiB7T2JqZWN0fSAgIGN4dCDkuIrkuIvmloflr7nosaFcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zLCBjeHQpIHtcbiAgLyogb3B0aW9uc+eahOm7mOiupOWAvFxuICAgKiAg6KGo56S66aaW5qyh6LCD55So6L+U5Zue5YC85pa55rOV5pe277yM5Lya6ams5LiK6LCD55SoZnVuY++8m+WQpuWImeS7heS8muiusOW9leW9k+WJjeaXtuWIu++8jOW9k+esrOS6jOasoeiwg+eUqOeahOaXtumXtOmXtOmalOi2hei/h3dhaXTml7bvvIzmiY3osIPnlKhmdW5j44CCXG4gICAqICBvcHRpb25zLmxlYWRpbmcgPSB0cnVlO1xuICAgKiDooajnpLrlvZPosIPnlKjmlrnms5Xml7bvvIzmnKrliLDovr53YWl05oyH5a6a55qE5pe26Ze06Ze06ZqU77yM5YiZ5ZCv5Yqo6K6h5pe25Zmo5bu26L+f6LCD55SoZnVuY+WHveaVsO+8jOiLpeWQjue7reWcqOaXouacqui+vuWIsHdhaXTmjIflrprnmoTml7bpl7Tpl7TpmpTlkoxmdW5j5Ye95pWw5Y+I5pyq6KKr6LCD55So55qE5oOF5Ya15LiL6LCD55So6L+U5Zue5YC85pa55rOV77yM5YiZ6KKr6LCD55So6K+35rGC5bCG6KKr5Lii5byD44CCXG4gICAqICBvcHRpb25zLnRyYWlsaW5nID0gdHJ1ZTtcbiAgICog5rOo5oSP77ya5b2Tb3B0aW9ucy50cmFpbGluZyA9IGZhbHNl5pe277yM5pWI5p6c5LiO5LiK6Z2i55qE566A5Y2V5a6e546w5pWI5p6c55u45ZCMXG4gICAqL1xuICB2YXIgY29udGV4dCA9IHZvaWQgMCxcbiAgICAgIGFyZ3MgPSB2b2lkIDAsXG4gICAgICByZXN1bHQgPSB2b2lkIDA7XG4gIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgdmFyIHByZXZpb3VzID0gMDtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBsYXRlciA9IGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBuZXcgRGF0ZSgpIC0gMDtcbiAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICB9O1xuICB3YWl0ID0gd2FpdCB8fCAwO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgLy8g6K6h566X5Ymp5L2Z5pe26Ze0XG4gICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgIGlmIChjeHQpIHtcbiAgICAgIGNvbnRleHQgPSBjeHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIH1cblxuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgLy8g5b2T5Yiw6L6+d2FpdOaMh+WumueahOaXtumXtOmXtOmalO+8jOWImeiwg+eUqGZ1bmPlh73mlbBcbiAgICAvLyDnsr7lvankuYvlpITvvJrmjInnkIbmnaXor7RyZW1haW5pbmcgPD0gMOW3sue7j+i2s+Wkn+ivgeaYjuW3sue7j+WIsOi+vndhaXTnmoTml7bpl7Tpl7TpmpTvvIzkvYbov5nph4zov5jogIPomZHliLDlgYflpoLlrqLmiLfnq6/kv67mlLnkuobns7vnu5/ml7bpl7TliJnpqazkuIrmiafooYxmdW5j5Ye95pWw44CCXG4gICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgIC8vIOeUseS6jnNldFRpbWVvdXTlrZjlnKjmnIDlsI/ml7bpl7Tnsr7luqbpl67popjvvIzlm6DmraTkvJrlrZjlnKjliLDovr53YWl055qE5pe26Ze06Ze06ZqU77yM5L2G5LmL5YmN6K6+572u55qEc2V0VGltZW91dOaTjeS9nOi/mOayoeiiq+aJp+ihjO+8jOWboOatpOS4uuS/nemZqei1t+inge+8jOi/memHjOWFiOa4heeQhnNldFRpbWVvdXTmk43kvZxcbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICB9XG4gICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAvLyBvcHRpb25zLnRyYWlsaW5nPXRydWXml7bvvIzlu7bml7bmiafooYxmdW5j5Ye95pWwXG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG52YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uIChjYikge1xuICByZXR1cm4gc2V0VGltZW91dChjYiwgMTcpO1xufTtcblxuLy8gY2FuY2VsQW5pbWF0aW9uRnJhbWVcbnZhciBjYWYgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGlkKSB7XG4gIGNsZWFyVGltZW91dChpZCk7XG59O1xuXG4vLyDmoLnmja7opoHmsYLnmoTkvY3mlbDvvIzlsIY55qC85byP5YyW5Li6IDA5XFwwMDlcXDAwMDkuLi5cbmZ1bmN0aW9uIHN0clJlcGVhdChudW0sIGJpdCkge1xuICB2YXIgcEJpdCA9IGJpdDtcbiAgbnVtID0gJycgKyAobnVtIHx8ICcnKTtcbiAgdmFyIG51bUxlbiA9IG51bS5sZW5ndGg7XG4gIGJpdCA9IChiaXQgfHwgbnVtTGVuKSAtIG51bUxlbjtcbiAgdmFyIHBhZGRpbmdTdHIgPSBiaXQgPiAwID8gbnVtLnJlcGVhdCA/ICcwJy5yZXBlYXQoYml0KSA6IG5ldyBBcnJheShiaXQgKyAxKS5qb2luKCcwJykgOiAnJztcbiAgcmV0dXJuIChwYWRkaW5nU3RyICsgbnVtKS5zbGljZSgwLCBwQml0KTtcbn1cblxuLy8gdmlkZW8g5pe26Ze05qC85byP5YyWXG5mdW5jdGlvbiBmb3JtYXRUaW1lKHRpbWUpIHtcbiAgdmFyIGhoID0gTWF0aC5mbG9vcih0aW1lIC8gMzYwMCk7XG4gIHRpbWUgPSBNYXRoLmZsb29yKHRpbWUgJSAzNjAwKTtcbiAgdmFyIG1tID0gc3RyUmVwZWF0KE1hdGguZmxvb3IodGltZSAvIDYwKSwgMik7XG4gIHRpbWUgPSBNYXRoLmZsb29yKHRpbWUgJSA2MCk7XG4gIHZhciBzcyA9IHN0clJlcGVhdCh0aW1lLCAyKTtcbiAgcmV0dXJuIGhoID49IDEgPyBoaCArICc6JyArIG1tICsgJzonICsgc3MgOiBtbSArICc6JyArIHNzO1xufVxuXG4vKipcbiAqIOe7mW9iauWvueixoeaJqeWxleS4inRyYW5z5pa55rOV77yM55So5Lul5a6e546wbWV0aG9kTmFtZeWvueW6lOeahOWxnuaAp+aWueazleWMheijheS4uumdmeaAgeWHveaVsOS4lOS/neaMgeS4iuS4i+aWh+eahOWKn+iDvVxuICogQHBhcmFtICB7T2JqZWN0fSBvYmog55uu5qCH5a+56LGhXG4gKi9cbmZ1bmN0aW9uIGFkZFRyYW5zTWV0aG9kKG9iaikge1xuICBzZXRGcm96ZW5BdHRyKG9iaiwgJ3RyYW5zJywgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICBpZiAoIW9iai5fX2Zucykge1xuICAgICAgc2V0RnJvemVuQXR0cihvYmosICdfX2ZucycsIHt9KTtcbiAgICB9XG4gICAgaWYgKCFvYmouX19mbnNbbWV0aG9kTmFtZV0pIHtcbiAgICAgIG9iai5fX2Zuc1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKG9ialttZXRob2ROYW1lXSkpIHRocm93IFR5cGVFcnJvcignb2JqLnRyYW5zKG1ldGhvZE5hbWUpIHBhcmFtZXRlciBtdXN0IGJlIEZ1bmN0aW9uJyk7XG4gICAgICAgIHJldHVybiBvYmpbbWV0aG9kTmFtZV0uYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5fX2Zuc1ttZXRob2ROYW1lXTtcbiAgfSk7XG59XG5cbi8qKlxuICog6L+95Yqg5qC35byP5Luj56CB5YiwaGVhZOeahHN0eWxl5qCH562+77yM5LiN5a2Y5Zyo5YiZ5Yib5bu6XG4gKiBAcGFyYW0ge1N0cmluZ30gY3NzVGV4dCDmoLflvI/mlofmnKxcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5mdW5jdGlvbiBhcHBlbmRDU1MoY3NzVGV4dCkge1xuICB2YXIgZG9jID0gZG9jdW1lbnQ7XG4gIHZhciBzdHlsZUVsID0gZG9jLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJyk7XG4gIGlmICghc3R5bGVFbCkge1xuICAgIHN0eWxlRWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICB2YXIgaGVhZGVyID0gZG9jLnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKTtcbiAgICBoZWFkZXIgJiYgaGVhZGVyLmFwcGVuZENoaWxkKHN0eWxlRWwpO1xuICB9XG4gIHN0eWxlRWwuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKGNzc1RleHQpKTtcbiAgcmV0dXJuIHN0eWxlRWw7XG59XG5cbi8qKlxuICog5qC85byP5YyW5pel5pyf5a+56LGh5Li677ya5bm0LeaciC3ml6Ug5pe2OuWIhjrnp5Iu5q+r56eSXG4gKiBAcGFyYW0ge0RhdGV9IGRhdGUgRGF0ZeaXpeacn+WvueixoVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4g6KaB6L6T5Ye655qE5pel5pyf5qC85byP77yM6buY6K6k77yaYHl5eXktTU0tZGQgaGg6bW06c3MuaWBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZm9ybWF0RGF0ZSgpIHtcbiAgdmFyIGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG5ldyBEYXRlKCk7XG4gIHZhciBwYXR0ZXJuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAneXl5eS1NTS1kZCBoaDptbTpzcy5pJztcblxuICB2YXIgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpO1xuICB2YXIgZmllbGRzID0ge1xuICAgIE06IGRhdGUuZ2V0TW9udGgoKSArIDEsXG4gICAgZDogZGF0ZS5nZXREYXRlKCksXG4gICAgaDogZGF0ZS5nZXRIb3VycygpLFxuICAgIG06IGRhdGUuZ2V0TWludXRlcygpLFxuICAgIHM6IGRhdGUuZ2V0U2Vjb25kcygpLFxuICAgIGk6IGRhdGUuZ2V0TWlsbGlzZWNvbmRzKClcbiAgfTtcbiAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvKHkrKS9pZywgZnVuY3Rpb24gKF8sIHllYXJQYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHllYXIuc3Vic3RyKDQgLSBNYXRoLm1pbig0LCB5ZWFyUGF0dGVybi5sZW5ndGgpKTtcbiAgfSk7XG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UobmV3IFJlZ0V4cCgnKCcgKyBpICsgJyspJywgJ2cnKSwgZnVuY3Rpb24gKF8sIHBhdHRTdHIpIHtcbiAgICAgIHJldHVybiAoZmllbGRzW2ldIDwgMTAgJiYgcGF0dFN0ci5sZW5ndGggPiAxID8gJzAnIDogJycpICsgZmllbGRzW2ldO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgaW4gZmllbGRzKSB7XG4gICAgX2xvb3AoaSk7XG4gIH1cbiAgcmV0dXJuIHBhdHRlcm47XG59XG5cbi8qKlxuICog6K+75Y+W5pys5Zyw5a2Y5YKo55qE5YC877yI5LiN5pSv5oyBbG9jYWxTdG9yYWdl5YiZ6ZmN57qn5YiwY29va2ll77yJXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IOebruagh+aVsOaNrmtleVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2Uoa2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciByZWdSdCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnwgKScgKyBrZXkgKyAnPShbXjtdKikoO3wkKScpKTtcbiAgICAgIHJldHVybiBpc0FycmF5KHJlZ1J0KSA/IHVuZXNjYXBlKHJlZ1J0WzJdKSA6ICcnO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn1cbi8qKlxuICog5bCG5oyH5a6aa2V55a+55bqU5YC85YaZ5YWl5pys5Zyw5a2Y5YKo77yI5LiN5pSv5oyBbG9jYWxTdG9yYWdl5YiZ6ZmN57qn5YiwY29va2ll77yJXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNldExvY2FsU3RvcmFnZShrZXksIHZhbCkge1xuICB0cnkge1xuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgZXhwaXJlcyA9IG5ldyBEYXRlKCk7XG4gICAgLy8g6buY6K6k5a2Y5YKoMzAw5aSpXG4gICAgZXhwaXJlcy5zZXRUaW1lKGV4cGlyZXMuZ2V0VGltZSgpICsgMjQgKiAzNjAwICogMTAwMCAqIDMwMCk7XG4gICAgdHJ5IHtcbiAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGtleSArICc9JyArIGVzY2FwZSh2YWwpICsgJztleHBpcmVzPScgKyBleHBpcmVzLnRvVVRDU3RyaW5nKCkgKyAnO3BhdGg9LzsnO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2sgPSB1bndyYXBFeHBvcnRzKGNsYXNzQ2FsbENoZWNrKTtcblxudmFyIGNyZWF0ZUNsYXNzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblxuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZGVmaW5lUHJvcGVydHkkMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSB1bndyYXBFeHBvcnRzKGNyZWF0ZUNsYXNzKTtcblxuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG52YXIgX29iamVjdEFzc2lnbiA9ICEkYXNzaWduIHx8IF9mYWlscyhmdW5jdGlvbigpe1xuICB2YXIgQSA9IHt9XG4gICAgLCBCID0ge31cbiAgICAsIFMgPSBTeW1ib2woKVxuICAgICwgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUICAgICA9IF90b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IF9vYmplY3RHb3BzLmZcbiAgICAsIGlzRW51bSAgICAgPSBfb2JqZWN0UGllLmY7XG4gIHdoaWxlKGFMZW4gPiBpbmRleCl7XG4gICAgdmFyIFMgICAgICA9IF9pb2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IF9vYmplY3RLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IF9vYmplY3RLZXlzKFMpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGogICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGopaWYoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSlUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxuLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcblxuXG5fZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IF9vYmplY3RBc3NpZ259KTtcblxudmFyIGFzc2lnbiQxID0gX2NvcmUuT2JqZWN0LmFzc2lnbjtcblxudmFyIGFzc2lnbiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogYXNzaWduJDEsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG52YXIgX09iamVjdCRhc3NpZ24gPSB1bndyYXBFeHBvcnRzKGFzc2lnbik7XG5cbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuX2V4cG9ydChfZXhwb3J0LlMsICdPYmplY3QnLCB7Y3JlYXRlOiBfb2JqZWN0Q3JlYXRlfSk7XG5cbnZhciAkT2JqZWN0JDEgPSBfY29yZS5PYmplY3Q7XG52YXIgY3JlYXRlJDEgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCl7XG4gIHJldHVybiAkT2JqZWN0JDEuY3JlYXRlKFAsIEQpO1xufTtcblxudmFyIGNyZWF0ZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogY3JlYXRlJDEsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG52YXIgX09iamVjdCRjcmVhdGUgPSB1bndyYXBFeHBvcnRzKGNyZWF0ZSk7XG5cbi8qKlxuICogY2hpbWVlLWhlbHBlci1ldmVudHMgdjAuMS4wXG4gKiAoYykgMjAxNyB0b3hpYy1qb2hhbm5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVFxuICovXG5cbi8qKlxuKiBAbW9kdWxlIGV2ZW50XG4qIEBhdXRob3IgaHV6dW5qaWVcbiogQGRlc2NyaXB0aW9uIOiHquWumuS5ieS6i+S7tuWfuuehgOexu1xuKi9cblxuLyog57yT5a2Y5LqL5Lu255uR5ZCs5pa55rOV5Y+K5YyF6KOF77yM5YaF6YOo5pWw5o2u5qC85byP77yaXG4gKiB0YXJnZXRJbmRleF88dHlwZTonY2xpY2t8bW91c2V1cHxkb25lJz46IFsgW1xuICogICBmdW5jdGlvbigpeyAuLi4gaGFuZGxlciAuLi4gfSxcbiAqICAgZnVuY3Rpb24oKXsgLi4uIGhhbmRsZXJXcmFwIC4uLiBoYW5kbGVyLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKSAuLi4gfSxcbiAqICAgaXNPbmNlXG4gKiBdXVxuICovXG52YXIgX2V2dExpc3RlbmVyQ2FjaGUgPSBfT2JqZWN0JGNyZWF0ZShudWxsKTtcbl9ldnRMaXN0ZW5lckNhY2hlLmNvdW50ID0gMDtcblxuLyoqXG4gKiDlvpfliLDmn5Dlr7nosaHnmoTmn5Dkuovku7bnsbvlnovlr7nlupTnmoTnm5HlkKzpmJ/liJfmlbDnu4RcbiAqIEBwYXJhbSAge09iamVjdH0gIHRhcmdldCDlj5HnlJ/kuovku7bnmoTlr7nosaFcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuexu+Weiyjov5nph4znmoTml7bpl7TnsbvlnovkuI3lj6rmmK/lkI3np7DvvIzov5jmmK/nvJPlrZjmoIfor4bvvIzlj6/ku6XpgJrov4fmt7vliqDlkI7nvIDmnaXljLrliIYpXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gZ2V0RXZ0VHlwZUNhY2hlKHRhcmdldCwgdHlwZSkge1xuXG4gIHZhciBldnRJZCA9IHRhcmdldC5fX2V2dF9pZDtcbiAgaWYgKCFldnRJZCkge1xuXG4gICAgLyog6K6+572uX19ldnRfaWTkuI3lj6/mnprkuL4gKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCAnX19ldnRfaWQnLCB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvKiDnqbrlr7nosaHliJ3lp4vljJbnu5HlrprntKLlvJUgKi9cbiAgICBldnRJZCA9IHRhcmdldC5fX2V2dF9pZCA9ICsrX2V2dExpc3RlbmVyQ2FjaGUuY291bnQ7XG4gIH1cblxuICB2YXIgdHlwZUNhY2hlS2V5ID0gZXZ0SWQgKyAnXycgKyB0eXBlO1xuICB2YXIgZXZ0VHlwZUNhY2hlID0gX2V2dExpc3RlbmVyQ2FjaGVbdHlwZUNhY2hlS2V5XTtcbiAgaWYgKCFldnRUeXBlQ2FjaGUpIHtcbiAgICBldnRUeXBlQ2FjaGUgPSBfZXZ0TGlzdGVuZXJDYWNoZVt0eXBlQ2FjaGVLZXldID0gW107XG4gIH1cblxuICByZXR1cm4gZXZ0VHlwZUNhY2hlO1xufVxuXG4vKipcbiAqIOinpuWPkeS6i+S7tuebkeWQrOaWueazlVxuICogQHBhcmFtICB7T2JqZWN0fSAgdGFyZ2V0IOWPkeeUn+S6i+S7tueahOWvueixoVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRPYmog6Kem5Y+R5LqL5Lu25pe26KaB5Lyg5Zue55qEZXZlbnTlr7nosaFcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZW1pdEV2ZW50Q2FjaGUodGFyZ2V0LCB0eXBlLCBldmVudE9iaikge1xuICB2YXIgZXZ0ID0gX09iamVjdCRjcmVhdGUobnVsbCk7XG4gIGV2dC50eXBlID0gdHlwZTtcbiAgZXZ0LnRhcmdldCA9IHRhcmdldDtcbiAgaWYgKGV2ZW50T2JqKSB7XG4gICAgX09iamVjdCRhc3NpZ24oZXZ0LCBpc09iamVjdCQxKGV2ZW50T2JqKSA/IGV2ZW50T2JqIDogeyBkYXRhOiBldmVudE9iaiB9KTtcbiAgfVxuICBnZXRFdnRUeXBlQ2FjaGUodGFyZ2V0LCB0eXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgKGl0ZW1bMV0gfHwgaXRlbVswXSkuYXBwbHkodGFyZ2V0LCBbZXZ0XSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIOa3u+WKoOS6i+S7tuebkeWQrOWIsOe8k+WtmFxuICogQHBhcmFtICB7T2JqZWN0fSAgdGFyZ2V0IOWPkeeUn+S6i+S7tueahOWvueixoVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOebkeWQrOWHveaVsFxuICogQHBhcmFtIHtCb29sZWFufSBpc09uY2Ug5piv5ZCm5Y2V5qyh5omn6KGMXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyV3JhcFxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBhZGRFdmVudENhY2hlKHRhcmdldCwgdHlwZSwgaGFuZGxlcikge1xuICB2YXIgaXNPbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgdmFyIGhhbmRsZXJXcmFwID0gYXJndW1lbnRzWzRdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGlzT25jZSkgJiYgIWhhbmRsZXJXcmFwKSB7XG4gICAgaGFuZGxlcldyYXAgPSBpc09uY2U7XG4gICAgaXNPbmNlID0gdW5kZWZpbmVkO1xuICB9XG4gIHZhciBoYW5kbGVycyA9IFtoYW5kbGVyLCB1bmRlZmluZWQsIGlzT25jZV07XG4gIGlmIChpc09uY2UgJiYgIWhhbmRsZXJXcmFwKSB7XG4gICAgaGFuZGxlcldyYXAgPSBmdW5jdGlvbiBoYW5kbGVyV3JhcCgpIHtcbiAgICAgIHJlbW92ZUV2ZW50Q2FjaGUodGFyZ2V0LCB0eXBlLCBoYW5kbGVyLCBpc09uY2UpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVyLmFwcGx5KHRhcmdldCwgYXJncyk7XG4gICAgfTtcbiAgfVxuICBpZiAoaGFuZGxlcldyYXApIHtcbiAgICBoYW5kbGVyc1sxXSA9IGhhbmRsZXJXcmFwO1xuICB9XG4gIGdldEV2dFR5cGVDYWNoZSh0YXJnZXQsIHR5cGUpLnB1c2goaGFuZGxlcnMpO1xufVxuXG4vKipcbiAqIOenu+mZpOS6i+S7tuebkeWQrFxuICogQHBhcmFtICB7T2JqZWN0fSAgdGFyZ2V0IOWPkeeUn+S6i+S7tueahOWvueixoVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOebkeWQrOWHveaVsFxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudENhY2hlKHRhcmdldCwgdHlwZSwgaGFuZGxlcikge1xuICB2YXIgaXNPbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICB2YXIgdHlwZUNhY2hlID0gZ2V0RXZ0VHlwZUNhY2hlKHRhcmdldCwgdHlwZSk7XG5cbiAgaWYgKGhhbmRsZXIgfHwgaXNPbmNlKSB7XG4gICAgLyog5pyJ5oyH5a6aIGhhbmRsZXIg5YiZ5riF6Zmk5a+55bqU55uR5ZCsICovXG4gICAgdmFyIGhhbmRsZXJJZCA9IC0xO1xuICAgIHZhciBoYW5kbGVyV3JhcCA9IHZvaWQgMDtcbiAgICB0eXBlQ2FjaGUuZmluZChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgaWYgKCghaGFuZGxlciB8fCBpdGVtWzBdID09PSBoYW5kbGVyKSAmJiAoIWlzT25jZSB8fCBpdGVtWzJdKSkge1xuICAgICAgICBoYW5kbGVySWQgPSBpO1xuICAgICAgICBoYW5kbGVyV3JhcCA9IGl0ZW1bMV07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChoYW5kbGVySWQgIT09IC0xKSB7XG4gICAgICB0eXBlQ2FjaGUuc3BsaWNlKGhhbmRsZXJJZCwgMSk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyV3JhcDtcbiAgfSBlbHNlIHtcbiAgICAvKiDmnKrmjIflrpogaGFuZGxlciDliJnmuIXpmaR0eXBl5a+55bqU55qE5omA5pyJ55uR5ZCsICovXG4gICAgdHlwZUNhY2hlLmxlbmd0aCA9IDA7XG4gIH1cbn1cblxuLyoqXG4gKiBAY2xhc3MgQ3VzdEV2ZW50XG4gKiBAZGVzY3JpcHRpb25cbiAqIEV2ZW50IOiHquWumuS5ieS6i+S7tuexu1xuICogMS4g5Y+v5Lul5L2/55So5LiN5Lyg5Y+C5b6X5Yiw55qE5a6e5L6L5L2c5Li6ZXZlbnRCdXPkvb/nlKhcbiAqIDIuIOWPr+S7pemAmui/h+aMh+WumnRhcmdldO+8jOeUqOWkmuS4quWunuS+i+aTjeS9nOWQjOS4gHRhcmdldOWvueixoeeahOS6i+S7tueuoeeQhlxuICogMy4g5b2T6K6+5a6adGFyZ2V05pe277yM5Y+v5Lul6YCa6L+H6K6+572uYXNzaWdu5Li6dHJ1Ze+8jOadpee7mXRhcmdldOWunueOsFwib25cXG9uY2VcXG9mZlxcZW1pdFwi5pa55rOVXG4gKiBAcGFyYW0gIHtPYmplY3R9ICB0YXJnZXQg5Y+R55Sf5LqL5Lu255qE5a+56LGh77yI56m65YiZ6buY6K6k5Li6ZXZlbnTlrp7kvovvvIlcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICBhc3NpZ24g5piv5ZCm5bCGXCJvblxcb25jZVxcb2ZmXFxlbWl0XCLmlrnms5Xlrp7njrDliLB0YXJnZXTlr7nosaHkuIpcbiAqIEByZXR1cm4ge2V2ZW50fVxuICovXG52YXIgQ3VzdEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDdXN0RXZlbnQodGFyZ2V0LCBhc3NpZ24kJDEpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1c3RFdmVudCk7XG5cbiAgICAvKiDorr7nva5fX3RhcmdldOS4jeWPr+aemuS4viAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX190YXJnZXQnLCB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5fX3RhcmdldCA9IHRoaXM7XG5cbiAgICBpZiAodGFyZ2V0KSB7XG5cbiAgICAgIGlmICgodHlwZW9mIHRhcmdldCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodGFyZ2V0KSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VzRXZlbnQgdGFyZ2V0IGFyZSBub3Qgb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fdGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgICAvKiDkuLp0YXJnZXTlrp7njrBvblxcb25jZVxcb2ZmXFxlbWl0ICovXG4gICAgICBpZiAoYXNzaWduJCQxKSB7XG4gICAgICAgIFsnb24nLCAnb25jZScsICdvZmYnLCAnZW1pdCddLmZvckVhY2goZnVuY3Rpb24gKG10aCkge1xuICAgICAgICAgIHRhcmdldFttdGhdID0gX3RoaXNbbXRoXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIOa3u+WKoOS6i+S7tuebkeWQrFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDnm5HlkKzlh73mlbBcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc09uY2Ug5Y2V5qyh55uR5ZCs57G75Z6LXG4gICAqIEByZXR1cm4ge2V2ZW50fVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDdXN0RXZlbnQsIFt7XG4gICAga2V5OiAnb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbih0eXBlLCBoYW5kbGVyKSB7XG4gICAgICB2YXIgaXNPbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgYWRkRXZlbnRDYWNoZSh0aGlzLl9fdGFyZ2V0LCB0eXBlLCBoYW5kbGVyLCBpc09uY2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5re75Yqg5LqL5Lu255uR5ZCsLOW5tuS4lOWPquaJp+ihjOS4gOasoVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg55uR5ZCs5Ye95pWwXG4gICAgICogQHJldHVybiB7ZXZlbnR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbmNlKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLm9uKHR5cGUsIGhhbmRsZXIsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOenu+mZpOS6i+S7tuebkeWQrFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg55uR5ZCs5Ye95pWwKOS4jeaMh+WummhhbmRsZXLliJnmuIXpmaR0eXBl5a+55bqU55qE5omA5pyJ5LqL5Lu255uR5ZCsKVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPbmNlIOWNleasoeebkeWQrOexu+Wei1xuICAgICAqIEByZXR1cm4ge2V2ZW50fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvZmYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYodHlwZSwgaGFuZGxlcikge1xuICAgICAgdmFyIGlzT25jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIHJlbW92ZUV2ZW50Q2FjaGUodGhpcy5fX3RhcmdldCwgdHlwZSwgaGFuZGxlciwgaXNPbmNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOinpuWPkeS6i+S7tuebkeWQrOWHveaVsFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAqIEByZXR1cm4ge2V2ZW50fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbWl0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdCh0eXBlLCBkYXRhKSB7XG4gICAgICBlbWl0RXZlbnRDYWNoZSh0aGlzLl9fdGFyZ2V0LCB0eXBlLCB7IGRhdGE6IGRhdGEgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3VzdEV2ZW50O1xufSgpO1xuXG4vKipcbiAqIGNoaW1lZS1oZWxwZXItZG9tIHYwLjEuMFxuICogKGMpIDIwMTcgdG94aWMtam9oYW5uXG4gKiBSZWxlYXNlZCB1bmRlciBNSVRcbiAqL1xuXG4vKipcbiAqIGNoaW1lZS1oZWxwZXItZXZlbnRzIHYwLjEuMFxuICogKGMpIDIwMTcgdG94aWMtam9oYW5uXG4gKiBSZWxlYXNlZCB1bmRlciBNSVRcbiAqL1xuXG4vKipcbiogQG1vZHVsZSBldmVudFxuKiBAYXV0aG9yIGh1enVuamllXG4qIEBkZXNjcmlwdGlvbiDoh6rlrprkuYnkuovku7bln7rnoYDnsbtcbiovXG5cbi8qIOe8k+WtmOS6i+S7tuebkeWQrOaWueazleWPiuWMheijhe+8jOWGhemDqOaVsOaNruagvOW8j++8mlxuICogdGFyZ2V0SW5kZXhfPHR5cGU6J2NsaWNrfG1vdXNldXB8ZG9uZSc+OiBbIFtcbiAqICAgZnVuY3Rpb24oKXsgLi4uIGhhbmRsZXIgLi4uIH0sXG4gKiAgIGZ1bmN0aW9uKCl7IC4uLiBoYW5kbGVyV3JhcCAuLi4gaGFuZGxlci5hcHBseSh0YXJnZXQsIGFyZ3VtZW50cykgLi4uIH0sXG4gKiAgIGlzT25jZVxuICogXV1cbiAqL1xudmFyIF9ldnRMaXN0ZW5lckNhY2hlJDEgPSBfT2JqZWN0JGNyZWF0ZShudWxsKTtcbl9ldnRMaXN0ZW5lckNhY2hlJDEuY291bnQgPSAwO1xuXG4vKipcbiAqIOW+l+WIsOafkOWvueixoeeahOafkOS6i+S7tuexu+Wei+WvueW6lOeahOebkeWQrOmYn+WIl+aVsOe7hFxuICogQHBhcmFtICB7T2JqZWN0fSAgdGFyZ2V0IOWPkeeUn+S6i+S7tueahOWvueixoVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LKOi/memHjOeahOaXtumXtOexu+Wei+S4jeWPquaYr+WQjeensO+8jOi/mOaYr+e8k+WtmOagh+ivhu+8jOWPr+S7pemAmui/h+a3u+WKoOWQjue8gOadpeWMuuWIhilcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBnZXRFdnRUeXBlQ2FjaGUkMSh0YXJnZXQsIHR5cGUpIHtcblxuICB2YXIgZXZ0SWQgPSB0YXJnZXQuX19ldnRfaWQ7XG4gIGlmICghZXZ0SWQpIHtcblxuICAgIC8qIOiuvue9rl9fZXZ0X2lk5LiN5Y+v5p6a5Li+ICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgJ19fZXZ0X2lkJywge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgLyog56m65a+56LGh5Yid5aeL5YyW57uR5a6a57Si5byVICovXG4gICAgZXZ0SWQgPSB0YXJnZXQuX19ldnRfaWQgPSArK19ldnRMaXN0ZW5lckNhY2hlJDEuY291bnQ7XG4gIH1cblxuICB2YXIgdHlwZUNhY2hlS2V5ID0gZXZ0SWQgKyAnXycgKyB0eXBlO1xuICB2YXIgZXZ0VHlwZUNhY2hlID0gX2V2dExpc3RlbmVyQ2FjaGUkMVt0eXBlQ2FjaGVLZXldO1xuICBpZiAoIWV2dFR5cGVDYWNoZSkge1xuICAgIGV2dFR5cGVDYWNoZSA9IF9ldnRMaXN0ZW5lckNhY2hlJDFbdHlwZUNhY2hlS2V5XSA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGV2dFR5cGVDYWNoZTtcbn1cblxuLyoqXG4gKiDop6blj5Hkuovku7bnm5HlkKzmlrnms5VcbiAqIEBwYXJhbSAge09iamVjdH0gIHRhcmdldCDlj5HnlJ/kuovku7bnmoTlr7nosaFcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50T2JqIOinpuWPkeS6i+S7tuaXtuimgeS8oOWbnueahGV2ZW505a+56LGhXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGVtaXRFdmVudENhY2hlJDEodGFyZ2V0LCB0eXBlLCBldmVudE9iaikge1xuICB2YXIgZXZ0ID0gX09iamVjdCRjcmVhdGUobnVsbCk7XG4gIGV2dC50eXBlID0gdHlwZTtcbiAgZXZ0LnRhcmdldCA9IHRhcmdldDtcbiAgaWYgKGV2ZW50T2JqKSB7XG4gICAgX09iamVjdCRhc3NpZ24oZXZ0LCBpc09iamVjdCQxKGV2ZW50T2JqKSA/IGV2ZW50T2JqIDogeyBkYXRhOiBldmVudE9iaiB9KTtcbiAgfVxuICBnZXRFdnRUeXBlQ2FjaGUkMSh0YXJnZXQsIHR5cGUpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAoaXRlbVsxXSB8fCBpdGVtWzBdKS5hcHBseSh0YXJnZXQsIFtldnRdKTtcbiAgfSk7XG59XG5cbi8qKlxuICog5re75Yqg5LqL5Lu255uR5ZCs5Yiw57yT5a2YXG4gKiBAcGFyYW0gIHtPYmplY3R9ICB0YXJnZXQg5Y+R55Sf5LqL5Lu255qE5a+56LGhXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg55uR5ZCs5Ye95pWwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzT25jZSDmmK/lkKbljZXmrKHmiafooYxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJXcmFwXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50Q2FjaGUkMSh0YXJnZXQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgdmFyIGlzT25jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gIHZhciBoYW5kbGVyV3JhcCA9IGFyZ3VtZW50c1s0XTtcblxuICBpZiAoaXNGdW5jdGlvbihpc09uY2UpICYmICFoYW5kbGVyV3JhcCkge1xuICAgIGhhbmRsZXJXcmFwID0gaXNPbmNlO1xuICAgIGlzT25jZSA9IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgaGFuZGxlcnMgPSBbaGFuZGxlciwgdW5kZWZpbmVkLCBpc09uY2VdO1xuICBpZiAoaXNPbmNlICYmICFoYW5kbGVyV3JhcCkge1xuICAgIGhhbmRsZXJXcmFwID0gZnVuY3Rpb24gaGFuZGxlcldyYXAoKSB7XG4gICAgICByZW1vdmVFdmVudENhY2hlJDEodGFyZ2V0LCB0eXBlLCBoYW5kbGVyLCBpc09uY2UpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVyLmFwcGx5KHRhcmdldCwgYXJncyk7XG4gICAgfTtcbiAgfVxuICBpZiAoaGFuZGxlcldyYXApIHtcbiAgICBoYW5kbGVyc1sxXSA9IGhhbmRsZXJXcmFwO1xuICB9XG4gIGdldEV2dFR5cGVDYWNoZSQxKHRhcmdldCwgdHlwZSkucHVzaChoYW5kbGVycyk7XG59XG5cbi8qKlxuICog56e76Zmk5LqL5Lu255uR5ZCsXG4gKiBAcGFyYW0gIHtPYmplY3R9ICB0YXJnZXQg5Y+R55Sf5LqL5Lu255qE5a+56LGhXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg55uR5ZCs5Ye95pWwXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50Q2FjaGUkMSh0YXJnZXQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgdmFyIGlzT25jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgdmFyIHR5cGVDYWNoZSA9IGdldEV2dFR5cGVDYWNoZSQxKHRhcmdldCwgdHlwZSk7XG5cbiAgaWYgKGhhbmRsZXIgfHwgaXNPbmNlKSB7XG4gICAgLyog5pyJ5oyH5a6aIGhhbmRsZXIg5YiZ5riF6Zmk5a+55bqU55uR5ZCsICovXG4gICAgdmFyIGhhbmRsZXJJZCA9IC0xO1xuICAgIHZhciBoYW5kbGVyV3JhcCA9IHZvaWQgMDtcbiAgICB0eXBlQ2FjaGUuZmluZChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgaWYgKCghaGFuZGxlciB8fCBpdGVtWzBdID09PSBoYW5kbGVyKSAmJiAoIWlzT25jZSB8fCBpdGVtWzJdKSkge1xuICAgICAgICBoYW5kbGVySWQgPSBpO1xuICAgICAgICBoYW5kbGVyV3JhcCA9IGl0ZW1bMV07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChoYW5kbGVySWQgIT09IC0xKSB7XG4gICAgICB0eXBlQ2FjaGUuc3BsaWNlKGhhbmRsZXJJZCwgMSk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyV3JhcDtcbiAgfSBlbHNlIHtcbiAgICAvKiDmnKrmjIflrpogaGFuZGxlciDliJnmuIXpmaR0eXBl5a+55bqU55qE5omA5pyJ55uR5ZCsICovXG4gICAgdHlwZUNhY2hlLmxlbmd0aCA9IDA7XG4gIH1cbn1cblxuLyoqXG4gKiBAY2xhc3MgQ3VzdEV2ZW50XG4gKiBAZGVzY3JpcHRpb25cbiAqIEV2ZW50IOiHquWumuS5ieS6i+S7tuexu1xuICogMS4g5Y+v5Lul5L2/55So5LiN5Lyg5Y+C5b6X5Yiw55qE5a6e5L6L5L2c5Li6ZXZlbnRCdXPkvb/nlKhcbiAqIDIuIOWPr+S7pemAmui/h+aMh+WumnRhcmdldO+8jOeUqOWkmuS4quWunuS+i+aTjeS9nOWQjOS4gHRhcmdldOWvueixoeeahOS6i+S7tueuoeeQhlxuICogMy4g5b2T6K6+5a6adGFyZ2V05pe277yM5Y+v5Lul6YCa6L+H6K6+572uYXNzaWdu5Li6dHJ1Ze+8jOadpee7mXRhcmdldOWunueOsFwib25cXG9uY2VcXG9mZlxcZW1pdFwi5pa55rOVXG4gKiBAcGFyYW0gIHtPYmplY3R9ICB0YXJnZXQg5Y+R55Sf5LqL5Lu255qE5a+56LGh77yI56m65YiZ6buY6K6k5Li6ZXZlbnTlrp7kvovvvIlcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICBhc3NpZ24g5piv5ZCm5bCGXCJvblxcb25jZVxcb2ZmXFxlbWl0XCLmlrnms5Xlrp7njrDliLB0YXJnZXTlr7nosaHkuIpcbiAqIEByZXR1cm4ge2V2ZW50fVxuICovXG52YXIgQ3VzdEV2ZW50JDEgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEN1c3RFdmVudCh0YXJnZXQsIGFzc2lnbiQkMSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3VzdEV2ZW50KTtcblxuICAgIC8qIOiuvue9rl9fdGFyZ2V05LiN5Y+v5p6a5Li+ICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfX3RhcmdldCcsIHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9fdGFyZ2V0ID0gdGhpcztcblxuICAgIGlmICh0YXJnZXQpIHtcblxuICAgICAgaWYgKCh0eXBlb2YgdGFyZ2V0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0YXJnZXQpKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXNFdmVudCB0YXJnZXQgYXJlIG5vdCBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX190YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgIC8qIOS4unRhcmdldOWunueOsG9uXFxvbmNlXFxvZmZcXGVtaXQgKi9cbiAgICAgIGlmIChhc3NpZ24kJDEpIHtcbiAgICAgICAgWydvbicsICdvbmNlJywgJ29mZicsICdlbWl0J10uZm9yRWFjaChmdW5jdGlvbiAobXRoKSB7XG4gICAgICAgICAgdGFyZ2V0W210aF0gPSBfdGhpc1ttdGhdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICog5re75Yqg5LqL5Lu255uR5ZCsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOebkeWQrOWHveaVsFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzT25jZSDljZXmrKHnm5HlkKznsbvlnotcbiAgICogQHJldHVybiB7ZXZlbnR9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEN1c3RFdmVudCwgW3tcbiAgICBrZXk6ICdvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIHZhciBpc09uY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICBhZGRFdmVudENhY2hlJDEodGhpcy5fX3RhcmdldCwgdHlwZSwgaGFuZGxlciwgaXNPbmNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOa3u+WKoOS6i+S7tuebkeWQrCzlubbkuJTlj6rmiafooYzkuIDmrKFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOebkeWQrOWHveaVsFxuICAgICAqIEByZXR1cm4ge2V2ZW50fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvbmNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25jZSh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5vbih0eXBlLCBoYW5kbGVyLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnp7vpmaTkuovku7bnm5HlkKxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOebkeWQrOWHveaVsCjkuI3mjIflrppoYW5kbGVy5YiZ5riF6ZmkdHlwZeWvueW6lOeahOaJgOacieS6i+S7tuebkeWQrClcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzT25jZSDljZXmrKHnm5HlkKznsbvlnotcbiAgICAgKiBAcmV0dXJuIHtldmVudH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb2ZmJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIHZhciBpc09uY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICByZW1vdmVFdmVudENhY2hlJDEodGhpcy5fX3RhcmdldCwgdHlwZSwgaGFuZGxlciwgaXNPbmNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOinpuWPkeS6i+S7tuebkeWQrOWHveaVsFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAqIEByZXR1cm4ge2V2ZW50fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbWl0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdCh0eXBlLCBkYXRhKSB7XG4gICAgICBlbWl0RXZlbnRDYWNoZSQxKHRoaXMuX190YXJnZXQsIHR5cGUsIHsgZGF0YTogZGF0YSB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDdXN0RXZlbnQ7XG59KCk7XG5cbi8qKlxuICogY2hpbWVlLWhlbHBlci11dGlscyB2MC4xLjFcbiAqIChjKSAyMDE3IHRveGljLWpvaGFublxuICogUmVsZWFzZWQgdW5kZXIgTUlUXG4gKi9cblxuLy8gKioqKioqKioqKioqKioqKioqKioqKiAganVkZ2VtZW50ICAgKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNoZWNrIGlmIHRoZSBjb2RlIHJ1bm5pbmcgaW4gYnJvd3NlciBlbnZpcm9ubWVudCAobm90IGluY2x1ZGUgd29ya2VyIGVudilcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG52YXIgaW5Ccm93c2VyJDEgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93KSAhPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKiogIOWvueixoeaTjeS9nCAgKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIOi9rOWPmOS4gOS4quexu+aVsOe7hOWvueixoeS4uuaVsOe7hFxuICovXG5mdW5jdGlvbiBtYWtlQXJyYXkkMShvYmopIHtcbiAgcmV0dXJuIF9BcnJheSRmcm9tKG9iaik7XG59XG5cbi8qKlxuKiBAbW9kdWxlIGRvbVxuKiBAYXV0aG9yIGh1enVuamllXG4qIEBkZXNjcmlwdGlvbiDkuIDkupvluLjnlKjnmoRET03liKTmlq3lj4rmk43kvZzmlrnms5XvvIzlj6/ku6Xkvb/nlKhkb20uJCgnKicp5YyF6KOFRE9N77yM5a6e546w57G7alF1ZXJ555qE6ZO+5byP5pON5L2c77yb5b2T54S26L+Z6YeM55qE6Z2Z5oCB5pa55rOV5Lmf5Y+v5Lul55u05o6l5L2/55So44CCXG4qL1xuXG52YXIgX2RpdkVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG52YXIgX3RleHRBdHRyTmFtZSA9ICdpbm5lclRleHQnO1xuJ3RleHRDb250ZW50JyBpbiBfZGl2RWwgJiYgKF90ZXh0QXR0ck5hbWUgPSAndGV4dENvbnRlbnQnKTtcbnZhciBfYXJyUHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKipcbiAqIOivu+WPlkhUTUzlhYPntKDlsZ7mgKflgLxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIOebruagh+WFg+e0oFxuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJOYW1lIOebruagh+WxnuaAp+WQjeensFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRBdHRyKGVsLCBhdHRyTmFtZSkge1xuICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcbn1cblxuLyoqXG4gKiDorr7nva5IVE1M5YWD57Sg5bGe5oCn5YC8XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCDnm67moIflhYPntKBcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyTmFtZSDnm67moIflsZ7mgKflkI3np7BcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyVmFsIOebruagh+WxnuaAp+WAvFxuICovXG5mdW5jdGlvbiBzZXRBdHRyKGVsLCBhdHRyTmFtZSwgYXR0clZhbCkge1xuICBpZiAoYXR0clZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWwpO1xuICB9XG59XG5cbi8qKlxuICog5Li6SFRNTOWFg+e0oOa3u+WKoGNsYXNzTmFtZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwg55uu5qCH5YWD57SgXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xzIOimgea3u+WKoOeahGNsYXNzTmFtZe+8iOWkmuS4quS7peepuuagvOWIhuWJsu+8iVxuICovXG5mdW5jdGlvbiBhZGRDbGFzc05hbWUoZWwsIGNscykge1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjbHNBcnIgPSBjbHMuc3BsaXQoL1xccysvKTtcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGNsc0Fyci5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyQ2xzID0gJyAnICsgKGVsLmNsYXNzTmFtZSB8fCAnJykgKyAnICc7XG4gICAgY2xzQXJyLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGN1ckNscy5pbmRleE9mKCcgJyArIGMgKyAnICcpID09PSAtMSAmJiAoY3VyQ2xzICs9ICcgJyArIGMpO1xuICAgIH0pO1xuICAgIGVsLmNsYXNzTmFtZSA9IGN1ckNscy50cmltKCk7XG4gIH1cbn1cblxuLyoqXG4gKiDkuLpIVE1M5YWD57Sg56e76ZmkY2xhc3NOYW1lXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCDnm67moIflhYPntKBcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbHMg6KaB56e76Zmk55qEY2xhc3NOYW1l77yI5aSa5Liq5Lul56m65qC85YiG5Ymy77yJXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzTmFtZShlbCwgY2xzKSB7XG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2xzQXJyID0gY2xzLnNwbGl0KC9cXHMrLyk7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBjbHNBcnIuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ckNscyA9ICcgJyArIGVsLmNsYXNzTmFtZSArICcgJztcbiAgICBjbHNBcnIuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgdmFyIHRhciA9ICcgJyArIGMgKyAnICc7XG4gICAgICB3aGlsZSAoY3VyQ2xzLmluZGV4T2YodGFyKSAhPT0gLTEpIHtcbiAgICAgICAgY3VyQ2xzID0gY3VyQ2xzLnJlcGxhY2UodGFyLCAnICcpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVsLmNsYXNzTmFtZSA9IGN1ckNscy50cmltKCk7XG4gIH1cbn1cblxuLyoqXG4gKiDmo4Dmn6VIVE1M5YWD57Sg5piv5ZCm5bey6K6+572uY2xhc3NOYW1lXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCDnm67moIflhYPntKBcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUg6KaB5qOA5p+l55qEY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNDbGFzc05hbWUoZWwsIGNsYXNzTmFtZSkge1xuICByZXR1cm4gbmV3IFJlZ0V4cCgnKD86XnxcXFxccyknICsgY2xhc3NOYW1lICsgJyg/PVxcXFxzfCQpJykudGVzdChlbC5jbGFzc05hbWUpO1xufVxuXG4vKipcbiAqIOS4ukhUTUzlhYPntKDnp7vpmaTkuovku7bnm5HlkKxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIOebruagh+WFg+e0oFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu25ZCN56ewXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOWkhOeQhuWHveaVsFxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIOaYr+WQpuWPquebkeWQrOS4gOasoVxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlIOaYr+WQpuWcqOaNleiOt+mYtuauteeahOebkeWQrFxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudChlbCwgdHlwZSwgaGFuZGxlcikge1xuICB2YXIgb25jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gIHZhciBjYXB0dXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICBpZiAob25jZSkge1xuICAgIC8qIOWwneivleS7jue8k+WtmOS4reivu+WPluWMheijheWQjueahOaWueazlSAqL1xuICAgIHZhciBoYW5kbGVyV3JhcCA9IHJlbW92ZUV2ZW50Q2FjaGUkMShlbCwgdHlwZSArICdfb25jZScsIGhhbmRsZXIpO1xuICAgIGlmIChoYW5kbGVyV3JhcCkge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXJXcmFwO1xuICAgIH1cbiAgfVxuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG4vKipcbiAqIOS4ukhUTUzlhYPntKDmt7vliqDkuovku7bnm5HlkKxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIOebruagh+WFg+e0oFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu25ZCN56ewXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOWkhOeQhuWHveaVsFxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIOaYr+WQpuWPquebkeWQrOS4gOasoVxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlIOaYr+WQpuWcqOaNleiOt+mYtuauteebkeWQrFxuICovXG5mdW5jdGlvbiBhZGRFdmVudChlbCwgdHlwZSwgaGFuZGxlcikge1xuICB2YXIgb25jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gIHZhciBjYXB0dXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICBpZiAob25jZSkge1xuICAgIHZhciBvbGRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgb2xkSGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmVtb3ZlRXZlbnQoZWwsIHR5cGUsIGhhbmRsZXIsIG9uY2UsIGNhcHR1cmUpO1xuICAgICAgfTtcbiAgICB9KCk7XG4gICAgLyog5bCG5YyF6KOF5ZCO55qE5pa55rOV6K6w5b2V5Yiw57yT5a2Y5LitICovXG4gICAgYWRkRXZlbnRDYWNoZSQxKGVsLCB0eXBlICsgJ19vbmNlJywgb2xkSGFuZGxlciwgaGFuZGxlcik7XG4gIH1cblxuICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG4vKipcbiAqIOS4ukhUTUzlhYPntKDmt7vliqDkuovku7bku6PnkIZcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIOebruagh+WFg+e0oFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIOimgeiiq+S7o+eQhueahOWFg+e0oFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu25ZCN56ewXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOWkhOeQhuWHveaVsFxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlIOaYr+WQpuWcqOaNleiOt+mYtuauteebkeWQrFxuICovXG5mdW5jdGlvbiBhZGREZWxlZ2F0ZShlbCwgc2VsZWN0b3IsIHR5cGUsIGhhbmRsZXIpIHtcbiAgdmFyIGNhcHR1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG5cbiAgdmFyIGhhbmRsZXJXcmFwID0gZnVuY3Rpb24gaGFuZGxlcldyYXAoZSkge1xuICAgIHZhciB0YXJnZXRFbHMgPSBmaW5kUGFyZW50cyhlLnNyY0VsZW1lbnQsIGVsLCB0cnVlKTtcbiAgICB2YXIgdGFyZ2V0RWwgPSBxdWVyeShzZWxlY3RvciwgZWwsIHRydWUpLmZpbmQoZnVuY3Rpb24gKHNlRWwpIHtcbiAgICAgIHJldHVybiB0YXJnZXRFbHMuZmluZChmdW5jdGlvbiAodGdFbCkge1xuICAgICAgICByZXR1cm4gc2VFbCA9PT0gdGdFbDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRhcmdldEVsICYmIGhhbmRsZXIuYXBwbHkodGFyZ2V0RWwsIGFyZ3VtZW50cyk7XG4gIH07XG4gIC8qIOWwhuWMheijheWQjueahOaWueazleiusOW9leWIsOe8k+WtmOS4rSAqL1xuICBhZGRFdmVudENhY2hlJDEoZWwsIHR5cGUgKyAnX2RlbGVnYXRlXycgKyBzZWxlY3RvciwgaGFuZGxlciwgaGFuZGxlcldyYXApO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXJXcmFwLCBjYXB0dXJlKTtcbn1cblxuLyoqXG4gKiDkuLpIVE1M5YWD57Sg56e76Zmk5LqL5Lu25Luj55CGXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCDnm67moIflhYPntKBcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciDopoHooqvku6PnkIbnmoTlhYPntKBcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuWQjeensFxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDlpITnkIblh73mlbBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZSDmmK/lkKblnKjmjZXojrfpmLbmrrXnm5HlkKxcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRGVsZWdhdGUoZWwsIHNlbGVjdG9yLCB0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBjYXB0dXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAvKiDlsJ3or5Xku47nvJPlrZjkuK3or7vlj5bljIXoo4XlkI7nmoTmlrnms5UgKi9cbiAgdmFyIGhhbmRsZXJXcmFwID0gcmVtb3ZlRXZlbnRDYWNoZSQxKGVsLCB0eXBlICsgJ19kZWxlZ2F0ZV8nICsgc2VsZWN0b3IsIGhhbmRsZXIpO1xuICBoYW5kbGVyV3JhcCAmJiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXJXcmFwLCBjYXB0dXJlKTtcbn1cblxuLyoqXG4gKiDor7vlj5ZIVE1M5YWD57Sg5qC35byP5YC8XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCDnm67moIflhYPntKBcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkg5qC35byPa2V5XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlKGVsLCBrZXkpIHtcbiAgcmV0dXJuIChlbC5jdXJyZW50U3R5bGUgfHwgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkpW2tleV0gfHwgZWwuc3R5bGVba2V5XTtcbn1cblxuLyoqXG4gKiDorr7nva5IVE1M5YWD57Sg5qC35byP5YC8XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCDnm67moIflhYPntKBcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkg5qC35byPa2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsIOagt+W8j+WAvFxuICovXG5mdW5jdGlvbiBzZXRTdHlsZShlbCwga2V5LCB2YWwpIHtcbiAgaWYgKGlzT2JqZWN0JDEoa2V5KSkge1xuICAgIGZvciAodmFyIGsgaW4ga2V5KSB7XG4gICAgICBzZXRTdHlsZShlbCwgaywga2V5W2tdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZWwuc3R5bGVba2V5XSA9IHZhbDtcbiAgfVxufVxuXG4vKipcbiAqIOagueaNrumAieaLqeWZqOafpeivouebruagh+WFg+e0oFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIOmAieaLqeWZqCznlKjkuo4gcXVlcnlTZWxlY3RvckFsbFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIOeItuWuueWZqFxuICogQHBhcmFtIHtCb29sZWFufSB0b0FycmF5IOW8uuWItui+k+WHuuS4uuaVsOe7hFxuICogQHJldHVybiB7Tm9kZUxpc3R8QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5KHNlbGVjdG9yKSB7XG4gIHZhciBjb250YWluZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGRvY3VtZW50O1xuICB2YXIgdG9BcnJheSA9IGFyZ3VtZW50c1syXTtcblxuICB2YXIgcmV0Tm9kZUxpc3QgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIHJldHVybiB0b0FycmF5ID8gX0FycmF5JGZyb20ocmV0Tm9kZUxpc3QpIDogcmV0Tm9kZUxpc3Q7XG59XG5cbi8qKlxuICog5LuORE9N5qCR5Lit56e76ZmkZWxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIOebruagh+WFg+e0oFxuICovXG5mdW5jdGlvbiByZW1vdmVFbChlbCkge1xuICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbn1cblxuLyoqXG4gKiDmn6Xmib7lhYPntKDnmoTniLboioLngrnku6xcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIOebruagh+WFg+e0oFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZW5kRWwg5pyA5aSn54i25a655Zmo77yI5LiN5oyH5a6a5YiZ5om+5YiwaHRtbO+8iVxuICogQHBhcmFtIHtCb29sZWFufSBoYXZlRWwg5YyF5ZCr5b2T5YmN5YWD57SgXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGhhdmVFbmRFbCDljIXlkKvorr7lrprnmoTmnIDlpKfniLblrrnlmahcbiAqL1xuZnVuY3Rpb24gZmluZFBhcmVudHMoZWwpIHtcbiAgdmFyIGVuZEVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICB2YXIgaGF2ZUVsID0gYXJndW1lbnRzWzJdO1xuICB2YXIgaGF2ZUVuZEVsID0gYXJndW1lbnRzWzNdO1xuXG4gIHZhciByZXRFbHMgPSBbXTtcbiAgaWYgKGhhdmVFbCkge1xuICAgIHJldEVscy5wdXNoKGVsKTtcbiAgfVxuICB3aGlsZSAoZWwgJiYgZWwucGFyZW50Tm9kZSAhPT0gZW5kRWwpIHtcbiAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgZWwgJiYgcmV0RWxzLnB1c2goZWwpO1xuICB9XG4gIGlmIChoYXZlRW5kRWwpIHtcbiAgICByZXRFbHMucHVzaChlbmRFbCk7XG4gIH1cbiAgcmV0dXJuIHJldEVscztcbn1cblxuLyoqXG4gKiDmoLnmja7pgInmi6nlmajmn6Xor6LlubblvpfliLDnm67moIflhYPntKDnmoR3cmFw5YyF6KOF5ZmoXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3Ig6YCJ5oup5ZmoLOWPpuWkluaUr+aMgSBIVE1MU3RyaW5nfHxOb2RlTGlzdHx8Tm9kZUFycmF5fHxIVE1MRWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIOeItuWuueWZqFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiAkKHNlbGVjdG9yLCBjb250YWluZXIpIHtcbiAgcmV0dXJuIHNlbGVjdG9yLmNvbnN0cnVjdG9yID09PSBOb2RlV3JhcCA/IHNlbGVjdG9yIDogbmV3IE5vZGVXcmFwKHNlbGVjdG9yLCBjb250YWluZXIpO1xufVxuXG4vKipcbiAqIEBjbGFzcyBOb2RlV3JhcFxuICogQGRlc2NyaXB0aW9uXG4gKiBOb2RlV3JhcCBET03ljIXoo4XlmajvvIznlKjku6Xlrp7njrDln7rmnKznmoTpk77lvI/mk43kvZxcbiAqIG5ldyBkb20uTm9kZVdyYXAoJyonKSDnm7jlvZPkuo4gZG9tLiQoJyonKVxuICog6L+Z6YeM6Z2i55So5LqORE9N5pON5L2c55qE5bGe5oCn5pa55rOV6YO95piv5Z+65LqO5LiK6Z2i6Z2Z5oCB5pa55rOV5a6e546w77yM5pyJ6ZyA6KaB5Y+v5Lul6ZqP5pe25L+u5pS56KGl5YWFXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3Ig6YCJ5oup5ZmoKOWFvOWuuSBTdHJpbmd8fEhUTUxTdHJpbmd8fE5vZGVMaXN0fHxOb2RlQXJyYXl8fEhUTUxFbGVtZW50KVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIOeItuWuueWZqO+8iOm7mOiupOS4umRvY3VtZW5077yJXG4gKi9cblxudmFyIE5vZGVXcmFwID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb2RlV3JhcChzZWxlY3Rvcikge1xuICAgIHZhciBjb250YWluZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGRvY3VtZW50O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVXcmFwKTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgX3RoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuICAgIC8qIFN0cmluZ3x8Tm9kZUxpc3R8fEhUTUxFbGVtZW50IOivhuWIq+WkhOeQhiAqL1xuICAgIHZhciBlbHNBcnIgPSB2b2lkIDA7XG4gICAgaWYgKHNlbGVjdG9yICYmIHNlbGVjdG9yLmNvbnN0cnVjdG9yID09PSBOb2RlTGlzdCkge1xuICAgICAgLyog5pSv5oyB55u05o6l5Lyg5YWlTm9kZUxpc3TmnaXmnoTlu7rljIXoo4XlmaggKi9cbiAgICAgIGVsc0FyciA9IG1ha2VBcnJheSQxKHNlbGVjdG9yKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoc2VsZWN0b3IpKSB7XG4gICAgICAvKiDmlK/mjIHnm7TmjqXkvKDlhaVOb2Rl5pWw57uE5p2l5p6E5bu65YyF6KOF5ZmoICovXG4gICAgICBlbHNBcnIgPSBzZWxlY3RvcjtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgaWYgKHNlbGVjdG9yLmluZGV4T2YoJzwnKSA9PT0gMCkge1xuICAgICAgICAvKiDmlK/mjIHnm7TmjqXkvKDlhaVIVE1M5a2X56ym5Liy5p2l5paw5bu6RE9N5bm25p6E5bu65YyF6KOF5ZmoICovXG4gICAgICAgIF9kaXZFbC5pbm5lckhUTUwgPSBzZWxlY3RvcjtcbiAgICAgICAgZWxzQXJyID0gcXVlcnkoJyonLCBfZGl2RWwsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyog5pSv5oyB55u05o6l5Lyg5YWl5a2X56ym5Liy6YCJ5oup5Zmo5p2l5p+l5om+RE9N5bm25p6E5bu65YyF6KOF5ZmoICovXG4gICAgICAgIGVsc0FyciA9IHF1ZXJ5KHNlbGVjdG9yLCBjb250YWluZXIsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiDlhbbku5bku7vmhI/lr7nosaHnm7TmjqXmnoTlu7rljIXoo4XlmaggKi9cbiAgICAgIGVsc0FyciA9IFtzZWxlY3Rvcl07XG4gICAgfVxuICAgIF9PYmplY3QkYXNzaWduKF90aGlzLCBlbHNBcnIpO1xuXG4gICAgLyogTm9kZVdyYXDmnKzmhI/lj6/ku6UgZXh0ZW5kcyBBcnJheeecgeeVpeaehOmAoOaWueazleS4reS4i+mdoui/memDqOWIhuS7o+egge+8jOS9huebruWJjee8luivkeS4jeaUr+aMgSAqL1xuICAgIF90aGlzLmxlbmd0aCA9IGVsc0Fyci5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICog5b6q546v6YGN5Y6GRE9N6ZuG5ZCIXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIOmBjeWOhuWHveaVsCBmbihpdGVtLCBpKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE5vZGVXcmFwLCBbe1xuICAgIGtleTogJ2VhY2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBfYXJyUHJvdG90eXBlLmZvckVhY2guYXBwbHkodGhpcywgYXJncyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwdXNoJyxcblxuXG4gICAgLyoqXG4gICAgICog5re75Yqg5YWD57Sg5YiwRE9N6ZuG5ZCIXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwg6KaB5Yqg5YWl55qE5YWD57SgXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgX2FyclByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3BsaWNlJyxcblxuXG4gICAgLyoqXG4gICAgICog5oiq5Y+WRE9N6ZuG5ZCI54mH5q6177yM5bm25b6X5Yiw5paw55qE5YyF6KOF5Zmoc3BsaWNlXG4gICAgICogQHBhcmFtIHtOdWJtZXJ9IHN0YXJ0XG4gICAgICogQHBhcmFtIHtOdWJtZXJ9IGNvdW50XG4gICAgICogQHJldHVybiB7Tm9kZVdyYXB9IOaWsOeahERPTembhuWQiOWMheijheWZqFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpY2UoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkKF9hcnJQcm90b3R5cGUuc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmaW5kJyxcblxuXG4gICAgLyoqXG4gICAgICog5p+l5om+5a2Q5YWD57SgXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIOmAieaLqeWZqFxuICAgICAqIEByZXR1cm4ge05vZGVXcmFwfSDmlrDnmoRET03pm4blkIjljIXoo4XlmahcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZChzZWxlY3Rvcikge1xuICAgICAgdmFyIGNoaWxkcyA9IFtdO1xuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBjaGlsZHMgPSBjaGlsZHMuY29uY2F0KHF1ZXJ5KHNlbGVjdG9yLCBlbCwgdHJ1ZSkpO1xuICAgICAgfSk7XG4gICAgICB2YXIgY2hpbGRzV3JhcCA9ICQoY2hpbGRzKTtcbiAgICAgIGNoaWxkc1dyYXAucGFyZW50ID0gdGhpcztcbiAgICAgIGNoaWxkc1dyYXAuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgIHJldHVybiBjaGlsZHNXcmFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOa3u+WKoOWtkOWFg+e0oFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNoaWxkRWxzIOimgea3u+WKoOeahEhUTUzlhYPntKBcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhcHBlbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQoY2hpbGRFbHMpIHtcbiAgICAgIHZhciBjaGlsZHNXcmFwID0gJChjaGlsZEVscyk7XG4gICAgICB2YXIgZmlyc3RFbCA9IHRoaXNbMF07XG4gICAgICBjaGlsZHNXcmFwLmVhY2goZnVuY3Rpb24gKG5ld0VsKSB7XG4gICAgICAgIHJldHVybiBmaXJzdEVsLmFwcGVuZENoaWxkKG5ld0VsKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5bCG5YWD57Sg6ZuG5ZCI5re75Yqg5Yiw5oyH5a6a5a655ZmoXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50RWwg6KaB5re75Yqg5Yiw54i25a655ZmoXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXBwZW5kVG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRUbyhwYXJlbnRFbCkge1xuICAgICAgJChwYXJlbnRFbCkuYXBwZW5kKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRE9N6ZuG5ZCIdGV4dOWGheWuueivu+WGmeaTjeS9nFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwg5paH5pys5YaF5a6577yI5aaC5p6c5pyJ6K6+572u6K+l5Y+C5pWw5YiZ5omn6KGM5YaZ5pON5L2c77yM5ZCm5YiZ5omn6KGM6K+75pON5L2c77yJXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHQodmFsKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpc1swXVtfdGV4dEF0dHJOYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsW190ZXh0QXR0ck5hbWVdID0gdmFsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRE9N6ZuG5ZCISFRNTOWGheWuueivu+WGmeaTjeS9nFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIGh0bWzlhoXlrrnvvIjlpoLmnpzmnInorr7nva7or6Xlj4LmlbDliJnmiafooYzlhpnmk43kvZzvvIzlkKbliJnmiafooYzor7vmk43kvZzvvIlcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdodG1sJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaHRtbChfaHRtbCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0uaW5uZXJIVE1MO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gX2h0bWw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBET03pm4blkIjlsZ7mgKfor7vlhpnmk43kvZxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSDlsZ7mgKflkI3np7BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsIOWxnuaAp+WAvO+8iOWmguaenOacieiuvue9ruivpeWPguaVsOWImeaJp+ihjOWGmeaTjeS9nO+8jOWQpuWImeaJp+ihjOivu+aTjeS9nO+8iVxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2F0dHInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyKG5hbWUsIHZhbCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGdldEF0dHIodGhpc1swXSwgbmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gc2V0QXR0cihlbCwgbmFtZSwgdmFsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERPTembhuWQiGRhdGFzZXTor7vlhpnmk43kvZxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IOmUruWQjVxuICAgICAqIEBwYXJhbSB7QW55fSB2YWwg6ZSu5YC877yI5aaC5p6c5pyJ6K6+572u6K+l5Y+C5pWw5YiZ5omn6KGM5YaZ5pON5L2c77yM5ZCm5YiZ5omn6KGM6K+75pON5L2c77yJXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGF0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRhdGEoa2V5LCB2YWwpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzBdLmRhdGFzZXQgfHwge307XG4gICAgICB9XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gKHRoaXNbMF0uZGF0YXNldCB8fCB7fSlba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIChlbC5kYXRhc2V0IHx8IChlbC5kYXRhc2V0ID0ge30pKVtrZXldID0gdmFsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRE9N6ZuG5ZCI5qC35byP6K+75YaZ5pON5L2cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSDmoLflvI9rZXlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsIOagt+W8j+WAvO+8iOWmguaenOacieiuvue9ruivpeWPguaVsOWImeaJp+ihjOWGmeaTjeS9nO+8jOWQpuWImeaJp+ihjOivu+aTjeS9nO+8iVxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNzcyhrZXksIHZhbCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgIWlzT2JqZWN0JDEoa2V5KSkge1xuICAgICAgICByZXR1cm4gZ2V0U3R5bGUodGhpc1swXSwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBzZXRTdHlsZShlbCwga2V5LCB2YWwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Li6RE9N6ZuG5ZCI5aKe5YqgY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNscyDopoHlop7liqDnmoRjbGFzc05hbWVcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRDbGFzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENsYXNzKGNscykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGFkZENsYXNzTmFtZShlbCwgY2xzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOenu+mZpOW9k+WJjURPTembhuWQiOeahGNsYXNzTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbHMg6KaB56e76Zmk55qEY2xhc3NOYW1lXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlQ2xhc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDbGFzcyhjbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVDbGFzc05hbWUoZWwsIGNscyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmo4Dmn6XntKLlvJUw55qERE9N5piv5ZCm5pyJY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNscyDopoHmo4Dmn6XnmoRjbGFzc05hbWVcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdoYXNDbGFzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0NsYXNzKGNscykge1xuICAgICAgcmV0dXJuIGhhc0NsYXNzTmFtZSh0aGlzWzBdLCBjbHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOS4ukRPTembhuWQiOa3u+WKoOS6i+S7tuebkeWQrFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuWQjeensFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5aSE55CG5Ye95pWwXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbmNlIOaYr+WQpuWPquebkeWQrOS4gOasoVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZSDmmK/lkKblnKjmjZXojrfpmLbmrrXnm5HlkKxcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIHZhciBvbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciBjYXB0dXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGFkZEV2ZW50KGVsLCB0eXBlLCBoYW5kbGVyLCBvbmNlLCBjYXB0dXJlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOS4ukRPTembhuWQiOino+mZpOS6i+S7tuebkeWQrFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuWQjeensFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5aSE55CG5Ye95pWwXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbmNlIOaYr+WQpuWPquebkeWQrOS4gOasoVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZSDmmK/lkKblnKjmjZXojrfpmLbmrrXnm5HlkKxcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvZmYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYodHlwZSwgaGFuZGxlcikge1xuICAgICAgdmFyIG9uY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIGNhcHR1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRXZlbnQoZWwsIHR5cGUsIGhhbmRsZXIsIG9uY2UsIGNhcHR1cmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Li6RE9N6ZuG5ZCI57uR5a6a5LqL5Lu25Luj55CGXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIOebruagh+WtkOWFg+e0oOmAieaLqeWZqFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuWQjeensFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5aSE55CG5Ye95pWwXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlIOaYr+WQpuWcqOaNleiOt+mYtuauteebkeWQrFxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlbGVnYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZWdhdGUoc2VsZWN0b3IsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIHZhciBjYXB0dXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGFkZERlbGVnYXRlKGVsLCBzZWxlY3RvciwgdHlwZSwgaGFuZGxlciwgY2FwdHVyZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDkuLpET03pm4blkIjop6Pnu5Hkuovku7bku6PnkIZcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3Ig55uu5qCH5a2Q5YWD57Sg6YCJ5oup5ZmoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu25ZCN56ewXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDlpITnkIblh73mlbBcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmUg5piv5ZCm5Zyo5o2V6I636Zi25q6155uR5ZCsXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5kZWxlZ2F0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuZGVsZWdhdGUoc2VsZWN0b3IsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIHZhciBjYXB0dXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZURlbGVnYXRlKGVsLCBzZWxlY3RvciwgdHlwZSwgaGFuZGxlciwgY2FwdHVyZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDku45ET03moJHkuK3np7vpmaRcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRWwoZWwpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vZGVXcmFwO1xufSgpO1xuXG4vKipcbiAqIGNoaW1lZS1oZWxwZXItbG9nIHYwLjEuMFxuICogKGMpIDIwMTcgc29uZ2d1YW5neXVcbiAqIFJlbGVhc2VkIHVuZGVyIE1JVFxuICovXG5cbnZhciBMb2cgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExvZygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9nKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMb2csIG51bGwsIFt7XG4gICAga2V5OiAnZXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvcih0YWcsIG1zZykge1xuICAgICAgaWYgKCFMb2cuRU5BQkxFX0VSUk9SKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0YWcgfHwgTG9nLkZPUkNFX0dMT0JBTF9UQUcpIHtcbiAgICAgICAgdGFnID0gTG9nLkdMT0JBTF9UQUc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyID0gJ1snICsgdGFnICsgJ10gPiAnICsgbXNnO1xuXG4gICAgICBpZiAoY29uc29sZS5lcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKHN0cik7XG4gICAgICB9IGVsc2UgaWYgKGNvbnNvbGUud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oc3RyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHN0cik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5mbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZm8odGFnLCBtc2cpIHtcbiAgICAgIGlmICghTG9nLkVOQUJMRV9JTkZPKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0YWcgfHwgTG9nLkZPUkNFX0dMT0JBTF9UQUcpIHtcbiAgICAgICAgdGFnID0gTG9nLkdMT0JBTF9UQUc7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHIgPSAnWycgKyB0YWcgKyAnXSA+ICcgKyBtc2c7XG5cbiAgICAgIGlmIChjb25zb2xlLmluZm8pIHtcbiAgICAgICAgY29uc29sZS5pbmZvKHN0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhzdHIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3dhcm4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3YXJuKHRhZywgbXNnKSB7XG4gICAgICBpZiAoIUxvZy5FTkFCTEVfV0FSTikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGFnIHx8IExvZy5GT1JDRV9HTE9CQUxfVEFHKSB7XG4gICAgICAgIHRhZyA9IExvZy5HTE9CQUxfVEFHO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RyID0gJ1snICsgdGFnICsgJ10gPiAnICsgbXNnO1xuXG4gICAgICBpZiAoY29uc29sZS53YXJuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihzdHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coc3RyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWJ1ZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlYnVnKHRhZywgbXNnKSB7XG4gICAgICBpZiAoIUxvZy5FTkFCTEVfREVCVUcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRhZyB8fCBMb2cuRk9SQ0VfR0xPQkFMX1RBRykge1xuICAgICAgICB0YWcgPSBMb2cuR0xPQkFMX1RBRztcbiAgICAgIH1cblxuICAgICAgdmFyIHN0ciA9ICdbJyArIHRhZyArICddID4gJyArIG1zZztcblxuICAgICAgaWYgKGNvbnNvbGUuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhzdHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coc3RyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd2ZXJib3NlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmVyYm9zZSh0YWcsIG1zZykge1xuICAgICAgaWYgKCFMb2cuRU5BQkxFX1ZFUkJPU0UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRhZyB8fCBMb2cuRk9SQ0VfR0xPQkFMX1RBRykge1xuICAgICAgICB0YWcgPSBMb2cuR0xPQkFMX1RBRztcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1snICsgdGFnICsgJ10gPiAnICsgbXNnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTG9nO1xufSgpO1xuXG5Mb2cuR0xPQkFMX1RBRyA9ICdjaGltZWUnO1xuTG9nLkZPUkNFX0dMT0JBTF9UQUcgPSBmYWxzZTtcbkxvZy5FTkFCTEVfRVJST1IgPSB0cnVlO1xuTG9nLkVOQUJMRV9JTkZPID0gdHJ1ZTtcbkxvZy5FTkFCTEVfV0FSTiA9IHRydWU7XG5Mb2cuRU5BQkxFX0RFQlVHID0gdHJ1ZTtcbkxvZy5FTkFCTEVfVkVSQk9TRSA9IHRydWU7XG5cbmV4cG9ydHMuTG9nID0gTG9nO1xuZXhwb3J0cy5nZW5UcmF2ZXJzYWxIYW5kbGVyID0gZ2VuVHJhdmVyc2FsSGFuZGxlcjtcbmV4cG9ydHMuZGVlcENsb25lID0gZGVlcENsb25lO1xuZXhwb3J0cy5kZWVwQXNzaWduID0gZGVlcEFzc2lnbjtcbmV4cG9ydHMuY2FtZWxpemUgPSBjYW1lbGl6ZTtcbmV4cG9ydHMuaHlwZW5hdGUgPSBoeXBlbmF0ZTtcbmV4cG9ydHMuYmluZCA9IGJpbmQ7XG5leHBvcnRzLnV1aWQgPSB1dWlkO1xuZXhwb3J0cy5TNCA9IFM0O1xuZXhwb3J0cy5yYW5kID0gcmFuZDtcbmV4cG9ydHMuaXNWb2lkID0gaXNWb2lkO1xuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3QkMTtcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbmV4cG9ydHMuaXNOdW1lcmljID0gaXNOdW1lcmljO1xuZXhwb3J0cy5pc0ludGVnZXIgPSBpc0ludGVnZXI7XG5leHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5O1xuZXhwb3J0cy5pc0V2ZW50ID0gaXNFdmVudDtcbmV4cG9ydHMuaXNCbG9iID0gaXNCbG9iO1xuZXhwb3J0cy5pc0ZpbGUgPSBpc0ZpbGU7XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5leHBvcnRzLmlzVXJsID0gaXNVcmw7XG5leHBvcnRzLmlzTm9kZSA9IGlzTm9kZTtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0NoaWxkTm9kZSA9IGlzQ2hpbGROb2RlO1xuZXhwb3J0cy5pc1Bvc3Rlcml0eU5vZGUgPSBpc1Bvc3Rlcml0eU5vZGU7XG5leHBvcnRzLmlzSFRNTFN0cmluZyA9IGlzSFRNTFN0cmluZztcbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5leHBvcnRzLmluQnJvd3NlciA9IGluQnJvd3NlcjtcbmV4cG9ydHMubWFrZUFycmF5ID0gbWFrZUFycmF5O1xuZXhwb3J0cy50cmFuc09iamVjdEF0dHJJbnRvQXJyYXkgPSB0cmFuc09iamVjdEF0dHJJbnRvQXJyYXk7XG5leHBvcnRzLnJ1blJlamVjdGFibGVRdWV1ZSA9IHJ1blJlamVjdGFibGVRdWV1ZTtcbmV4cG9ydHMucnVuU3RvcHBhYmxlUXVldWUgPSBydW5TdG9wcGFibGVRdWV1ZTtcbmV4cG9ydHMuc2V0RnJvemVuQXR0ciA9IHNldEZyb3plbkF0dHI7XG5leHBvcnRzLnNldEF0dHJHZXR0ZXJBbmRTZXR0ZXIgPSBzZXRBdHRyR2V0dGVyQW5kU2V0dGVyO1xuZXhwb3J0cy5kZWNvZGVVVEY4ID0gZGVjb2RlVVRGODtcbmV4cG9ydHMuZGVib3VuY2UgPSBkZWJvdW5jZTtcbmV4cG9ydHMudGhyb3R0bGUgPSB0aHJvdHRsZTtcbmV4cG9ydHMucmFmID0gcmFmO1xuZXhwb3J0cy5jYWYgPSBjYWY7XG5leHBvcnRzLnN0clJlcGVhdCA9IHN0clJlcGVhdDtcbmV4cG9ydHMuZm9ybWF0VGltZSA9IGZvcm1hdFRpbWU7XG5leHBvcnRzLmFkZFRyYW5zTWV0aG9kID0gYWRkVHJhbnNNZXRob2Q7XG5leHBvcnRzLmFwcGVuZENTUyA9IGFwcGVuZENTUztcbmV4cG9ydHMuZm9ybWF0RGF0ZSA9IGZvcm1hdERhdGU7XG5leHBvcnRzLmdldExvY2FsU3RvcmFnZSA9IGdldExvY2FsU3RvcmFnZTtcbmV4cG9ydHMuc2V0TG9jYWxTdG9yYWdlID0gc2V0TG9jYWxTdG9yYWdlO1xuZXhwb3J0cy5lbWl0RXZlbnRDYWNoZSA9IGVtaXRFdmVudENhY2hlO1xuZXhwb3J0cy5hZGRFdmVudENhY2hlID0gYWRkRXZlbnRDYWNoZTtcbmV4cG9ydHMucmVtb3ZlRXZlbnRDYWNoZSA9IHJlbW92ZUV2ZW50Q2FjaGU7XG5leHBvcnRzLkN1c3RFdmVudCA9IEN1c3RFdmVudDtcbmV4cG9ydHMuZ2V0QXR0ciA9IGdldEF0dHI7XG5leHBvcnRzLnNldEF0dHIgPSBzZXRBdHRyO1xuZXhwb3J0cy5hZGRDbGFzc05hbWUgPSBhZGRDbGFzc05hbWU7XG5leHBvcnRzLnJlbW92ZUNsYXNzTmFtZSA9IHJlbW92ZUNsYXNzTmFtZTtcbmV4cG9ydHMuaGFzQ2xhc3NOYW1lID0gaGFzQ2xhc3NOYW1lO1xuZXhwb3J0cy5yZW1vdmVFdmVudCA9IHJlbW92ZUV2ZW50O1xuZXhwb3J0cy5hZGRFdmVudCA9IGFkZEV2ZW50O1xuZXhwb3J0cy5hZGREZWxlZ2F0ZSA9IGFkZERlbGVnYXRlO1xuZXhwb3J0cy5yZW1vdmVEZWxlZ2F0ZSA9IHJlbW92ZURlbGVnYXRlO1xuZXhwb3J0cy5nZXRTdHlsZSA9IGdldFN0eWxlO1xuZXhwb3J0cy5zZXRTdHlsZSA9IHNldFN0eWxlO1xuZXhwb3J0cy5xdWVyeSA9IHF1ZXJ5O1xuZXhwb3J0cy5yZW1vdmVFbCA9IHJlbW92ZUVsO1xuZXhwb3J0cy5maW5kUGFyZW50cyA9IGZpbmRQYXJlbnRzO1xuZXhwb3J0cy4kID0gJDtcbmV4cG9ydHMuTm9kZVdyYXAgPSBOb2RlV3JhcDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jaGltZWUtaGVscGVyL2xpYi9pbmRleC5icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\r\n\tif(!originalModule.webpackPolyfill) {\r\n\t\tvar module = Object.create(originalModule);\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"exports\", {\r\n\t\t\tenumerable: true,\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanM/Y2M5NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XHJcblx0aWYoIW9yaWdpbmFsTW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiZXhwb3J0c1wiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9oYXJtb255LW1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(4);


/***/ })
/******/ ]);